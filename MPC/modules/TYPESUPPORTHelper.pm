package TYPESUPPORTHelper;

# ************************************************************
# Description   : Command helper for OSPL idlpp generated files. Required
#                 because of our (shall we say) unusual output file naming
#                 conventions.
#
#                 The command helper factory get() method converts the define
#                 custom type provided to uppercase, removes the '_FILES' portion
#                 and adds 'Helper' to the end.  If a module is found matching
#                 that name, it will be used to assist the ProjectCreator
#                 in determining which output files will be generated by
#                 the command given the file name and command options.
#                 This therefore is the helper for the OpenSplice
#                 Typesupport_Files entries in .mpc files.
# $Id:$
# ************************************************************

use strict;
use File::Basename;

# RedHat EL 4/5 uses perl 5.8.x/Getopt::Long v2.34/5
# Redhat EL 6 uses perl 5.10/Getopt::Long >= v2.36 which is
# earliest GetOptionsFromString is available...
#use Getopt::Long qw(GetOptionsFromString);
use Getopt::Long;

Getopt::Long::Configure ("bundling_override");
Getopt::Long::Configure ("pass_through");

my %required;
my %notfound;

# ... (see above) so we have to roll our own 'GetOptionsFromString'
sub _GetOptionsFromString(@) {
    my ($string) = shift;
    require Text::ParseWords;
    my @temp=@ARGV;
    @ARGV = Text::ParseWords::shellwords($string);
    my $ret = GetOptions(@_);
    my @args=@ARGV;
    @ARGV=@temp;
    return ( $ret, \@args );
}

sub new {
  my $class = shift;
  return bless {}, $class;
}

sub get_output {
  ## This method is called with the filename and command options and
  ## expects an array reference containing filenames that will be
  ## generated, but can not be described using the normal Define_Custom
  ## syntax.
  my ($self, $types_idl_file, $idlpp_args)  = @_;
  # print "typesupport helper called for $types_idl_file, $idlpp_args\n";
  ## Remove file name extension
  $types_idl_file =~ s/\.[^\.]+$//;
  my $base;
  my @filenames;

  ## Correctly deal with pre filename and directories if they exist
  if ($types_idl_file =~ /(.*[\/\\])([^\/\\]+)$/) {
      ## Split the directory and base name of the file.
      $base = $2;
  }
  else {
      $base = $types_idl_file;
  }

  ## Need to know what to generate now
  my $language = '';
  my $mode = '';
  my $standalone = 1;
  my $output_dir = '';
  my $is_streams = '';
  my $generate_tests = '';
  my $face = '';
  my $left_over_args;
  my $ret;
  ($ret, $left_over_args) = _GetOptionsFromString($idlpp_args,
                              'S' => \$standalone,
                              'N' => \$standalone,
                              'C' => sub { $standalone = 0 },
                              'T' => \$generate_tests,
                              'd=s' => \$output_dir,
                              'l=s' => \$language,
                              'm=s' => \$mode,
                              'F' => \$face);

  if ($output_dir ne '' && $output_dir !~ /\/$/ )
  {
    $output_dir = "$output_dir/";
  }

  if (($language eq 'cpp') || ($language eq 'c++')
      || ($language eq 'isocpp') || ($language eq 'isoc++'))
  {
    push @filenames, "$output_dir$base" . "SplDcps.cpp";
    push @filenames, "$output_dir$base" . "SplDcps.h";
    push @filenames, "$output_dir$base" . "Dcps_impl.cpp";
    push @filenames, "$output_dir$base" . "Dcps_impl.h";
    if (($language eq 'isocpp') || ($language eq 'isoc++'))
    {
        push @filenames, "$output_dir$base" . '_DCPS.hpp';
    }
    else
    {
        push @filenames, "$output_dir" . "ccpp_$base" . '.h';
    }
    if ($standalone == 1)
    {
      push @filenames, "$output_dir$base" . ".cpp";
      push @filenames, "$output_dir$base" . ".h";
      push @filenames, "$output_dir$base" . "Dcps.cpp";
      push @filenames, "$output_dir$base" . "Dcps.h";
    }
    else
    {
        # @todo - This is a workaround hack. Headers and inline are
        # getting picked up but these aren't. Remove & raise / fix bug.
        push @filenames, "$output_dir$base" . "Dcps.idl";
    }
    if ($generate_tests == 1)
    {
       push @filenames, "$output_dir$base" . "_testmethod.h";
    }
  }
  else
  {
    if ($language eq 'isocpp2')
    {
        push @filenames, "$output_dir$base" . "SplDcps.cpp";
        push @filenames, "$output_dir$base" . "SplDcps.h";
        push @filenames, "$output_dir$base" . '_DCPS.hpp';
        if ($standalone == 1)
        {
            push @filenames, "$output_dir$base" . ".cpp";
            push @filenames, "$output_dir$base" . ".h";
        }
        else
        {
            # @todo - This is a workaround hack. Headers and inline are
            # getting picked up but these aren't. Remove & raise / fix bug.
            push @filenames, "$output_dir$base" . "Dcps.idl";
        }
        if ($face == 1)
        {
            push @filenames, "$output_dir$base" . "_FACE.cpp";
            push @filenames, "$output_dir$base" . "_FACE.hpp";
        }
    }
    else
    {
      if ($language eq 'c')
      {
          if ($mode eq 'SPLTYPE')
          {
              push @filenames, "$output_dir$base" . "SplType.h";
          }
          else
          {
              ## sac can be done with the usual mechanism as it very sensibly
              ## opted to stick to consistently just suffixing the file base name
              ## with something
          }
      }
      else
      {
          if ($language eq 'cs')
          {
              push @filenames, "$output_dir$base" . ".cs";
              push @filenames, "$output_dir$base" . "Dcps.cs";
              push @filenames, "$output_dir$base" . "SplDcps.cs";
              push @filenames, "$output_dir" . 'I' . "$base" . "Dcps.cs";
          }
      }
    }
  }
  return \@filenames;
}

sub get_outputexts {
  ## This method is expected to return an array reference containing the
  ## extensions for files returned by the get_output() method.  They will
  ## be used as regular expressions so regular expression characters
  ## (such as '.', '[', ']', etc.) must be escaped.  This can be done by
  ## calling $self->Parser::escape_regex_special($str);
  my $self = shift;
  my @exts = ($self->Parser::escape_regex_special(".cpp"),
           $self->Parser::escape_regex_special(".h"),
           $self->Parser::escape_regex_special(".cs"),
            $self->Parser::escape_regex_special(".idl"));
  return \@exts;
}

sub get_tied {
  ## This method is called with a file name and an array reference of
  ## files.  The first expected return value is an array reference of those
  ## files listed in the passed array reference that are in some way tied
  ## to the file name passed in.  The second is a component name to help
  ## MPC figure out a way to tie the files together.  The result of "tied"
  ## files is that they may be compiled after the file name passed in.
  return [], undef;
}

1;
