/* -*- c++ -*- */

/*****************************************************************************
 **
 **  kernelModule contains definitions exposed on the network; in
 **  preceding versions a bit too much internal detail got exposed, so
 **  we have to work rather hard at preserving backwards compatibility
 **  to completely separate the internal structures from those exposed
 **  over the network, without changing any externally visible details
 **  and without running into having multiple definitions in the
 **  source code.
 **
 **  The only data currently explicitly exposed on the network are the
 **  built-in topics; v_message used to be exposed but that has been
 **  solved by changing all locations where it used to get
 **  (de)serialised.
 **
 **  Obviously, anything the built-in topics depend on need to be
 **  exposed as well
 **
 *****************************************************************************/

#include "os_retcode.h"

module kernelModule {
    typedef c_time v_duration;

    typedef struct v_gid_s {
        c_ulong systemId; /* kernelId + sessionId */
        c_ulong localId;
        c_ulong serial;
    } v_gid;

    typedef v_gid v_builtinTopicKey;

    enum v_durabilityKind {
        V_DURABILITY_VOLATILE,
        V_DURABILITY_TRANSIENT_LOCAL,
        V_DURABILITY_TRANSIENT,
        V_DURABILITY_PERSISTENT
    };

    enum v_presentationKind {
        V_PRESENTATION_INSTANCE,
        V_PRESENTATION_TOPIC,
        V_PRESENTATION_GROUP
    };

    enum v_livelinessKind {
        V_LIVELINESS_AUTOMATIC,
        V_LIVELINESS_PARTICIPANT,
        V_LIVELINESS_TOPIC
    };

    enum v_reliabilityKind {
        V_RELIABILITY_BESTEFFORT,
        V_RELIABILITY_RELIABLE
    };

    enum v_ownershipKind {
        V_OWNERSHIP_SHARED,
        V_OWNERSHIP_EXCLUSIVE
    };

    enum v_historyQosKind { /* Note: the only with Qos in the name */
        V_HISTORY_KEEPLAST,
        V_HISTORY_KEEPALL
    };

    /* Typedef here is not actually used in kernelModule, but it
       allows us to treat all spec'd QoS kinds as defined in
       kernelModule */
    typedef v_historyQosKind v_historyKind;

    enum v_orderbyKind {
        V_ORDERBY_RECEPTIONTIME,
        V_ORDERBY_SOURCETIME
    };

    enum v_invalidSampleVisibilityKind {
        V_VISIBILITY_NO_INVALID_SAMPLES,
        V_VISIBILITY_MINIMUM_INVALID_SAMPLES,
        V_VISIBILITY_ALL_INVALID_SAMPLES
    };

    struct v_userDataPolicy { /* Used by v_participantInfo, not by others */
        ARRAY<c_octet>                   value;
        c_long                           size;
    };

    struct v_transportPolicy {
        c_long                            value;
    };

    struct v_lifespanPolicy {
        v_duration                        duration;
    };

    struct v_durabilityPolicy {
        v_durabilityKind                  kind;
    };

    struct v_durabilityServicePolicy {
        v_duration                        service_cleanup_delay;
        v_historyQosKind                  history_kind;
        c_long                            history_depth;
        c_long                            max_samples;
        c_long                            max_instances;
        c_long                            max_samples_per_instance;
    };

    struct v_presentationPolicy {
        v_presentationKind                access_scope;
        c_bool                            coherent_access;
        c_bool                            ordered_access;
    };

    struct v_deadlinePolicy {
        v_duration                       period;
    };

    struct v_latencyPolicy {
        v_duration                       duration;
    };

    struct v_ownershipPolicy {
        v_ownershipKind                   kind;
    };

    struct v_strengthPolicy {
        c_long                            value;
    };

    struct v_livelinessPolicy {
        v_livelinessKind                  kind;
        v_duration                        lease_duration;
    };

    struct v_reliabilityPolicy {
        v_reliabilityKind                 kind;
        v_duration                        max_blocking_time;
        c_bool                            synchronous;
    };

    struct v_historyPolicy {
        v_historyQosKind                  kind;
        c_long                            depth;
    };

    struct v_orderbyPolicy {
        v_orderbyKind                     kind;
    };

    struct v_resourcePolicy {
        c_long                            max_samples;
        c_long                            max_instances;
        c_long                            max_samples_per_instance;
    };

    struct v_pacingPolicy {
        v_duration                        minSeperation;
    };

    struct v_writerLifecyclePolicy {
        c_bool                            autodispose_unregistered_instances;
        v_duration                        autopurge_suspended_samples_delay;
        v_duration                        autounregister_instance_delay;
    };

    struct v_readerLifecyclePolicy {
        v_duration                        autopurge_nowriter_samples_delay;
        v_duration                        autopurge_disposed_samples_delay;
        c_bool                            autopurge_dispose_all;
        c_bool                            enable_invalid_samples;
        v_invalidSampleVisibilityKind     invalid_sample_visibility;
    };

    struct v_userKeyPolicy {
        c_bool                            enable;
        c_string                          expression;
    };

    struct v_readerLifespanPolicy {
        c_bool                               used;
        v_duration                           duration;
    };

    struct v_entityFactoryPolicy {
        c_bool                            autoenable_created_entities;
    };

    struct v_sharePolicy {
        c_string                          name;
        c_bool                            enable;
    };

    struct v_builtinPartitionPolicy {
        sequence<c_string> name;
    };

    struct v_builtinTopicDataPolicy {
        ARRAY<c_octet> value;
    };

    struct v_builtinGroupDataPolicy {
        ARRAY<c_octet> value;
    };

    struct v_builtinUserDataPolicy {
        ARRAY<c_octet> value;
    };

    struct v_productDataPolicy {
        c_string value;
    };

    struct v_participantCMInfo {
        /* The '_' before the fieldname is an escape, since the word
           'key' is reserved.  The odl parser will remove this '_'
           character and process accordingly.
        */
        v_builtinTopicKey                        _key;
        v_productDataPolicy                      product;
    };

    struct v_participantInfo {
        /* The '_' before the fieldname is an escape, since the word
           'key' is reserved.  The odl parser will remove this '_'
           character and process accordingly.
        */
        v_builtinTopicKey                        _key;
        v_userDataPolicy                         user_data;
    };

    typedef short v_dataRepresentationId_t;

    const v_dataRepresentationId_t V_XCDR_REPRESENTATION = 0;
    const v_dataRepresentationId_t V_XML_REPRESENTATION  = 1;
    const v_dataRepresentationId_t V_OSPL_REPRESENTATION  = 0x400;
    const v_dataRepresentationId_t V_GPB_REPRESENTATION  = 0x401;

    typedef struct v_typeHash_s {
        unsigned long long msb;
        unsigned long long lsb;
    } v_typeHash;

    struct v_topicInfo {
        v_builtinTopicKey                        _key;
        c_string                                 name;
        c_string                                 type_name;
        v_durabilityPolicy                       durability;
        v_durabilityServicePolicy                durabilityService;
        v_deadlinePolicy                         deadline;
        v_latencyPolicy                          latency_budget;
        v_livelinessPolicy                       liveliness;
        v_reliabilityPolicy                      reliability;
        v_transportPolicy                        transport_priority;
        v_lifespanPolicy                         lifespan;
        v_orderbyPolicy                          destination_order;
        v_historyPolicy                          history;
        v_resourcePolicy                         resource_limits;
        v_ownershipPolicy                        ownership;
        v_builtinTopicDataPolicy                 topic_data;
        /* all fields above must be memory layout compatible with the
           dds spec. */
        c_string                                 meta_data;
        c_string                                 key_list;
    };

    struct v_typeInfo {
        c_string                                 name;
        v_dataRepresentationId_t                 data_representation_id;
        v_typeHash                               type_hash;
        sequence<c_octet>                        meta_data;
        sequence<c_octet>                        extentions;
    };

    struct v_publicationInfo {
        v_builtinTopicKey                        _key;
        v_builtinTopicKey                        participant_key;
        c_string                                 topic_name;
        c_string                                 type_name;
        v_durabilityPolicy                       durability;
        v_deadlinePolicy                         deadline;
        v_latencyPolicy                          latency_budget;
        v_livelinessPolicy                       liveliness;
        v_reliabilityPolicy                      reliability;
        v_lifespanPolicy                         lifespan;
        v_orderbyPolicy                          destination_order;
        v_builtinUserDataPolicy                  user_data;
        v_ownershipPolicy                        ownership;
        v_strengthPolicy                         ownership_strength;
        v_presentationPolicy                     presentation;
        v_builtinPartitionPolicy                 partition;
        v_builtinTopicDataPolicy                 topic_data;
        v_builtinGroupDataPolicy                 group_data;

        /* all fields above must be memory layout compatible with the
           dds spec. */
        v_writerLifecyclePolicy                  lifecycle;

        /* Indicates whether the writer is alive or not, with respect
         * to liveliness policy. */
        c_bool                                   alive;
    };

    struct v_dataWriterCMInfo {
        v_builtinTopicKey                        _key;
        v_productDataPolicy                      product;
        v_builtinTopicKey                        publisher_key;
        c_string                                 name;
        v_historyPolicy                          history;
        v_resourcePolicy                         resource_limits;
        v_writerLifecyclePolicy                  writer_data_lifecycle; /* dups v_publicationInfo */
    };

    struct v_subscriptionInfo {
        v_builtinTopicKey                        _key;
        v_builtinTopicKey                        participant_key;
        c_string                                 topic_name;
        c_string                                 type_name;
        v_durabilityPolicy                       durability;
        v_deadlinePolicy                         deadline;
        v_latencyPolicy                          latency_budget;
        v_livelinessPolicy                       liveliness;
        v_reliabilityPolicy                      reliability;
        v_ownershipPolicy                        ownership;
        v_orderbyPolicy                          destination_order;
        v_builtinUserDataPolicy                  user_data;
        v_pacingPolicy                           time_based_filter;
        v_presentationPolicy                     presentation;
        v_builtinPartitionPolicy                 partition;
        v_builtinTopicDataPolicy                 topic_data;
        v_builtinGroupDataPolicy                 group_data;
        /* all fields above must be memory layout compatible with the
           dds spec. */

        /* Reader lifespan attribute added */
        v_readerLifespanPolicy                   lifespan;
    };

    struct v_dataReaderCMInfo {
        v_builtinTopicKey                        _key;
        v_productDataPolicy                      product;
        v_builtinTopicKey                        subscriber_key;
        c_string                                 name;
        v_historyPolicy                          history;
        v_resourcePolicy                         resource_limits;
        v_readerLifecyclePolicy                  reader_data_lifecycle;
        v_userKeyPolicy                          subscription_keys;
        v_readerLifespanPolicy                   reader_lifespan; /* dups v_subscriptionInfo */
        v_sharePolicy                            share;
    };

    struct v_publisherCMInfo {
        v_builtinTopicKey                        _key;
        v_productDataPolicy                      product;
        v_builtinTopicKey                        participant_key;
        c_string                                 name;
        v_entityFactoryPolicy                    entity_factory;
        v_builtinPartitionPolicy                 partition;
    };

    struct v_subscriberCMInfo {
        v_builtinTopicKey                        _key;
        v_productDataPolicy                      product;
        v_builtinTopicKey                        participant_key;
        c_string                                 name;
        v_entityFactoryPolicy                    entity_factory;
        v_sharePolicy                            share;
        v_builtinPartitionPolicy                 partition;
    };

    struct v_deliveryInfo {
        v_gid   writerGID;
        v_gid   readerGID;
        c_ulong sequenceNumber;
    };

    struct v_heartbeatInfo {
        v_gid       id;
        v_duration period;
    };

    /* Note: Additional values may only be added at the end of this
       enum otherwise compatiability with previous versions will be
       broken! */
    enum v_controlAndMonitoringCommandKind {
        V_COMMAND_DISPOSE_ALL_DATA
    };

    /* Note: To preseve compatablity this struct must never be
       altered, ( changed api's must be implemented by adding a new
       struct and registering in the above enum ) */
    struct v_commandDisposeAllData
    {
        c_string topicExpr;
        c_string partitionExpr;
    };

    typedef struct v_controlAndMonitoringCommand_s
    {
        v_builtinTopicKey _key;
        union command_kind switch ( v_controlAndMonitoringCommandKind ) {
            case V_COMMAND_DISPOSE_ALL_DATA :
                v_commandDisposeAllData dispose_all_data_info;
        } u;
    } v_controlAndMonitoringCommand;

    typedef ARRAY<c_octet> v_messageQos;

    /* v_nodeExt has no business being here, but is used to work
       around the unstable ordering of fields in the generated C
       types: the CDR-serialiser serialises in memory order, whereas
       the other serialisers (XML, BigE, RT networking) serialise in
       order of field enumeration by c_scopeWalk. */
    class v_nodeExt {
        /* see kernelModuleI::v_state, not all of the bits ever get
           exported, so need to work out what nodeState's definition
           is */
        attribute c_ulong nodeState;
    };

    class v_messageExt extends v_nodeExt {
        attribute c_time allocTime;
        attribute c_time writeTime;
        attribute v_gid writerGID;
        attribute v_gid writerInstanceGID;
        attribute c_ulong sequenceNumber;
        attribute c_ulong transactionId;
        attribute v_messageQos qos;
    };

    /* The transaction ID is a tuple of writer GID and writer
       transaction number */
    struct v_tid {
        v_gid   wgid;
        c_ulong seqnr;
    };

    /* The end-of-transaction message identifies the end of a
     * transaction and in case of group coherence contains a list of
     * all other participating writer transactions.
     */
    class v_messageEOTExt extends v_messageExt {
        attribute c_ulong         publisherId;
        attribute c_ulong         transactionId;
        attribute sequence<v_tid> tidList;
    };
};

/*****************************************************************************
 **
 **  kernelModuleI contains internal definitions (not exposed on the
 **  network)
 **
 *****************************************************************************/

module kernelModuleI {
    typedef c_ulong v_state;

    enum v_writeResult {
        V_WRITE_UNDEFINED = (OS_RETCODE_ID_V_WRITE_RESULT),
        V_WRITE_SUCCESS,
        V_WRITE_SUCCESS_NOT_STORED,
        V_WRITE_REGISTERED,
        V_WRITE_UNREGISTERED,
        V_WRITE_PRE_NOT_MET,
        V_WRITE_ERROR,
        V_WRITE_TIMEOUT,
        V_WRITE_OUT_OF_RESOURCES,
        V_WRITE_REJECTED,
        V_WRITE_DUPLICATE,
        V_WRITE_COUNT
    };

    enum v_messageContext {
        V_CONTEXT_UNDEFINED,
        V_CONTEXT_GROUPWRITE,
        V_CONTEXT_TRANSACTIONFLUSH,
        V_CONTEXT_GETHISTORY,
        V_CONTEXT_COUNT
    };

    enum v_dataReaderResult {
        V_DATAREADER_INSERTED = (OS_RETCODE_ID_V_DATAREADER_RESULT),
        V_DATAREADER_OUTDATED,
        V_DATAREADER_NOT_OWNER,
        V_DATAREADER_MAX_SAMPLES,
        V_DATAREADER_MAX_INSTANCES,
        V_DATAREADER_INSTANCE_FULL,
        V_DATAREADER_SAMPLE_LOST,
        V_DATAREADER_DUPLICATE_SAMPLE,
        V_DATAREADER_OUT_OF_MEMORY,
        V_DATAREADER_INTERNAL_ERROR,
        V_DATAREADER_UNDETERMINED,
        V_DATAREADER_FILTERED_OUT,
        V_DATAREADER_COUNT
    };

    class v_threadInfo {
        /* The thread-id (as an int) is an os_ulong_int, which has a platform
         * dependent size. This cannot be modeled in the kernel odl, so
         * c_ulonglong was picked since an os_ulong_int should always fit in the
         * 64 bits c_ulonglong. */
        attribute c_ulonglong threadId;
        /* Pointer to os_mutex; Can ONLY be locked by owning process! Never
         * contended except for administrative purposes. */
        attribute c_voidp lock;
        attribute c_voidp mtx; /* Pointer to c_mutex */
        attribute c_voidp cnd; /* Pointer to c_cond */
        /* Serial of the domain this thread info belongs to. May be used in reporting,
         * signalhandling, etc. Lower 2 bytes are the domainId. */
        attribute c_ulong serial;
        /* Protectcount for this thread. Just for reporting. */
        attribute c_ulong protectCount;
        /* Flags for this thread. Just for reporting. */
        attribute c_ulong flags;
    };

    class v_processInfo {
        /* The process-id is an os_int, which has a platform dependent size. This
         * cannot be modeled in the kernel odl, so c_longlong was picked since
         * an os_int should always fit in the 64 bits c_longlong. */
        attribute c_longlong processId;
        /* Counter for the number of threads of the process currently accessing SHM.
         * This counter includes threads currently waiting/sleeping. This counter
         * must be atomically updated and its value can only be interpreted directly
         * if it is guaranteed not to be changed anymore. */
        attribute pa_uint32_t protectCount;
        /* Counter for the number of threads of the process currently waiting/sleeping
         * in SHM. This counter must be atomically updated and its value can only be
         * interpreted directly if it is guaranteed not to be changed anymore. In
         * order to obtain the number of non-waiting threads in SHM of a process
         * that disappeared, this count should be deducted from the protectCount. */
        attribute pa_uint32_t waitCount;
        /* Counter for the number of threads of the process that are blocked (
         * intentionally deadlocked on a process private muytex). */
        attribute pa_uint32_t blockedCount;
        /* Serial of the domain this process info belongs to. May be used in reporting,
         * signalhandling, etc. Lower 2 bytes are the domainId. */
        attribute c_ulong serial;
        /* Set containing the thread-records for threads of this process that accessed
         * this domain. */
        attribute SET<v_threadInfo> threads; /* actually a c_table<v_threadInfo.threadId> */
        /* Lock protecting the threads-table */
        attribute c_mutex lock;
    };

    /* -------------------------------------------------------------------------- */
    /* Statistics implementation                                                 */
    /* -------------------------------------------------------------------------- */

    typedef struct v_timedValue_s {
        os_timeW lastUpdate;
        c_ulong value;
    } v_timedValue;

    typedef v_timedValue v_minValue;
    typedef v_timedValue v_maxValue;

    typedef struct v_avgValue_s {
        c_ulong count;
        c_float value;
    } v_avgValue;

    typedef struct v_fullCounter_s {
        c_ulong    value;
        v_minValue min;
        v_maxValue max;
        v_avgValue avg;
    } v_fullCounter;

    /* This is an abstract class! */
    class v_statistics {
        attribute os_timeW           lastReset;
    };

    class v_writerStatistics extends v_statistics {
        attribute c_ulong            numberOfWrites;
        attribute c_ulong            numberOfDisposes;
        attribute c_ulong            numberOfRegisters;
        attribute c_ulong            numberOfImplicitRegisters;
        attribute c_ulong            numberOfUnregisters;
        attribute c_ulong            numberOfTimedOutWrites;
        attribute c_ulong            numberOfWritesBlockedBySamplesLimit;
        attribute c_ulong            numberOfWritesBlockedByInstanceLimit;
        attribute c_ulong            numberOfWritesBlockedBySamplesPerInstanceLimit;
        attribute c_ulong            numberOfRetries;

        attribute c_ulong            numberOfInstancesWithStatusAlive;
        attribute c_ulong            numberOfInstancesWithStatusDisposed;
        attribute c_ulong            numberOfInstancesWithStatusUnregistered;
        attribute c_ulong            numberOfSamples;
        attribute v_maxValue         maxNumberOfSamplesPerInstance;
    };

    class v_dataReaderStatistics extends v_statistics {
        attribute v_maxValue         maxSampleSize;
        attribute v_maxValue         maxSamplesPerInstance;
        attribute v_maxValue         maxNumberOfSamples;
        attribute v_maxValue         maxNumberOfInstances;

        attribute c_ulong            numberOfSamples;
        attribute c_ulong            numberOfInstances;

        attribute v_fullCounter      readLatency;
        attribute v_fullCounter      transportLatency;

        attribute c_ulong            numberOfInstancesWithStatusNew;
        attribute c_ulong            numberOfInstancesWithStatusAlive;
        attribute c_ulong            numberOfInstancesWithStatusDisposed;
        attribute c_ulong            numberOfInstancesWithStatusNoWriters;

        attribute c_ulong            numberOfSamplesWithStatusRead;
        attribute c_ulong            numberOfSamplesExpired;
        attribute c_ulong            numberOfSamplesPurgedByDispose;
        attribute c_ulong            numberOfSamplesPurgedByNoWriters;

        attribute c_ulong            numberOfSamplesArrived;
        attribute c_ulong            numberOfSamplesInserted;
        attribute c_ulong            numberOfSamplesDiscarded;
        attribute c_ulong            numberOfSamplesRead;
        attribute c_ulong            numberOfSamplesTaken;
        attribute c_ulong            numberOfSamplesLost;
        attribute c_ulong            numberOfSamplesRejectedBySamplesLimit;
        attribute c_ulong            numberOfSamplesRejectedByInstancesLimit;

        attribute c_ulong            numberOfReads;
        attribute c_ulong            numberOfInstanceReads;
        attribute c_ulong            numberOfNextInstanceReads;
        attribute c_ulong            numberOfInstanceLookups;
        attribute c_ulong            numberOfTakes;
        attribute c_ulong            numberOfInstanceTakes;
        attribute c_ulong            numberOfNextInstanceTakes;
    };

    class v_queryStatistics extends v_statistics {
        attribute c_ulong            numberOfReads;
        attribute c_ulong            numberOfInstanceReads;
        attribute c_ulong            numberOfNextInstanceReads;
        attribute c_ulong            numberOfTakes;
        attribute c_ulong            numberOfInstanceTakes;
        attribute c_ulong            numberOfNextInstanceTakes;
    };

    class v_networkQueueStatistics { /* Reachable via v_networkReaderStatistics only */
        attribute c_string           name;
        attribute c_ulong            numberOfSamplesArrived;
        attribute c_ulong            numberOfSamplesInserted;
        attribute c_ulong            numberOfSamplesRejected;
        attribute v_fullCounter      numberOfSamplesWaiting;
        attribute c_ulong            numberOfSamplesTaken;
    };

    class v_networkReaderStatistics extends v_statistics {
        attribute c_ulong            queuesCount;
        attribute ARRAY<v_networkQueueStatistics> queues;
    };

    class v_networkChannelStatistics { /* Reachable via v_networkingStatistics only */
        attribute c_string           name;
        attribute c_ulong            numberOfMessagesSent;
        attribute c_ulong            numberOfBytesSent;
        attribute c_ulong            numberOfPacketsSent;

        attribute c_ulong            numberOfMessagesFragmented;
        attribute c_ulong            numberOfMessagesPacked;

        attribute c_ulong            numberOfKnownNodes;
        attribute c_ulong            numberOfBytesResent;
        attribute c_ulong            numberOfPacketsResent;
        attribute c_ulong            numberOfBytesInResendBuffer;
        attribute c_ulong            numberOfPacketsInResendBuffer;
        attribute c_ulong            maxNumberOfBytesResentToOneNode;
        attribute c_ulong            maxNumberOfPacketsResentToOneNode;

        attribute c_ulong            numberOfMessagesReceived;
        attribute c_ulong            numberOfBytesReceived;
        attribute c_ulong            numberOfPacketsReceived;
        attribute c_ulong            numberOfPacketsLost;
        attribute c_ulong            numberOfPacketsOutOfOrder;
        attribute c_ulong            numberOfAcksSent;

        attribute c_ulong            numberOfMessagesDelivered;
        attribute c_ulong            numberOfBytesDelivered;
        attribute c_ulong            numberOfMessagesNotInterested;
        attribute c_ulong            numberOfBytesNotInterested;
        attribute c_ulong            numberOfPacketsReliabilityMismatch;
        attribute c_ulong            numberOfPacketsNotConnectedPartition;
        attribute c_ulong            numberOfPacketsUnknownPartition;
        attribute c_ulong            numberOfPacketsUnknownAddress;
        attribute c_ulong            numberOfPacketsInvalid;
        attribute c_ulong            numberOfPacketsOutOfOrderDropped;
        attribute c_ulong            nofFreePacketBuffers;
        attribute c_ulong            nofUsedPacketBuffers;

        attribute c_ulong            reorderAdminPacketsQueued;
        attribute v_avgValue         reorderAdminPacketsQueuedAvg;
        attribute v_maxValue         reorderAdminPacketsQueuedMax;
        attribute v_minValue         reorderAdminPacketsQueuedMin;
        attribute c_ulong            reorderAdminBytesQueued;
        attribute v_avgValue         reorderAdminBytesQueuedAvg;
        attribute v_maxValue         reorderAdminBytesQueuedMax;
        attribute v_minValue         reorderAdminBytesQueuedMin;

        attribute c_ulong            ringBufferMessagesQueued;
        attribute v_avgValue         ringBufferMessagesQueuedAvg;
        attribute v_maxValue         ringBufferMessagesQueuedMax;
        attribute v_minValue         ringBufferMessagesQueuedMin;

        attribute c_ulong            resendAdminPacketsQueued;
        attribute v_avgValue         resendAdminPacketsQueuedAvg;
        attribute v_maxValue         resendAdminPacketsQueuedMax;
        attribute v_minValue         resendAdminPacketsQueuedMin;
        attribute c_ulong            resendAdminBytesQueued;
        attribute v_avgValue         resendAdminBytesQueuedAvg;
        attribute v_maxValue         resendAdminBytesQueuedMax;
        attribute v_minValue         resendAdminBytesQueuedMin;

        attribute v_fullCounter      adminQueueAcks;
        attribute v_fullCounter      adminQueueData;

        attribute c_ulong            nofBytesBeforeCompression;
        attribute c_ulong            nofBytesAfterCompression;
        attribute c_ulong            nofBytesBeforeDecompression;
        attribute c_ulong            nofBytesAfterDecompression;
    };

    class v_networkingStatistics extends v_statistics  {
        attribute c_ulong            numberOfErrors;
        attribute c_ulong            channelsCount;
        attribute ARRAY<v_networkChannelStatistics> channels;
    };

    class v_cmsoapStatistics  extends v_statistics {
        attribute v_maxValue         maxConnectedClients;
        attribute v_maxValue         maxClientThreads;
        attribute c_ulong            connectedClients;
        attribute c_ulong            clientThreads;
        attribute c_ulong            requestsHandled;
    };

    class v_groupQueueStatistics extends v_statistics {
        attribute c_ulong            numberOfWrites;
        attribute c_ulong            numberOfReads;
        attribute c_ulong            numberOfTakes;
        attribute v_fullCounter      numberOfSamples;
    };

    class v_durabilityStatistics extends v_statistics  {
        attribute c_ulong            persistentSamplesWritten;
        attribute v_maxValue         fellowsKnownMax;
        attribute c_ulong            fellowsKnown;
        attribute c_ulong            fellowsApproved;
        attribute c_ulong            fellowsIncompatibleState;
        attribute c_ulong            fellowsIncompatibleDataModel;
        attribute c_ulong            nameSpacesKnown;
        attribute c_ulong            nameSpacesMaster;
        attribute c_ulong            nameSpacesSlave;
        attribute c_ulong            groupsToCreateTotal;
        attribute c_ulong            groupsToCreateVolatile;
        attribute c_ulong            groupsToCreateTransient;
        attribute c_ulong            groupsToCreatePersistent;
        attribute c_ulong            groupsKnownTotal;
        attribute c_ulong            groupsKnownVolatile;
        attribute c_ulong            groupsKnownTransient;
        attribute c_ulong            groupsKnownPersistent;
        attribute c_ulong            groupsCompleteTotal;
        attribute c_ulong            groupsCompleteVolatile;
        attribute c_ulong            groupsCompleteTransient;
        attribute c_ulong            groupsCompletePersistent;
        attribute c_ulong            groupsIncompleteTotal;
        attribute c_ulong            groupsIncompleteVolatile;
        attribute c_ulong            groupsIncompleteTransient;
        attribute c_ulong            groupsIncompletePersistent;
        attribute c_ulong            groupsIgnoredTotal;
        attribute c_ulong            groupsIgnoredVolatile;
        attribute c_ulong            groupsIgnoredTransient;
        attribute c_ulong            groupsIgnoredPersistent;
        attribute c_ulong            alignerRequestsReceived;
        attribute c_ulong            alignerRequestsIgnored;
        attribute c_ulong            alignerRequestsAnswered;
        attribute c_ulong            alignerRequestsOpen;
        attribute v_maxValue         alignerRequestsOpenMax;
        attribute c_ulong            alignerRequestsCombined;
        attribute c_ulong            alignerRequestsCombinedOpen;
        attribute v_maxValue         alignerRequestsCombinedOpenMax;
        attribute c_ulong            alignerRequestsCombinedAnswered;
        attribute c_ulong            aligneeRequestsSent;
        attribute v_maxValue         aligneeRequestsOpenMax;
        attribute c_ulong            aligneeRequestsOpen;
        attribute c_ulong            aligneeRequestsWaiting;
        attribute v_maxValue         aligneeRequestsWaitingMax;
        attribute c_ulong            aligneeSamplesTotal;
        attribute c_ulong            aligneeSamplesRegister;
        attribute c_ulong            aligneeSamplesWrite;
        attribute c_ulong            aligneeSamplesDispose;
        attribute c_ulong            aligneeSamplesWriteDispose;
        attribute c_ulong            aligneeSamplesUnregister;
        attribute c_ulong            alignerSamplesTotal;
        attribute c_ulong            alignerSamplesRegister;
        attribute c_ulong            alignerSamplesWrite;
        attribute c_ulong            alignerSamplesDispose;
        attribute c_ulong            alignerSamplesWriteDispose;
        attribute c_ulong            alignerSamplesUnregister;
        attribute c_ulong            aligneeTotalSize;
        attribute c_ulong            alignerTotalSize;
    };

    class v_kernelStatistics extends v_statistics  {
        attribute v_maxValue         maxShmUsed;
        attribute v_maxValue         maxShmGarbage;
        attribute v_maxValue         maxShmClaims;

        attribute c_ulong            shmUsed;
        attribute c_ulong            shmClaims;
        attribute c_ulong            shmClaimFails;
        attribute c_ulong            shmGarbage;
    };

    class v_rnrGroupStatistics extends v_statistics {
        attribute c_string           name;
        attribute c_ulong            numberOfSamplesRecorded;
        attribute c_ulong            numberOfBytesRecorded;
        attribute c_ulong            numberOfSamplesReplayed;
        attribute c_ulong            numberOfBytesReplayed;
        attribute v_fullCounter      dataRateRecorded;
        attribute v_fullCounter      dataRateReplayed;
    };

    class v_rnrStorageStatistics extends v_statistics {
        attribute c_string                      name;
        attribute SET<v_rnrGroupStatistics>    topics;          /* actually a c_table! */
    };

    class v_rnrStatistics extends v_statistics {
        attribute c_string                      name;
        attribute SET<v_rnrStorageStatistics>   storages;       /* actually a c_table! */
    };

    /* -------------------------------------------------------------------------- */
    /*  Handle server implementation                                              */
    /* -------------------------------------------------------------------------- */

    /* note that name convention applied to v_handleInfo_s is related to
       implementation of macro C_CAST */

    typedef struct v_handleInfo_s {
        /* object that is managed associated to the handle described by
           this info, or next handle in free list, depending on
           status_count & STATUS_ON_FREELIST. */
        c_address object_nextFree;

        /* handle generation for this specific handle. */
        c_ulong  serial;

        /* when in use: status in the top bits, the number of actual claims
           in the lower bits; when on freelist: status in the top bits,
           handle index in the lower bits */
        pa_uint32_t status_count_index;
    } v_handleInfo;

    typedef ARRAY<v_handleInfo> v_handleInfoList;

    class v_handleServer {
        attribute ARRAY<v_handleInfoList> handleInfos;   /* The list of all handle info records. */
        attribute c_ulong                 lastIndex;     /* The last index allocated. */
        attribute c_ulong                 freeListLength;/* THe length of the free list */
        attribute c_voidp /* v_handleInfo* */ firstFree;  /* The head of the handle info free list. */
        attribute c_voidp /* v_handleInfo* */ lastFree;   /* The tail of the handle info free list. */
        attribute c_type                  handleInfo_type;/* cached v_handleInfo */
        attribute c_mutex                 mutex;         /* The mutex that handles access to the server. */
    };

    /* note that name convention applied to v_handle_s is related to
       implementation of macro C_CAST */

    typedef struct v_handle_s {
        c_address server;       /* reference to the handle server. */
        c_ulong   index;        /* the index to the handle info record within the handle server. */
        c_ulong   serial;       /* the handle generation to which this handle belongs. */
    } v_handle;

    /* -------------------------------------------------------------------------- */
    /*  Kernel Infrastructure                                                     */
    /* -------------------------------------------------------------------------- */

    enum v_kind {
        K_KERNEL,            K_OBJECT,             K_ENTITY,
        K_GROUPSET,          K_STATUSCONDITION,
        K_OBJECTLOAN,        K_OBJECTBUFFER,
        K_WAITSET,           K_LISTENER,           K_CONDITION,
        K_QUERY,             K_DATAREADERQUERY,    K_DATAVIEW,
        K_PROJECTION,        K_MAPPING,            K_FILTER,
        K_DEADLINEINSTANCE,  K_DEADLINEINSTANCELIST,
        K_MESSAGE,           K_MESSAGEEOT,         K_EOTLISTELEMENT,
        K_TRANSACTIONADMIN,  K_TRANSACTION,        K_TRANSACTIONELEMENT,
        K_TRANSACTIONGROUPADMIN,                   K_TRANSACTIONGROUP,
        K_TRANSACTIONPUBLISHER,                    K_TRANSACTIONWRITER,
        K_TRANSACTIONGROUPWRITER,                  K_TRANSACTIONGROUPREADER,
        K_TRANSACTIONPENDING,
        K_WRITERINSTANCE,    K_WRITERSAMPLE,       K_WRITERCACHEITEM,
        K_GROUPINSTANCE,     K_GROUPSAMPLE,        K_GROUPCACHEITEM,
        K_DATAREADERINSTANCE,K_READERSAMPLE,
        K_DATAVIEWINSTANCE,  K_DATAVIEWQUERY,      K_DATAVIEWSAMPLE,
        K_ORDEREDINSTANCE,                         K_ORDEREDINSTANCESAMPLE,
                                                   K_WRITERINSTANCETEMPLATE,
        K_TOPIC,             K_TOPIC_ADAPTER,
        K_TYPEREPRESENTATION,
        K_PUBLISHER,         K_SUBSCRIBER,
        K_DOMAIN,            K_DOMAININTEREST,     K_DOMAINADMIN,
        K_READER,            K_WRITER,
        K_ENTRY,             K_DATAREADERENTRY,    K_DELIVERYSERVICEENTRY,
        K_GROUP,             K_WRITERGROUP,        K_CACHE,
        K_GROUPACTION,       K_GROUPSTREAM,
        K_GROUPQUEUE,        K_GROUPQUEUESAMPLE,
        K_DATAREADER,        K_DELIVERYSERVICE,    K_PARTICIPANT,
        K_PURGELISTITEM,     K_GROUPPURGEITEM,
        K_INDEX,
        K_READERSTATUS,      K_WRITERSTATUS,
        K_PUBLISHERSTATUS,   K_SUBSCRIBERSTATUS,
        K_DOMAINSTATUS,      K_TOPICSTATUS,
        K_PARTICIPANTSTATUS, K_KERNELSTATUS,
        K_WRITERSTATISTICS,  K_QUERYSTATISTICS,    K_DATAREADERSTATISTICS,
        K_PROXY,             K_WAITSETEVENT,       K_LISTENEREVENT,
        K_WAITSETEVENTHISTORYDELETE, K_WAITSETEVENTHISTORYREQUEST,
        K_WAITSETEVENTPERSISTENTSNAPSHOT, K_WAITSETEVENTCONNECTWRITER,
        K_SERVICEMANAGER,    K_SERVICE,            K_SERVICESTATE,
        K_NETWORKING,        K_DURABILITY,         K_CMSOAP,
        K_RNR,               K_NWBRIDGE,
        K_LEASEMANAGER,      K_LEASE,              K_LEASEACTION,
        K_SPLICED,
        K_CONFIGURATION,
        K_REGISTRATION,
        /* Networking types */
        K_NETWORKREADER,       K_NETWORKREADERENTRY,   K_NETWORKMESSAGE,
        /* kinds needed for quick lookup. Note that these are no v_object
         * descendents */
        K_NETWORKMAPENTRY,
        K_HISTORICALDELETEREQUEST,
        K_HISTORICALDATAREQUEST,
        K_PERSISTENTSNAPSHOTREQUEST,
        K_PENDINGDISPOSEELEMENT,
        K_WRITEREOTSAMPLE,
        K_GID, K_TID,
        K_RXODATA,
        K_DURABILITYCLIENT,	 K_DURABILITYCLIENTEVENT,  K_DURABILITYCLIENTSERVER,
        /* This constant must always be the last */
        K_TYPECOUNT
    };

    class v_object {
        attribute v_kind                         kind;
        attribute c_voidp                        kernel;
    };

    class v_public extends v_object {
        attribute v_handle                       handle;
        attribute c_voidp                        userDataPublic;
    };

    const c_long v_objectBufferLength = 64;

    class v_objectBuffer extends v_object {
        attribute v_objectBuffer next;
        attribute c_object       obj[v_objectBufferLength];
    };

    class v_objectLoan extends v_objectBuffer {
        attribute c_ulong       index;
    };

    /* This proxy can be used for both local and remote
       public objects.
    */
    class v_proxy extends v_object {
        attribute v_handle                       source;
        attribute c_voidp                        userData;
        attribute c_voidp                        source2;
        attribute v_proxy                        next;
    };

    class v_observable extends v_public {
        attribute c_mutex                        mutex;
        attribute v_proxy observers;
    };

    class v_observer extends v_observable {
        attribute c_cond                         cv;
        attribute c_mutex                        mutex;
        attribute c_long                         waitCount;
        attribute c_ulong                        eventMask;
        attribute c_ulong                        eventFlags;
        /* place to store event data by the observer */
        attribute c_voidp                        eventData;
    };

    class v_status extends v_object {
        attribute c_ulong                        state;
    };

    enum v_entityState { V_ENTITYSTATE_DISABLED, V_ENTITYSTATE_SUSPENDED, V_ENTITYSTATE_ENABLED };

    typedef c_ulong v_eventMask;

    class v_listenerEvent {
        attribute c_voidp source; /* source the event originates from */
        attribute c_ulong kind; /* Event kind */
        attribute c_voidp eventData; /* status or sample data */
        attribute c_voidp userData; /* destination reference of user object */
        attribute c_voidp listenerData; /* listener context to be called */
        attribute v_listenerEvent next;
    };

    class v_listener extends v_public {
        attribute c_cond cv;
        attribute c_mutex mutex;
        attribute v_listenerEvent eventList;
        attribute v_listenerEvent lastEvent; /* tail of the eventList */
        attribute c_voidp participant;
        attribute c_bool terminate;
        attribute c_ulong waitCount;
        attribute c_bool combine; /* if true then trigger only once on multiple data available events. */
    };

    class v_entity extends v_observer {
        attribute c_string                       name;
        attribute v_status                       status;
        attribute v_listener                     listener;
        attribute v_eventMask                    listenerInterest;
        attribute c_voidp                        listenerData;
        attribute c_bool                         enabled;
        attribute v_objectLoan                   loan;
    };

    class v_statusCondition extends v_observer {
        attribute v_proxy entity;
    };

    class v_query;

    class v_collection extends v_entity {
        attribute SET<v_query>                   queries;
    };

    class v_query extends v_collection {
        attribute c_voidp                        source;
        attribute v_queryStatistics              statistics;
        attribute c_string                       expression;
    };

    class v_dataReaderSample;

    class v_dataReaderQuery extends v_query {
        attribute ARRAY<c_query>         instanceQ; /* predicate on key fields */
        attribute ARRAY<c_query>         sampleQ;   /* predicate on non-key fields */
        attribute c_ulong                state;
        attribute c_bool                 walkRequired;
        attribute v_dataReaderSample     triggerValue;
        attribute v_state                sampleMask;
    };

    class v_dataViewSample;

    class v_dataViewQuery extends v_query {
        attribute ARRAY<c_query>         instanceQ; /* predicate on key fields */
        attribute ARRAY<c_query>         sampleQ;   /* predicate on non-key fields */
        attribute c_ulong                state;
        attribute c_bool                 walkRequired;
        attribute v_dataViewSample       triggerValue;
        attribute v_state                sampleMask;
    };

    class v_waitsetEvent {
        attribute v_handle source;
        attribute c_ulong kind;
        attribute c_voidp userData;
        attribute v_object eventData;
        attribute v_waitsetEvent next;
    };

    class v_waitset extends v_observer {
        /* The eventlist for the waitset is stored as eventData in v_observer */
        attribute c_voidp participant;
        attribute c_ulong count;
        attribute v_proxy observables;
        attribute c_bool waitsetEventEnabled;
        attribute c_ulong waitDisconnectCount;
        attribute c_cond syncDisconnect;
    };

    enum v_leaseActionId {
        V_LEASEACTION_UNDEFINED,
        V_LEASEACTION_SERVICESTATE_EXPIRED,
        V_LEASEACTION_READER_DEADLINE_MISSED,
        V_LEASEACTION_WRITER_DEADLINE_MISSED,
        V_LEASEACTION_LIVELINESS_CHECK,
        V_LEASEACTION_HEARTBEAT_SEND,
        V_LEASEACTION_HEARTBEAT_CHECK,
        V_LEASEACTION_SPLICED_DEATH_DETECTED,
        V_LEASEACTION_DISPOSE_TRANSACTION,
        V_LEASEACTION_MINIMUM_SEPARATION_EXPIRY,
        V_LEASEACTION_COUNT /* This constant must always be the last */
    };

    class v_leaseManager;

    enum v_leaseKind {
        V_LEASE_KIND_MONOTONIC,
        V_LEASE_KIND_ELAPSED,
        V_LEASE_KIND_COUNT /* This constant must always be the last */
    };

    typedef union v_leaseTime_s switch ( v_leaseKind ) {
        case V_LEASE_KIND_MONOTONIC: os_timeM tm;
        case V_LEASE_KIND_ELAPSED:   os_timeE te;
    } v_leaseTime;

    class v_lease extends v_object {
        attribute c_mutex                        mutex;
        attribute os_duration                    duration;
        attribute v_leaseTime                    expiryTime;
        attribute SET<v_leaseManager>            observers;
    };

    class v_leaseAction extends v_object
    {
        attribute v_lease lease;
        attribute v_leaseActionId actionId;
        attribute v_handle actionObject;
        attribute c_bool repeat;
    };

    typedef struct v_leaseAdmin_s {
        v_leaseTime                              nextExpiryTime;
        SET<v_leaseAction>                       leases;
    } v_leaseAdmin;

    class v_leaseManager extends v_object {
        attribute c_mutex                        mutex;
        attribute c_cond                         cond;
        attribute c_bool                         quit;
        attribute v_leaseAdmin                   monotonic;
        attribute v_leaseAdmin                   elapsed;
    };

   /* -------------------------------------------------------------------------- */
    /* Policy implementations                                                     */
    /* -------------------------------------------------------------------------- */

    typedef c_long v_policyId;

    /* This value is used to specify unlimited resources and history depth */
    const c_long V_LENGTH_UNLIMITED             = -1;

    /* The value of a policy id is identical to
     * the value of the policy id at API level! */
    /* added so id's can be used as index in array's */
    const v_policyId V_UNKNOWN_POLICY_ID        = 0;

    const v_policyId V_USERDATAPOLICY_ID          = 1;
    const v_policyId V_DURABILITYPOLICY_ID        = 2;
    const v_policyId V_PRESENTATIONPOLICY_ID      = 3;
    const v_policyId V_DEADLINEPOLICY_ID          = 4;
    const v_policyId V_LATENCYPOLICY_ID           = 5;
    const v_policyId V_OWNERSHIPPOLICY_ID         = 6;
    const v_policyId V_STRENGTHPOLICY_ID          = 7;
    const v_policyId V_LIVELINESSPOLICY_ID        = 8;
    const v_policyId V_PACINGPOLICY_ID            = 9;
    const v_policyId V_PARTITIONPOLICY_ID         = 10;
    const v_policyId V_RELIABILITYPOLICY_ID       = 11;
    const v_policyId V_ORDERBYPOLICY_ID           = 12;
    const v_policyId V_HISTORYPOLICY_ID           = 13;
    const v_policyId V_RESOURCEPOLICY_ID          = 14;
    const v_policyId V_ENTITYFACTORYPOLICY_ID     = 15;
    const v_policyId V_WRITERLIFECYCLEPOLICY_ID   = 16;
    const v_policyId V_READERLIFECYCLEPOLICY_ID   = 17;
    const v_policyId V_TOPICDATAPOLICY_ID         = 18;
    const v_policyId V_GROUPDATAPOLICY_ID         = 19;
    const v_policyId V_TRANSPORTPOLICY_ID         = 20;
    const v_policyId V_LIFESPANPOLICY_ID          = 21;
    const v_policyId V_DURABILITYSERVICEPOLICY_ID = 22;
    const v_policyId V_USERKEYPOLICY_ID           = 23;
    const v_policyId V_VIEWKEYPOLICY_ID           = 24;
    const v_policyId V_READERLIFESPANPOLICY_ID    = 25;
    const v_policyId V_SHAREPOLICY_ID             = 26;
    const v_policyId V_SCHEDULINGPOLICY_ID        = 27;

    const v_policyId V_POLICY_ID_COUNT            = 28;

    const c_string V_USERDATAPOLICY_NAME          = "UserData";
    const c_string V_DURABILITYPOLICY_NAME        = "Durability";
    const c_string V_PRESENTATIONPOLICY_NAME      = "Presentation";
    const c_string V_DEADLINEPOLICY_NAME          = "Deadline";
    const c_string V_LATENCYPOLICY_NAME           = "LatencyBudget";
    const c_string V_OWNERSHIPPOLICY_NAME         = "Ownership";
    const c_string V_STRENGTHPOLICY_NAME          = "OwnershipStrength";
    const c_string V_LIVELINESSPOLICY_NAME        = "Liveliness";
    const c_string V_PACINGPOLICY_NAME            = "TimeBasedFilter";
    const c_string V_PARTITIONPOLICY_NAME         = "Partition";
    const c_string V_RELIABILITYPOLICY_NAME       = "Reliability";
    const c_string V_ORDERBYPOLICY_NAME           = "DestinationOrder";
    const c_string V_HISTORYPOLICY_NAME           = "History";
    const c_string V_RESOURCEPOLICY_NAME          = "ResourceLimits";
    const c_string V_ENTITYFACTORYPOLICY_NAME     = "EntityFactory";
    const c_string V_WRITERLIFECYCLEPOLICY_NAME   = "WriterDataLifecycle";
    const c_string V_READERLIFECYCLEPOLICY_NAME   = "ReaderDataLifecycle";
    const c_string V_TOPICDATAPOLICY_NAME         = "TopicData";
    const c_string V_GROUPDATAPOLICY_NAME         = "GroupData";
    const c_string V_TRANSPORTPOLICY_NAME         = "TransportPriority";
    const c_string V_LIFESPANPOLICY_NAME          = "Lifespan";
    const c_string V_DURABILITYSERVICEPOLICY_NAME = "DurabilityService";
    const c_string V_USERKEYPOLICY_NAME           = "SubscriptionKey";
    const c_string V_READERLIFESPANPOLICY_NAME    = "ReaderLifespan";
    const c_string V_SHAREPOLICY_NAME             = "Share";
    const c_string V_SCHEDULINGPOLICY_NAME        = "Scheduling";

    /* -------------------------------------------------------------------------- */
    /*  Status implementation                                                  */
    /* -------------------------------------------------------------------------- */


    struct v_QosPolicyCount {
        v_policyId                               policyId;
        c_long                                   count;
    };

    enum v_sampleRejectedKind {
        S_NOT_REJECTED,
        S_REJECTED_BY_INSTANCES_LIMIT,
        S_REJECTED_BY_SAMPLES_LIMIT,
        S_REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT
    };

    struct v_inconsistentTopicInfo {
        c_long                         totalCount;
        c_long                         totalChanged;
    };

    struct v_allDataDisposedInfo {
        c_long                         totalCount;
        c_long                         totalChanged;
    };

    struct v_sampleLostInfo {
        c_long                         totalCount;
        c_long                         totalChanged;
    };

    struct v_livelinessLostInfo {
        c_long                         totalCount;
        c_long                         totalChanged;
    };

    struct v_deadlineMissedInfo {
        c_long                         totalCount;
        c_long                         totalChanged;
        v_handle                       instanceHandle;
    };

    struct v_sampleRejectedInfo {
        c_long                         totalCount;
        c_long                         totalChanged;
        v_sampleRejectedKind           lastReason;
        kernelModule::v_gid                          instanceHandle;
    };

    struct v_incompatibleQosInfo {
        c_long                         totalCount;
        c_long                         totalChanged;
        v_policyId                     lastPolicyId;
        c_long                         policyCount[V_POLICY_ID_COUNT];
    };

    struct v_livelinessChangedInfo {
        c_long                         activeCount;
        c_long                         activeChanged;
        c_long                         inactiveCount;
        c_long                         inactiveChanged;
        kernelModule::v_gid                          instanceHandle;
    };

    struct v_topicMatchInfo {
        c_long                         totalCount;
        c_long                         totalChanged;
        c_long                         currentCount;
        c_long                         currentChanged;
        kernelModule::v_gid                          instanceHandle;
    };

    struct v_servicesChangedInfo {
        c_long                         totalCount;
        c_long                         totalChanged;
    };

    struct v_groupsChangedInfo {
        c_long                         totalCount;
        c_long                         totalChanged;
    };

    class v_kernelStatus extends v_status {
        attribute v_servicesChangedInfo          servicesInfo;
    };

    class v_partitionStatus extends v_status {
        attribute v_groupsChangedInfo            groupsChanged;
    };

    class v_topicStatus extends v_status {
        attribute v_inconsistentTopicInfo        inconsistentTopic;
        attribute v_allDataDisposedInfo          allDataDisposed;
    };

    class v_subscriberStatus extends v_status {
        attribute c_long       dummy;
    };

    class v_writerStatus extends v_status {
        attribute v_livelinessLostInfo           livelinessLost;
        attribute v_deadlineMissedInfo           deadlineMissed;
        attribute v_incompatibleQosInfo          incompatibleQos;
        attribute v_topicMatchInfo               publicationMatch;
    };

    class v_readerStatus extends v_status {
        attribute v_livelinessChangedInfo        livelinessChanged;
        attribute v_sampleRejectedInfo           sampleRejected;
        attribute v_sampleLostInfo               sampleLost;
        attribute v_deadlineMissedInfo           deadlineMissed;
        attribute v_incompatibleQosInfo          incompatibleQos;
        attribute v_topicMatchInfo               subscriptionMatch;
    };



    /**
     * IMPORTANT: all enumeration values must be ordered according
     * compatibility, since they are used to check compatibility between
     * readers and writers.
     *
     * Note: these *MUST* be kept in sync with the exposed ones in
     * v_kernelModule, or translators must be added.  (Currently, they are
     * identical, and this enforced at compile time.)
     *
     * They are duplicated
     */

    enum v_scheduleKind {
        V_SCHED_DEFAULT,
        V_SCHED_TIMESHARING,
        V_SCHED_REALTIME
    };

    enum v_schedulePriorityKind {
        V_SCHED_PRIO_RELATIVE,
        V_SCHED_PRIO_ABSOLUTE
    };

    typedef struct v_partitionPolicyI_s {
        c_string v;
    } v_partitionPolicyI;

    typedef struct v_topicDataPolicyI_s {
        struct v_topicDataPolicyI_contents_s {
            ARRAY<c_octet>            value;
            c_long                    size;
        } v;
    } v_topicDataPolicyI;

    typedef struct v_groupDataPolicyI_s {
        struct v_groupDataPolicyI_contents_s {
            ARRAY<c_octet>                   value;
            c_long                           size;
        } v;
    } v_groupDataPolicyI;

    typedef struct v_lifespanPolicyI_s {
         struct v_lifespanPolicyI_contents_s {
            os_duration duration;
         } v;
    } v_lifespanPolicyI;

    typedef struct v_deadlinePolicyI_s {
         struct v_deadlinePolicyI_contents_s {
            os_duration period;
         } v;
    } v_deadlinePolicyI;

    typedef struct v_latencyPolicyI_s {
         struct v_latencyPolicyI_contents_s {
            os_duration duration;
         } v;
    } v_latencyPolicyI;

    typedef struct v_pacingPolicyI_s {
         struct v_pacingPolicyI_contents_s {
            os_duration minSeperation;
         } v;
    } v_pacingPolicyI;

    typedef struct v_livelinessPolicyI_s {
         struct v_livelinessPolicyI_contents_s {
            kernelModule::v_livelinessKind kind;
            os_duration lease_duration;
         } v;
    } v_livelinessPolicyI;

    typedef struct v_readerLifespanPolicyI_s {
         struct v_readerLifespanPolicyI_contents_s {
            c_bool used;
            os_duration duration;
         } v;
    } v_readerLifespanPolicyI;

    typedef struct v_readerLifecyclePolicyI_s {
        struct v_readerLifecyclePolicyI_contents_s {
            os_duration autopurge_nowriter_samples_delay;
            os_duration autopurge_disposed_samples_delay;
            c_bool autopurge_dispose_all;
            c_bool enable_invalid_samples;
            kernelModule::v_invalidSampleVisibilityKind invalid_sample_visibility;
        } v;
    } v_readerLifecyclePolicyI;

    typedef struct v_writerLifecyclePolicyI_s {
        struct v_writerLifecyclePolicyI_contents_s {
            c_bool autodispose_unregistered_instances;
            os_duration autopurge_suspended_samples_delay;
            os_duration autounregister_instance_delay;
        } v;
    } v_writerLifecyclePolicyI;

    typedef struct v_reliabilityPolicyI_s {
        struct v_reliabilityPolicyI_contents_s {
            kernelModule::v_reliabilityKind kind;
            os_duration max_blocking_time;
            c_bool synchronous;
        } v;
    } v_reliabilityPolicyI;

    typedef struct v_durabilityServicePolicyI_s {
        struct v_durabilityPolicyI_contents_s {
            os_duration service_cleanup_delay;
            kernelModule::v_historyQosKind history_kind;
            c_long history_depth;
            c_long max_samples;
            c_long max_instances;
            c_long max_samples_per_instance;
        } v;
    } v_durabilityServicePolicyI;

    typedef struct v_productDataPolicyI_s { kernelModule::v_productDataPolicy v; } v_productDataPolicyI;
    typedef struct v_sharePolicyI_s { kernelModule::v_sharePolicy v; } v_sharePolicyI;
    typedef struct v_userDataPolicyI_s { kernelModule::v_userDataPolicy v; } v_userDataPolicyI;
    typedef struct v_transportPolicyI_s { kernelModule::v_transportPolicy v; } v_transportPolicyI;
    typedef struct v_durabilityPolicyI_s { kernelModule::v_durabilityPolicy v; } v_durabilityPolicyI;
    typedef struct v_presentationPolicyI_s { kernelModule::v_presentationPolicy v; } v_presentationPolicyI;
    typedef struct v_ownershipPolicyI_s { kernelModule::v_ownershipPolicy v; } v_ownershipPolicyI;
    typedef struct v_strengthPolicyI_s { kernelModule::v_strengthPolicy v; } v_strengthPolicyI;
    typedef struct v_historyPolicyI_s { kernelModule::v_historyPolicy v; } v_historyPolicyI;
    typedef struct v_orderbyPolicyI_s { kernelModule::v_orderbyPolicy v; } v_orderbyPolicyI;
    typedef struct v_resourcePolicyI_s { kernelModule::v_resourcePolicy v; } v_resourcePolicyI;
    typedef struct v_entityFactoryPolicyI_s { kernelModule::v_entityFactoryPolicy v; } v_entityFactoryPolicyI;
    typedef struct v_userKeyPolicyI_s { kernelModule::v_userKeyPolicy v; } v_userKeyPolicyI;

    typedef struct v_simulationPolicyI_s {
        struct v_simulationPolicyI_contents_s {
            os_duration                       oldTime;
            os_duration                       newTime;
            c_double                          relativeSpeed;
        } v;
    } v_simulationPolicyI;

    typedef struct v_schedulePolicyI_s {
        struct v_schedulePolicyI_contents_s {
            v_scheduleKind                    kind;
            v_schedulePriorityKind            priorityKind;
            c_long                            priority;
        } v;
    } v_schedulePolicyI;

    typedef struct v_builtinTopicPolicyI_s {
        struct v_builtinTopicPolicyI_contents_s {
            c_bool enabled;
        } v;
    } v_builtinTopicPolicyI;

    enum v_qosKind {
        V_PARTITION_QOS,
        V_PARTICIPANT_QOS,
        V_TOPIC_QOS,
        V_WRITER_QOS,
        V_READER_QOS,
        V_PUBLISHER_QOS,
        V_SUBSCRIBER_QOS,
        V_INDEX_QOS,
        V_WRITERHISTORY_QOS,
        V_GROUPHISTORY_QOS,
        V_VIEW_QOS,
        V_DATAVIEW_QOS,
        V_KERNEL_QOS,
        V_COUNT_QOS /* This constant must always be the last */
    };

    class v_qos {
        attribute v_qosKind                 kind;
    };

    struct v_systemIdConfig {
        c_ulong min;
        c_ulong max;
        c_ulong entropySize;
        c_voidp entropy;
    };

    class v_kernelQos extends v_qos {
        attribute v_builtinTopicPolicyI      builtin;
        attribute v_systemIdConfig           systemIdConfig;
    };

    class v_partitionQos extends v_qos {
        attribute v_simulationPolicyI        simulation;
        attribute v_userDataPolicyI          userData;
        attribute v_entityFactoryPolicyI     entityFactory;
    };

    class v_participantQos extends v_qos {
        attribute v_entityFactoryPolicyI     entityFactory;
        attribute v_userDataPolicyI          userData;
        attribute v_schedulePolicyI          watchdogScheduling;
    };

    class v_topicQos extends v_qos {
        attribute v_topicDataPolicyI         topicData;
        attribute v_durabilityPolicyI        durability;
        attribute v_durabilityServicePolicyI durabilityService;
        attribute v_deadlinePolicyI          deadline;
        attribute v_latencyPolicyI           latency;
        attribute v_livelinessPolicyI        liveliness;
        attribute v_reliabilityPolicyI       reliability;
        attribute v_orderbyPolicyI           orderby;
        attribute v_historyPolicyI           history;
        attribute v_resourcePolicyI          resource;
        attribute v_transportPolicyI         transport;
        attribute v_lifespanPolicyI          lifespan;
        attribute v_ownershipPolicyI         ownership;
    };

    class v_writerQos extends v_qos {
        attribute v_durabilityPolicyI        durability;
        attribute v_deadlinePolicyI          deadline;
        attribute v_latencyPolicyI           latency;
        attribute v_livelinessPolicyI        liveliness;
        attribute v_reliabilityPolicyI       reliability;
        attribute v_orderbyPolicyI           orderby;
        attribute v_historyPolicyI           history;
        attribute v_resourcePolicyI          resource;
        attribute v_transportPolicyI         transport;
        attribute v_lifespanPolicyI          lifespan;
        attribute v_userDataPolicyI          userData;
        attribute v_ownershipPolicyI         ownership;
        attribute v_strengthPolicyI          strength;
        attribute v_writerLifecyclePolicyI   lifecycle;
    };

    class v_readerQos extends v_qos {
        attribute v_durabilityPolicyI        durability;
        attribute v_deadlinePolicyI          deadline;
        attribute v_latencyPolicyI           latency;
        attribute v_livelinessPolicyI        liveliness;
        attribute v_reliabilityPolicyI       reliability;
        attribute v_orderbyPolicyI           orderby;
        attribute v_historyPolicyI           history;
        attribute v_resourcePolicyI          resource;
        attribute v_userDataPolicyI          userData;
        attribute v_ownershipPolicyI         ownership;
        attribute v_pacingPolicyI            pacing;
        attribute v_readerLifecyclePolicyI   lifecycle;
        attribute v_readerLifespanPolicyI    lifespan;
        attribute v_sharePolicyI             share;
        attribute v_userKeyPolicyI           userKey;
    };

    class v_publisherQos extends v_qos {
        attribute v_presentationPolicyI      presentation;
        attribute v_partitionPolicyI         partition;
        attribute v_groupDataPolicyI         groupData;
        attribute v_entityFactoryPolicyI     entityFactory;
    };

    class v_subscriberQos extends v_qos {
        attribute v_presentationPolicyI      presentation;
        attribute v_partitionPolicyI         partition;
        attribute v_groupDataPolicyI         groupData;
        attribute v_entityFactoryPolicyI     entityFactory;
        attribute v_sharePolicyI             share;
    };

    class v_dataViewQos extends v_qos {
        attribute v_userKeyPolicyI           userKey;
    };

    class v_rxoData extends v_object {
        attribute v_durabilityPolicyI        durability;
        attribute v_deadlinePolicyI          deadline;
        attribute v_latencyPolicyI           latency;
        attribute v_livelinessPolicyI        liveliness;
        attribute v_reliabilityPolicyI       reliability;
        attribute v_orderbyPolicyI           orderby;
        attribute v_ownershipPolicyI         ownership;
    };

    /* -------------------------------------------------------------------------- */
    /*  Meta data implementation                                                  */
    /* -------------------------------------------------------------------------- */

    class v_mapping {
        attribute c_field                        source;
        attribute c_field                        destination;
    };

    class v_projection {
        attribute c_type                         resultType;
        attribute ARRAY<v_mapping>               rules;
    };

    enum v_accessMode { V_ACCESS_MODE_UNDEFINED,
                        V_ACCESS_MODE_READ,
                        V_ACCESS_MODE_WRITE,
                        V_ACCESS_MODE_READ_WRITE,
                        V_ACCESS_MODE_NONE,
                        V_ACCESS_MODE_COUNT };


    class v_topic extends v_entity {
        attribute c_voidp                        owner;
    };

    class v_topicImpl extends v_topic {
        attribute c_type                         messageType;
        attribute c_type                         dataType;
        attribute v_topicQos                     qos;
        attribute c_string                       keyExpr;
        attribute ARRAY<c_field>                 messageKeyList;
        attribute v_accessMode                   accessMode;
        /* keyType is a reference to a generated type 'topicName<Key>'.
           It is a structure that contains fields 'field1'.. 'fieldN'.
           The fields correspond to the fields specified by the keyList.
           Note that this reference is only for convenience so default
           DataWriters and DataReaders do not have to create the type themselves.
        */
        attribute c_type                         keyType;
        attribute c_ulong                        crcOfName;
        attribute c_ulong                        crcOfTypeName;
    };

    class v_topicAdapter extends v_topic {
        attribute v_topicImpl                    topic;
    };

    class v_filter {
        attribute v_topic                        topic;
        attribute c_object                       predicate;
    };

    class v_typeRepresentation {
        attribute c_string typeName;
        attribute kernelModule::v_dataRepresentationId_t dataRepresentationId;
        attribute kernelModule::v_typeHash typeHash;
        attribute sequence<c_octet> metaData;
        attribute sequence<c_octet> extentions;
    };

    /* -------------------------------------------------------------------------- */
    /* Partition implementation                                                   */
    /* -------------------------------------------------------------------------- */

    class v_partition extends v_entity {
        attribute c_ushort                      addCount;
        attribute v_qos                         qos;
    };

    /* -------------------------------------------------------------------------- */
    /* Instance List Item implementation                                          */
    /* -------------------------------------------------------------------------- */

    class v_instance extends v_public {
        attribute v_state                        state;
        attribute c_voidp                        entity; /* Owner of the instance. */
    };

    class v_deadLineInstance extends v_instance {
        attribute os_timeE                       lastDeadlineResetTime;
        attribute c_voidp                        next;
        attribute c_voidp                        prev;
    };

    class v_deadLineInstanceList extends v_object {
        attribute v_lease                        deadlineLease;
        attribute v_leaseManager                 leaseManager;
        attribute os_duration                    leaseDuration;
        attribute c_voidp                        actionObject; /* reader or writer */
        attribute v_leaseActionId                actionId;
        attribute v_deadLineInstance             head;
        attribute v_deadLineInstance             tail;
    };

    class v_partitionInterest {
        /* attribute c_long                         index; */
        /* attribute c_bool                         interested; */
        attribute c_string                       expression;
    };

    class v_partitionAdmin extends v_object { /* only used by v_publisher and v_subscriber */
        attribute c_mutex                        mutex;
        attribute SET<v_partition>               partitions;
        attribute SET<v_partitionInterest>       partitionInterests;
    };

    /* -------------------------------------------------------------------------- */
    /* Message implementation                                                     */
    /* -------------------------------------------------------------------------- */

    class v_node {
        attribute v_state                        nodeState;
    };

    class v_message extends v_node {
        attribute os_timeE                       allocTime;
        attribute os_timeW                       writeTime;
        attribute kernelModule::v_gid            writerGID;
        attribute kernelModule::v_gid            writerInstanceGID;
        attribute c_ulong                        sequenceNumber;
        attribute c_ulong                        transactionId;
        attribute kernelModule::v_messageQos     qos;
    };

    /* The end-of-transaction message identifies the end of a transaction and
     * in case of group coherence contains a list of all other participating
     * writer transactions.
     */
    class v_messageEOT extends v_message {
        attribute c_ulong         publisherId;
        attribute c_ulong         transactionId;
        attribute sequence<kernelModule::v_tid> tidList;
    };

    /* -------------------------------------------------------------------------- */
    /* Lifespan implementation                                                    */
    /* -------------------------------------------------------------------------- */

    class v_lifespanSample {
        attribute os_timeE         expiryTime;
        attribute v_lifespanSample next;
        attribute c_voidp          prev;
    };

    class v_lifespanAdmin {
        attribute c_long           sampleCount;
        attribute v_lifespanSample head;
        attribute v_lifespanSample tail;
    };

    /* -------------------------------------------------------------------------- */
    /* Instance pipeline cache implementation                                     */
    /* -------------------------------------------------------------------------- */

    enum v_cacheKind { V_CACHE_CONNECTION,
                       V_CACHE_TARGETS,
                       V_CACHE_ANY };

    struct v_cacheLink {
        c_voidp                                  next;
        c_voidp                                  prev;
    };

    class v_cacheNode {
        attribute v_cacheLink                    connections;
        attribute v_cacheLink                    targets;
    };

    class v_cache extends v_cacheNode {
        attribute v_cacheKind                    kind;
        attribute c_type                         itemType;
    };

    class v_cacheItem extends v_cacheNode {
        attribute c_voidp                        instance;
    };

    typedef v_cacheItem v_writerCacheItem;

    class v_groupCacheItem extends v_cacheItem {
        attribute c_voidp                        groupInstance;
        attribute c_long                         registrationCount;
        attribute c_long                         pendingResends;
    };

    /* -------------------------------------------------------------------------- */
    /* Reader implementation                                                      */
    /* -------------------------------------------------------------------------- */

    class v_dataViewSampleList;

    class v_readerSample extends v_lifespanSample {
        attribute os_timeW                       readTime;
        attribute v_state                        sampleState;
        attribute c_voidp                        instance;
        attribute c_voidp                        viewSamples;
    };

    class v_dataViewSampleList extends v_readerSample {
        attribute c_voidp                        next;
        attribute c_voidp                        prev;
    };

    class v_dataViewSample extends v_dataViewSampleList {
        attribute v_dataViewSample               prev;
    /* The next pointer is special, because the first sample (the sample
     * pointed to by v_dataViewInstanceTemplate) points to the last sample
     * to speedup adding new samples to the list. */
        attribute c_voidp                        next;
    };

class v_orderedInstanceSample extends v_dataViewSample {
    attribute v_readerSample                 sample;
};

    class v_dataViewSampleTemplate extends v_dataViewSample {
        attribute v_readerSample                 sample;
    };

    class v_dataViewInstance extends v_instance {
        attribute c_long                         sampleCount;
    };

    class v_dataViewInstanceTemplate extends v_dataViewInstance {
    /* The sample member serves two purposes.
     * 1) If the instance contains samples, it points to the oldest sample in
     *    the list. Updates are placed at the end of the list.
     * 2) If no samples are held by the instance it serves as a keep alive
     *    sample to ensure the amount of work to be done in intensive
     *    write-take loops is kept to a minimum. The Instance is kept alive
     *    as an empty Instance because in many use-cases the next update is
     *    expected to arrive soon and since the sample holds the key-value
     *    of the Instance it must also remain part of the Instance until the
     *    next update can replace it.
     *
     * NOTE: The sample pointer therefore should always be a valid pointer.
     */
        attribute v_dataViewSample               sample;
    };

    class v_dataReaderSample extends v_readerSample {
        attribute v_dataReaderSample             older;
        attribute c_voidp                        newer;
        attribute os_timeW                       insertTime;
        attribute c_long                         disposeCount;
        attribute c_long                         noWritersCount;
        attribute kernelModule::v_gid                          publicationHandle;
        /* This ID is the readCnt value of the reader.
         * when this sample is processed by any read or take method and
         * this value is equal to the actual value of the reader then
         * this sample is already processed and can be skipped.
         */
        attribute c_ulong                        readId;
    };

    class v_dataReaderSampleTemplate extends v_dataReaderSample {
        attribute v_message                      message;
    };

    struct v_owner {
        kernelModule::v_gid  gid;
        c_long strength;
        c_bool exclusive;
    };

    struct v_historyBookmark {
        os_timeW sourceTimestamp;
        kernelModule::v_gid gid;
        c_ulong sequenceNumber;
        c_bool isImplicit;
    };

    class v_dataReaderInstance extends v_deadLineInstance {
        attribute c_voidp                        index;
        attribute c_long                         disposeCount;
        attribute c_long                         noWritersCount;
        /* 'sampleCount' represents the total number of valid samples stored
         * in this v_dataReaderInstance. Some of these samples may be available
         * for the next read/take, some others belong to an unfinished transaction
         * and are therefore not available to the next read/take. The total number
         * of available valid samples is captured in 'accessibleCount'.
         */
        attribute c_long                         resourceSampleCount;
        attribute c_long                         historySampleCount;
        attribute os_timeM                       purgeInsertionTime;
        attribute os_timeW                       epoch;
        attribute v_historyBookmark              lastConsumed;
        attribute c_long                         liveliness;
        attribute v_owner                        owner;
        attribute c_bool                         hasBeenAlive;
        attribute c_bool                         inNotEmptyList;
        attribute os_timeE                       lastInsertionTime;
        attribute v_dataReaderSampleTemplate     pending;
        attribute c_voidp                        userData;
    };

    class v_orderedInstance extends v_dataViewInstanceTemplate {
        attribute c_voidp                        samples;
        attribute c_voidp                        bookmark;
        attribute kernelModule::v_presentationKind presentation;
        attribute kernelModule::v_orderbyKind    orderby;
        attribute v_state                        mask;
        attribute LIST<v_dataReaderInstance>     lazynew;
    };

    class v_dataReaderInstanceTemplate extends v_dataReaderInstance {
        attribute v_dataReaderSampleTemplate     sample;
        attribute c_voidp                        oldest;
    };

    class v_entry extends v_object {
        attribute c_voidp                        reader;
        attribute SET<v_proxy>                   groups;
        attribute c_bool                         complete; /* completeness of all groups */
        attribute c_long                         nvgCount; /* number of attached non volatile groups */
    };

    struct v_entrySet {
        c_mutex                                  mutex;
        SET<v_entry>                             entries;
    };

    class v_historicalDeleteRequest extends v_object {
        attribute os_timeE deleteTime;
        attribute c_string partitionExpr;
        attribute c_string topicExpr;
    };

    class v_historicalDataRequest extends v_object {
        attribute c_string                       filter;
        attribute ARRAY<c_string>                filterParams;
        attribute v_resourcePolicyI              resourceLimits;
        attribute os_timeW                       minSourceTimestamp;
        attribute os_timeW                       maxSourceTimestamp;
        attribute os_duration                    timeout;
    };

    class v_persistentSnapshotRequest extends v_object {
        attribute c_string                       topicExpr;
        attribute c_string                       partitionExpr;
        attribute c_string                       uri;
    };

    class v_reader extends v_collection {
        attribute v_entrySet                     entrySet;
        attribute c_voidp                        subscriber;
        attribute v_subscriberQos                subQos; /* ref is ro */
        attribute v_readerQos                    qos;
        /* Attributes to support historical data requests with conditions */
        attribute v_historicalDataRequest        historicalDataRequest;
        attribute c_cond                         historicalDataCondition;
        attribute c_bool                         historicalDataComplete;
    };


    /* -------------------------------------------------------------------------- */
    /* Group implementation                                                       */
    /* -------------------------------------------------------------------------- */

    class v_groupStream;
    class v_transaction;

    class v_groupSample extends v_lifespanSample {
        attribute v_groupSample                  older;
        attribute c_voidp                        newer;
        attribute c_voidp                        instance;
        attribute v_transaction                  transaction; /* Reference to the transaction it was part of */
    };

    class v_groupSampleTemplate extends v_groupSample {
        attribute v_message                      message;
    };

    class v_registration {
        attribute kernelModule::v_gid            writerGID;
        attribute kernelModule::v_messageQos     qos;
        attribute os_timeW                       writeTime;
        attribute c_ulong                        sequenceNumber; /* sequenceNumber of the original message */
        attribute os_timeE                       unregisterTime; /* Elapsed (monotonic) time */
        attribute v_state                        state; /* message state of the original message */
        attribute v_transaction                  transaction; /* Reference to the transaction it was part of */
        attribute v_registration                 next;
    };

    class v_groupInstance extends v_object {
        attribute c_ulong                        state;
        attribute c_long                         historySampleCount;    /* only write messages in History. */
        attribute c_long                         count;                 /* write AND disposed messages in history. */
        attribute c_long                         resourceSampleCount;   /* Total write messages (incl. transactions). */
        attribute c_voidp                        group;
        attribute c_voidp                        oldest;
        attribute v_cache                        targetCache;
        attribute v_registration                 registrations;
        attribute v_registration                 unregistrations;
        attribute os_timeE                       epoch;
        attribute v_owner                        owner;
    };

    /* v_transactionElement implements an array element that holds messages part of an
     * incomplete transaction together with a reference to their destination instance
     * when complete.
     */
    class v_transactionElement {
        attribute v_message                      message;
        attribute v_instance                     instance;
    };

    class v_transaction extends v_object {
        attribute c_ulong                        transactionId; /* key */
        attribute v_messageEOT                   eot; /* provides #expected */
        attribute c_voidp                        writer; /* owner backref */
        attribute c_voidp                        admin; /* owner backref */
        attribute c_long                         count; /* equals nr of unique messages received */
        attribute c_long                         eotCount; /* equals nr of EOTs received */
        attribute c_long                         size; /* equals nr of messages in transaction */
        attribute c_bool                         elementZero; /* true when first element of transaction is received */
        attribute c_bool                         aborted; /* true when transaction is prematuraly aborted. */
        attribute c_bool                         sampleLostNotified; /* true when sampleLostNotification is sent. */
        attribute ARRAY<v_transactionElement>    elements; /* received messages */
        attribute c_bool                         isMarked; /* true is the L_MARK flag was set on a message */
        attribute c_voidp                        transactionGroup; /* transactionGroup backref */
    };

    class v_transactionWriter extends v_object {
        attribute kernelModule::v_gid            writerGID; /* key */
        attribute c_ulong                        publisherId; /* applicable for group scope and filled on reception first EOT */
        attribute c_voidp                        admin; /* owner backref */
        attribute LIST<v_transaction>            transactions; /* reception time ordered list */
        attribute c_ulong                        matchCount; /* Nr of matching partitions */
    };

    class v_transactionGroupReader extends v_object {
        attribute kernelModule::v_gid            gid; /* key */
        attribute v_topic                        topic;
        attribute v_rxoData                      rxo;
    };

    class v_transactionGroupWriter extends v_object {
        attribute kernelModule::v_gid            gid; /* key */
        attribute c_voidp                        publisher; /* owner backref */
        attribute c_bool                         discovered;
        attribute v_topic                        topic;
        attribute v_rxoData                      rxo;
        attribute SET<v_transactionGroupReader>  readers; /* set of readers with matching qos */
    };

    class v_transactionGroup extends v_object {
        attribute c_ulong                        transactionId; /* key */
        attribute c_voidp                        publisher; /* owner backref */
        attribute c_ulong                        publisherId;
        attribute c_bool                         aborted; /* true when transaction is prematuraly aborted. */
        attribute LIST<v_transaction>            transactions; /* complete writer transactions */
        attribute SET<v_transactionWriter>       writers; /* discovered matching writers for incomplete transactions */
        attribute c_ulong                        matchCount; /*  */
        attribute c_bool                         triggered; /* true when data_available trigger is sent for group */
    };

    class v_transactionPublisher extends v_object {
        attribute c_ulong                        systemId; /* key */
        attribute c_ulong                        publisherId; /* key */
        attribute c_voidp                        admin;    /* Backref to v_transactionGroupAdmin */
        attribute SET<v_transactionGroupWriter>  writers; /* discovered writers with matchCounts */
        attribute LIST<v_transactionGroup>       transactions; /* reception time ordered incomplete coherent groups */
        attribute c_ulong                        lastRemovedTransactionId;
    };

    class v_transactionAdmin extends v_object {
        attribute c_voidp                        owner; /* owner backref (v_group or v_dataReader). */
        attribute c_voidp                        groupAdmin; /* group coherence backref  */
        attribute SET<v_transactionWriter>       writers; /* discovered matching writers */
        attribute v_topic                        topic;
        attribute LIST<v_transaction>            history; /* list of complete and flushed transactions (without any elements) */
    };

    class v_transactionGroupAdmin extends v_object {
        attribute c_voidp                        owner; /* owner backref (v_kernel or v_subscriber). */
        attribute c_mutex                        mutex;
        attribute LIST<v_transactionGroup>       pending; /* list of complete group transactions that are waiting to be flushed as soon as the history is un-locked */
        attribute SET<v_transactionPublisher>    publishers; /* discovered publishers */
        attribute SET<v_transactionGroupReader>  readers; /* */
        attribute LIST<v_transactionGroup>       history; /* list of complete and flushed group transactions (without any elements) */
    };

    class v_groupInstanceTemplate extends v_groupInstance {
        attribute v_groupSampleTemplate          newest;
    };

    class v_groupEntry {
        attribute v_entry                        entry;
        attribute c_long                         sequenceNumber;
        attribute v_cache                        connectionCache;
        attribute v_groupEntry                   next;
    };

    struct v_groupEntrySet {
        v_groupEntry                             firstEntry;
        c_long                                   lastSequenceNumber;
    };

    class v_groupPurgeItem {
        attribute v_groupInstance                instance;
        attribute os_timeE                       insertionTime; /* Elapsed-clock */
        attribute v_groupPurgeItem               next;
    };

    enum v_groupAttachState {
        V_GROUP_ATTACH_STATE_UNKNOWN,
        V_GROUP_ATTACH_STATE_ATTACHED,
        V_GROUP_ATTACH_STATE_NO_INTEREST
    };

    class v_groupwriterAdministration {
        attribute kernelModule::v_gid                          gid;
        attribute c_ulong                        seqNumber;
    };

    /** Class v_group:
        The attributes topic and partition specifies the data space of
        the group. The attribute writers is a set of all the writers
        currently writing to this group. The attribute disposedInstances
        is a deathrow for disposed instances which will be deleted after
        a qos defined delay.
    */
    class v_group extends v_observer {

        /* Group meta description */
        attribute c_string                       name;
        attribute v_topic                        topic;
        attribute v_partition                    partition;
        attribute v_accessMode                   partitionAccessMode;
        /* Group associated Reader Entries */
        attribute v_groupEntrySet                topicEntrySet;   /* Normal dataReader entries. */
        attribute v_groupEntrySet                networkEntrySet; /* Network interface entries. */
        attribute v_groupEntrySet                routedEntrySet;  /* Routed (network) services entries, subset of networkEntrySet. */
        attribute v_groupEntrySet                variantEntrySet; /* Variant keyed dataReader entries. */
        attribute SET<v_groupStream>             streams;         /* Streams interested in all actions */

        /* Group process control. */
        attribute c_mutex                        mutex;

        /* Group state */
        attribute c_long                         sequenceNumber;
        attribute c_long                         resourceSampleCount;
        attribute os_timeW                       lastDisposeAllTime;
        attribute c_bool                         infWait;
        attribute c_bool                         complete;
        attribute c_bool                         routingEnabled;

        /* Service attachment states*/
        attribute SET<c_string>                  attachedServices;
        attribute SET<c_string>                  notInterestedServices;

        /* group data storage */
        attribute SET<v_groupInstance>           instances;
        attribute v_groupPurgeItem               disposedInstances;
        attribute c_voidp                        disposedInstancesLast;
        attribute v_groupPurgeItem               purgeListEmpty;
        attribute c_voidp                        purgeListEmptyLast;

        attribute v_lifespanAdmin                lifespanAdmin;

        /* Group resource optimisation */
        attribute v_message                          cachedRegMsg;
        attribute v_groupInstance                    cachedInstance;
        attribute c_type                             instanceType;
        attribute c_type                             sampleType;
        attribute SET<v_groupwriterAdministration>   writerAdministration; /* c_table writerAdministration<v_groupwriterAdministration> */
        attribute v_transactionAdmin                 transactionAdmin;
        attribute c_bool                             onRequest;
        attribute c_bool                             pristine; /* true if never connected to any writer */
    };

    /* -------------------------------------------------------------------------- */
    /* Writer implementation                                                      */
    /* -------------------------------------------------------------------------- */

    typedef c_octet v_resendScope;
    typedef c_octet v_resendItemKind;

    class v_writerResendItem {
        attribute v_writerResendItem newer; /* Doubly linked list used to          */
        attribute c_voidp            older; /* implement the resend administration */
        attribute v_resendScope      scope;
        attribute v_resendItemKind   kind;
    };

    class v_writerEotSample extends v_writerResendItem {
        attribute v_message                      message;
    };

    class v_writerSample extends v_writerResendItem {
        attribute c_voidp                        instance;
        attribute v_writerSample                 next; /* Doubly linked list used to   */
        attribute c_voidp                        prev; /* implement the writer-history */
    };

    class v_writerSampleTemplate extends v_writerSample {
        attribute v_message                      message;
    };

    class v_writerInstance extends v_deadLineInstance {
        /* The current number of messages in this instance */
        attribute c_long                         messageCount;
        /* The total number of messages ever inserted in this sample */
        attribute c_voidp                        last;    /* v_writerSample, not counted */
        attribute v_cache                        targetCache;
        attribute c_long                         deadlineCount;
    };

    class v_writerInstanceTemplate extends v_writerInstance {
        attribute v_writerSample                 sample;
    };

    class v_writerGroup {
        attribute v_group                        group;
        attribute v_cache                        targetCache;
        attribute v_writerGroup                  next;
    };

    struct v_writerGroupSet {
        v_writerGroup                            firstGroup;
    };

    class v_deliveryWaitList {
        attribute c_ulong        sequenceNumber;
        attribute c_mutex        mutex;
        attribute c_cond         cv;
        attribute ARRAY<kernelModule::v_gid>   readerGID;
        attribute c_voidp        guard;
        attribute c_ulong        waitCount;
    };

    class v_deliveryPublisher {
        attribute kernelModule::v_gid readerGID;
        attribute c_ulong count;
    };

    class v_deliveryGuard {
        attribute kernelModule::v_gid writerGID;
        attribute c_voidp owner;
        attribute c_type gidType;
        attribute c_mutex mutex;
        attribute SET<v_deliveryPublisher> publications;
        attribute SET<v_deliveryWaitList> waitlists;
    };

    struct v_writerInOrderAdmin {
        c_voidp            resendNewest;
        v_writerResendItem resendOldest;
    };

    union v_writerResendAdmin switch ( kernelModule::v_presentationKind ) {
        case kernelModule::V_PRESENTATION_INSTANCE : SET<v_writerInstance> instances;
        default : v_writerInOrderAdmin admin;
    };

    class v_writer extends v_entity {
        attribute v_topic                        topic;
        attribute v_writerGroupSet               groupSet;
        attribute c_property                     messageField;
        attribute c_long                         depth;
        attribute SET<v_writerInstance>          instances;
        attribute v_writerResendAdmin            resend; /* Discriminator of union is cached (safe because immutable) publisher presentation-access_scope-QoS. */
        attribute c_bool                         coherent_access; /* Cached (safe because immutable) publisher presentation-coherent_access-QoS. */
        attribute c_bool                         ordered_access; /* Cached (safe because immutable) publisher presentation-ordered_access-QoS. */
        attribute c_ulong                        count;
        attribute c_ulong                        eotCount; /* Number of EOT messages pending resend. */
        attribute v_writerStatistics             statistics;
        attribute c_ulong                        sequenceNumber;
        attribute c_ulong                        transactionId;
        attribute c_bool                         transactionStarted;
        attribute c_bool                         infWait;

        attribute v_deadLineInstanceList         deadlineList;
        attribute c_long                         deadlineCountLimit;
        attribute c_voidp                        publisher;
        attribute v_writerQos                    qos;
        attribute kernelModule::v_messageQos     msgQos;
        attribute kernelModule::v_messageQos     relQos;
        attribute c_type                         msgQosType;
        attribute c_bool                         alive;           /* alive wrt liveliness policy */
        attribute v_lease                        livelinessLease; /* readonly */

        attribute c_type                         instanceType;
        attribute c_type                         sampleType;

        attribute v_deliveryGuard                deliveryGuard;

#ifdef PROFILER
        /* PROFILER attributes */
        attribute c_voidp                        t1;
        attribute c_voidp                        t2;
        attribute c_voidp                        t3;
        attribute c_voidp                        t4;
        attribute c_voidp                        t5;
        attribute c_voidp                        t6;
#endif
    };

    /* -------------------------------------------------------------------------- */
    /* Pub/Sub factory implementation                                             */
    /* -------------------------------------------------------------------------- */

    class v_subscriber extends v_entity {
        attribute v_partitionAdmin               partitions;
        attribute SET<v_reader>                  readers;
        attribute c_mutex                        sharesMutex;
        attribute SET<v_reader>                  shares;
        attribute c_mutex                        mutex;
        attribute c_cond                         cond;

        attribute c_voidp                        participant;
        attribute v_subscriberQos                qos;
        attribute c_ulong                        shareCount;
        attribute v_transactionGroupAdmin        transactionGroupAdmin;
        attribute c_ulong                        accessCount; /* number of active Begin access */
        attribute c_bool                         accessBusy;  /* access is in progress */
        attribute c_address                      accessOwner; /* debug: threadIdInteger of the thread which set accessBusy */
        /* When ordered_access is true and access_scope is set to group, the
         * destination_order across all readers must be enforced. Creating a reader
         * that does not abide to the ordering policy will result in inconsistent
         * policy being returned to the caller. Since a subscriber does not deal
         * with ordering policies directly, the ordering policy is set once the
         * first reader is added.
         */
        attribute v_orderedInstance              orderedInstance;
        attribute kernelModule::v_presentationPolicy presentation;
    };

    class v_publisher extends v_entity {
        attribute v_partitionAdmin               partitions;
        attribute SET<v_writer>                  writers;
        attribute c_lock                         lock;
        attribute c_voidp                        participant;
        attribute v_publisherQos                 qos;
        attribute os_timeE                       suspendTime; /* inf means not suspended */
        attribute c_ulong                        coherentNestingLevel;
        attribute c_ulong                        transactionId;
        attribute sequence<kernelModule::v_tid>  tidList;
        /* See comment in v_subscriber for details on why destination order
         * policies must be enforced when ordered_access is true and access_scope
         * is set to group.
         */
        attribute c_bool                         orderbyFixed;
        attribute kernelModule::v_orderbyKind    orderby;
    };

    const string V_BUILT_IN_PARTICIPANT_NAME = "Built-in participant";
    class v_participant extends v_entity {
        attribute SET<v_object>                  entities;
        attribute c_lock                         lock;
        attribute v_participantQos               qos;
        attribute v_leaseManager                 leaseManager;
        /* resend thread will wait on this condition. This thread is created in the
           user layer!
        */
        attribute c_bool                         resendQuit;
        attribute c_cond                         resendCond;
        attribute c_mutex                        resendMutex;
        attribute SET<v_proxy>                   resendWriters;
        attribute c_ulong                        resendIteration;
        attribute c_mutex                        builtinLock;
        attribute v_subscriber                   builtinSubscriber;
        attribute c_mutex                        newGroupListMutex;
        attribute LIST<v_group>                  newGroupList;
        attribute c_longlong                     processId;
        attribute c_string                       processName;
        attribute SET<v_typeRepresentation>      typeRepresentations;
        attribute c_bool                         processIsZombie;
    };

    /* -------------------------------------------------------------------------- */
    /* Service framework implementation                                           */
    /* -------------------------------------------------------------------------- */

    enum v_serviceStateKind {
        STATE_NONE,
        STATE_INITIALISING,
        STATE_OPERATIONAL,
        STATE_INCOMPATIBLE_CONFIGURATION,
        STATE_TERMINATING,
        STATE_TERMINATED,
        STATE_DIED
    };

    /* Service type codes, numerical values are used in CMParticipant */
    enum v_serviceType {
        V_SERVICETYPE_NONE,
        V_SERVICETYPE_DISCOVERY,
        V_SERVICETYPE_ROUTING,
        V_SERVICETYPE_NETWORK,
        V_SERVICETYPE_TUNER,
        V_SERVICETYPE_DDSI2,
        V_SERVICETYPE_DDSI2E,
        V_SERVICETYPE_SNETWORK,
        V_SERVICETYPE_DURABILITY,
        V_SERVICETYPE_RECORD_REPLAY,
        V_SERVICETYPE_DBMSCONNECT,
        V_SERVICETYPE_SPLICED,
        V_SERVICETYPE_NWBRIDGE,
        V_SERVICETYPE_CMAGENT,
        V_SERVICETYPE_INCOGNITO,
        V_SERVICETYPE_COUNT
    };

    class v_serviceState extends v_observable {
        attribute c_string           name;
        attribute c_lock             lock;
        attribute v_serviceStateKind stateKind;
    };

    class v_service extends v_participant {
        attribute v_lease lease;
        attribute v_serviceState state;
        attribute v_serviceType serviceType;
    };

    class v_networking extends v_service {
        attribute v_networkingStatistics  statistics;
    };

    class v_durability extends v_service {
        attribute v_durabilityStatistics  statistics;
    };

    class v_nwbridge extends v_service {
        attribute c_long dummy;
        /*attribute v_nwbridgeStatistics  statistics;*/
    };

    class v_cmsoap extends v_service {
        attribute v_cmsoapStatistics  statistics;
    };

    class v_rnr extends v_service {
        attribute v_rnrStatistics  statistics;
    };

    class v_serviceManager extends v_entity {
        attribute c_mutex             mutex;
        attribute SET<v_serviceState> serviceStates;
    };

    /* -------------------------------------------------------------------------- */
    /* Configuration framework implementation                                     */
    /* -------------------------------------------------------------------------- */

    enum v_cfKind {
        V_CFNODE,
        V_CFATTRIBUTE,
        V_CFELEMENT,
        V_CFDATA,
        V_CFNODECOLLECTION,
        V_CFCOUNT
    };

    class v_cfElement;

    class v_configuration extends v_public {
        attribute v_cfElement        root;
        attribute c_ulong            idCounter;
        attribute c_string           uri;
    };

    /* This is an abstract class! */
    class v_cfNode {
        attribute c_ulong            id;
        attribute v_cfKind           kind;
        attribute c_string           name;
        attribute v_configuration configuration;
    };

    class v_cfAttribute extends v_cfNode {
        attribute c_value            value;
    };

    class v_cfElement extends v_cfNode {
        attribute SET<v_cfAttribute> attributes;
        attribute SET<v_cfNode>      children;
    };

    class v_cfData extends v_cfNode {
        attribute c_value            value;
    };

    /* -------------------------------------------------------------------------- */
    /* Built-in Topic type definitions                                            */
    /* -------------------------------------------------------------------------- */

    enum v_infoId {
        V_PARTICIPANTINFO_ID,
        V_TYPEINFO_ID,
        V_TOPICINFO_ID,
        V_PUBLICATIONINFO_ID,
        V_SUBSCRIPTIONINFO_ID,
        V_HEARTBEATINFO_ID,
        V_DELIVERYINFO_ID,
        V_C_AND_M_COMMAND_ID,
        V_CMPARTICIPANTINFO_ID,
        V_CMDATAWRITERINFO_ID,
        V_CMDATAREADERINFO_ID,
        V_CMPUBLISHERINFO_ID,
        V_CMSUBSCRIBERINFO_ID,
        V_INFO_ID_COUNT
    };

    class v_heartbeatInfoTemplate extends v_message {
        attribute kernelModule::v_heartbeatInfo userData;
    };

    class v_topicInfoTemplate extends v_message {
        attribute kernelModule::v_topicInfo userData;
    };

    class v_typeInfoTemplate extends v_message {
        attribute kernelModule::v_typeInfo userData;
    };

    class v_publicationInfoTemplate extends v_message {
        attribute kernelModule::v_publicationInfo userData;
    };

    class v_dataWriterCMInfoTemplate extends v_message {
        attribute kernelModule::v_dataWriterCMInfo userData;
    };

    class v_subscriptionInfoTemplate extends v_message {
        attribute kernelModule::v_subscriptionInfo userData;
    };

    class v_dataReaderCMInfoTemplate extends v_message {
        attribute kernelModule::v_dataReaderCMInfo userData;
    };

    class v_publisherCMInfoTemplate extends v_message {
        attribute kernelModule::v_publisherCMInfo userData;
    };

    class v_subscriberCMInfoTemplate extends v_message {
        attribute kernelModule::v_subscriberCMInfo userData;
    };

    class v_deliveryInfoTemplate extends v_message {
        attribute kernelModule::v_deliveryInfo userData;
    };

    /* -------------------------------------------------------------------------- */
    /* Table reader type implementation                                           */
    /* -------------------------------------------------------------------------- */

    const c_long V_OWNERSTRENGTH_MINIMUM = 0x7fffffff;

    class v_index extends v_object {
        attribute ARRAY<c_field>                 sourceKeyList;
        attribute ARRAY<c_field>                 messageKeyList;
        attribute c_voidp                        reader;
        attribute SET<v_object>                  objects;
        attribute SET<v_object>                  notEmptyList;
        attribute c_voidp                        entry; /* temporary until dataReaderEntry extends from index */
        attribute c_type                         objectType;
    };

    class v_purgeListItem {
        attribute v_dataReaderInstance           instance;
        attribute os_timeM                       insertionTime;
        attribute c_long                         genCount; /* generation equal or older should be removed */
    };

    class v_dataReaderEntry extends v_entry {
        attribute v_topic                        topic;
        attribute v_index                        index;
        attribute ARRAY<v_filter>                filterInstance;
        attribute ARRAY<v_filter>                filterData;
        /* timed list of samples with a limited lifespan. */
        attribute v_lifespanAdmin                lifespanAdmin;
        /* Lists for garbagecollection/autopurging
         * Two lists are used because each of them is time-ordered but the
         * union of the lists is not */
        attribute v_transactionAdmin             transactionAdmin;
        attribute LIST<v_purgeListItem>          purgeListDisposed; /* No Writers */
        attribute LIST<v_purgeListItem>          purgeListNotEmpty; /* No Writers */
    };

    class v_deadLineReaderInstanceList {
        attribute v_dataReaderInstance           firstInstance;
        attribute c_voidp                        lastInstance;
    };

    class v_dataView extends v_collection {
        attribute SET<v_dataViewInstance>        instances;
        attribute c_voidp                        reader;
        attribute c_type                         sampleType;
        attribute v_dataViewQos                  qos;
        /* The takenInstance attribute is used for 'take' operations
           Normally the instance is destroyed after a take and the
           instance handle is expired, but an application should be
           be able to use the instance handle for a 'take_next_instance'
           operation. So we always remember the last instance taken, so
           we determine the next instance.
        */
        attribute v_dataViewInstance             takenInstance;
        attribute c_type                         instanceType;
    };

    class v_dataReader extends v_reader {
        /* Attributes are protected by the observer lock! */
        attribute v_index                        index;
        attribute SET<v_dataView>                views;
        attribute v_deadLineInstanceList         deadLineList;
        attribute LIST<v_dataReaderInstance>     minimumSeparationList;
        attribute v_lease                        minimumSeparationLease;
        attribute os_duration                    maximumSeparationTime; /* minimum separation time + property value. */
        attribute c_long                         resourceSampleCount;
        attribute c_long                         notReadCount;
        attribute c_long                         notReadTriggerThreshold;
        attribute c_long                         notReadTriggerCount;
        attribute c_bool                         maxInstances;
        /* Attributes maintaining the current state wrt the policies */
        attribute c_ulong                        shareCount;
        attribute c_type                         sampleType;
        attribute v_projection                   projection;
        attribute v_orderedInstance              orderedInstance;
        attribute v_dataReaderSample             triggerValue;
        attribute c_bool                         walkRequired;
        attribute v_dataReaderStatistics         statistics;

        /* This Count is the read/take sequence number of the reader.
         * Any read or take operation will increment this value and mark
         * all processed samples with this value by assigning this value to
         * the samples readId attribute.
         * Any subsequent accesses to this sample during thie read action can
         * detect already processed samples and skip them.
         * (Samples can be accesses multiple times during one read or take
         * action as result of queries containing OR operations).
         */
        attribute c_ulong                        readCnt;

#ifdef _MSG_STAMP_
        attribute v_laptime                      writerCopyTime[2];
        attribute v_laptime                      writerLookupTime[2];
        attribute v_laptime                      writerWriteTime[2];
        attribute v_laptime                      groupLookupTime[2];
        attribute v_laptime                      groupWriteTime[2];
        attribute v_laptime                      readerLookupTime[2];
        attribute v_laptime                      readerInstanceTime[2];
        attribute v_laptime                      readerInsertTime[2];
        attribute v_laptime                      readerNotifyTime[2];
        attribute v_laptime                      readerReadTime[2];
        attribute v_laptime                      readerCopyTime[2];
        attribute v_laptime                      nwSerialisationTime[2];
        attribute v_laptime                      nwBufferFullTime[2];
        attribute v_laptime                      nwFlushBufferTime[2];
        attribute v_laptime                      nwSendTime[2];
        attribute v_laptime                      nwReceiveTime[2];
        attribute v_laptime                      nwInsertTime[2];
#endif
    };

    /* v_deliveryService is a nodal service that provides
     * a wait for delivery acknowledgements method.
     */

    class v_deliveryService extends v_reader {
        attribute SET<v_subscriptionInfoTemplate> subscriptions;
        attribute SET<v_deliveryGuard> guards;
        attribute c_mutex mutex;
    };

    class v_deliveryServiceEntry extends v_entry {
        attribute v_topic topic;
    };

    /* -------------------------------------------------------------------------- */
    /* Group stream implementation                                                */
    /* -------------------------------------------------------------------------- */

    enum v_groupActionKind {
        V_GROUP_ACTION_WRITE, V_GROUP_ACTION_DISPOSE,
        V_GROUP_ACTION_REGISTER, V_GROUP_ACTION_UNREGISTER,
        V_GROUP_ACTION_LIFESPAN_EXPIRE, V_GROUP_ACTION_CLEANUP_DELAY_EXPIRE,
        V_GROUP_ACTION_DELETE_DATA, V_GROUP_ACTION_TRANSACTION_COMPLETE
    };

    class v_groupAction extends v_object {
        attribute v_groupActionKind kind;
        attribute os_timeE          actionTime;
        attribute v_message         message;
        attribute v_group           group;
    };

    /* Abstract base class for all readers interested in all events in the group.*/
    class v_groupStream extends v_reader {
        attribute SET<v_group>      groups;
        attribute LIST<c_string>    expr;
    };

    class v_groupQueueSample {
        attribute v_groupAction action;
        attribute v_groupQueueSample next;
    };

    class v_groupQueue extends v_groupStream {
        attribute c_ulong            size;
        attribute c_ulong            maxSize;
        attribute v_groupQueueSample head;
        attribute v_groupQueueSample tail;
        attribute c_voidp            marker; /* v_groupQueueSample */
        attribute c_bool             markerReached;
        attribute v_groupQueueStatistics statistics;
    };

    /* -------------------------------------------------------------------------- */
    /* Networking reader type implementation                                      */
    /* -------------------------------------------------------------------------- */
    typedef c_ulong v_networkId;
    const v_networkId V_NETWORKID_LOCAL = 0x0;
    const v_networkId V_NETWORKID_ANY = 0xffffffff;
    const v_networkId V_NETWORKID_DDSI = 0xABADBABE;

    typedef c_ulong v_networkPartitionId;
    const v_networkPartitionId V_NETWORKPARTITIONID_LOCALHOST = 0xffffffff;

    typedef struct v_networkHashValue_s {
        c_octet h1;
        c_octet h2;
        c_octet h3;
        c_octet h4;
    } v_networkHashValue;

    enum v_networkRoutingMode {
        V_NETWORKROUTING_NONE,
        V_NETWORKROUTING_FROM_GROUP,
        V_NETWORKROUTING_ROUTING,
        V_NETWORKROUTING_ECHO
    };

    class v_networkReaderEntry extends v_entry {
        /* Hash for quick lookup by networking; */
        attribute v_networkHashValue             hashValue;
        /* Has a one-to-one relationship with group */
        attribute c_voidp                        group;
        /* ID of the network connected to this entry */
        attribute v_networkId                    networkId;
        /* Countdown until all channels have connected */
        attribute c_ulong                        channelCountdown;
        attribute c_mutex                        channelCountdownMutex;
        /* Networkpartition to send data to */
        attribute v_networkPartitionId           networkPartitionId;
        /* Flags indicating routing interest of entry */
        attribute v_networkRoutingMode           routing;
    };

    /* New implementation of networkQueue */
    class v_networkQueueSample {
        attribute v_message                      message;
        attribute v_networkReaderEntry           entry;
        attribute c_ulong                        sequenceNumber;
        attribute kernelModule::v_gid                          sender;
        attribute c_bool                         sendTo;
        attribute kernelModule::v_gid                          receiver; /* if sendTo is TRUE */
        attribute v_networkQueueSample                next;
    };

    class v_networkStatusMarker {
        attribute os_timeE                       sendBefore;
        attribute c_ulong                        priority;
        attribute v_networkQueueSample           firstSample;
        attribute c_voidp                        lastSample; /* v_networkSample */
        attribute v_networkStatusMarker          next;
    };

    class v_networkQueue {
        /* Qos properties for this queue */
        attribute c_ulong                        priority;
        attribute c_bool                         reliable;
        attribute c_bool                         P2P;
        /* The queue itself */
        attribute c_ulong                        maxMsgCount;
        attribute c_ulong                        currentMsgCount;
        /* List of statusmarkers in use */
        attribute v_networkStatusMarker          firstStatusMarker;
        attribute c_voidp                        lastStatusMarker; /* v_networkStatusMarker */
        /* List of free objects to avoid exhaustive mmMalloc/mmFree calls */
        attribute v_networkStatusMarker          freeStatusMarkers;
        attribute v_networkQueueSample           freeSamples;
        /* Types stored for caching, avoid resolving */
        attribute c_type                         statusMarkerType;
        attribute c_type                         sampleType;
        /* Behavioral attributes for this queue */
        attribute c_bool                         periodic;
        attribute c_bool                         triggered;
        attribute c_bool                         threadWaiting;
        attribute os_duration                    resolution;
        attribute c_ulong                        msecsResolution;
        attribute c_ulong                        phaseMilliSeconds;
        attribute os_timeE                       nextWakeup;
        attribute c_mutex                        mutex;
        attribute c_cond                         cv;
        attribute v_networkQueueStatistics       statistics;
    };

    class v_networkReader extends v_reader {
        attribute c_ulong                        nofQueues;
        attribute ARRAY<v_networkQueue>          queues;
        attribute v_networkQueue                 defaultQueue;
        /* Boolean indicating if anybody is alive remotely */
        attribute c_bool                         remoteActivity;
        attribute c_bool                         ignoreReliabilityQoS; /* required re-usage of code for DDSi service */
        /* Queue cache to store bestQueue's per priority */
        attribute ARRAY<v_networkQueue>          queueCache;
        attribute v_networkReaderStatistics      statistics;
    };


    /* -------------------------------------------------------------------------- */
    /* Durability client type implementation                                      */
    /* -------------------------------------------------------------------------- */

    enum v_durabilityClientTopicIds {
        V_DC_TOPIC_STATE_ID,
        V_DC_TOPIC_STATE_REQUEST_ID,
        V_DC_TOPIC_DATA_ID,
        V_DC_TOPIC_DATA_REQUEST_ID,
        V_DC_TOPIC_ID_COUNT
    };

    enum v_durabilityClientReaderIds {
        V_DC_READER_STATE_ID,
        V_DC_READER_DATA_ID,
        V_DC_READER_SUBSCRIPTIONINFO_ID,
        V_DC_READER_ID_COUNT
    };

    enum v_durabilityClientWriterIds {
        V_DC_WRITER_STATE_REQUEST_ID,
        V_DC_WRITER_DATA_REQUEST_ID,
        V_DC_WRITER_ID_COUNT
    };

    enum v_durabilityClientPartitionIds {
        V_DC_PARTITION_REQUEST_ID,
        V_DC_PARTITION_GLOBAL_DATA_ID,
        V_DC_PARTITION_PRIVATE_DATA_ID,
        V_DC_PARTITION_ID_COUNT
    };

    class v_durabilityClientServer {
        attribute c_ulong       systemId;
        attribute c_longlong    prefixId;
        attribute c_longlong    suffixId;
        attribute c_ulong       rdrFlags;
    };

    class v_durabilityClientEvent {
        attribute c_ulong       kind;
        attribute v_handle      entity;
        attribute c_object      eventData;
        attribute os_duration   timeout;    /* only applicable for V_EVENT_HISTORY_REQUEST event */
    };

    class v_durabilityClient extends v_object {
        attribute c_voidp       durablePolicies;
        attribute v_subscriber  builtinSubscriber;
        attribute v_participant participant;
        attribute v_subscriber  subscriber;
        attribute v_publisher   publisher;
        attribute v_topic       topics[V_DC_TOPIC_ID_COUNT];
        attribute v_dataReader  readers[V_DC_READER_ID_COUNT];
        attribute v_writer      writers[V_DC_WRITER_ID_COUNT];
        attribute c_string      partitions[V_DC_PARTITION_ID_COUNT];
        attribute v_waitset     waitset;
        attribute c_bool        terminate;
        attribute c_bool        y2038ready;
        attribute c_mutex       mutex;
        attribute c_ulong       requestId;                 /* last requestId handed out, initially 0 */
        attribute c_voidp       chains;                    /* table of chains allocated on heap */
        attribute c_voidp       rejected_chains;           /* table of rejected chains allocated on heap */
        attribute c_voidp       servers2;                  /* table of servers allocated on heap */

        attribute SET<v_durabilityClientServer> servers; /* c_table servers<v_durabilityClientServer> */
        attribute LIST<v_durabilityClientEvent> queue;
    };


    /* -------------------------------------------------------------------------- */
    /* Kernel Class implementation                                                */
    /* -------------------------------------------------------------------------- */

    class v_groupSet extends v_observable {
        attribute SET<v_group>                   groups;
        attribute c_lock                         lock;
        attribute c_long                         sequenceNumber;
    };

    class v_builtin {
        /* built-in topics */
        attribute v_participant                  participant;
        attribute v_publisher                    publisher;
        attribute v_topic                        topics[V_INFO_ID_COUNT];
        attribute v_writer                       writers[V_INFO_ID_COUNT];
        attribute v_kernelQos                    kernelQos;
    };

    class v_pendingDisposeElement {
        attribute kernelModule::v_commandDisposeAllData disposeCmd;
        attribute os_timeW disposeTimestamp;
    };

    class v_kernel extends v_entity {
        attribute kernelModule::v_gid            GID;
        attribute SET<v_participant>             participants;
        attribute SET<v_topic>                   topics;
        attribute SET<v_partition>               partitions;
        attribute SET<v_typeRepresentation>      typeRepresentations;
        attribute v_groupSet                     groupSet;
        attribute c_type                         type[K_TYPECOUNT];
        attribute c_lock                         lock;
        attribute v_handleServer                 handleServer;
        attribute v_kernelQos                    qos;
        attribute v_transactionGroupAdmin        transactionGroupAdmin;
        /* Following attributes are for synchronisation between group flushing and durability alignment requests. */
        attribute c_mutex                        accessLock;  /* Begin and End access lock */
        attribute c_ulong                        accessCount; /* multi durability service support, number of active Begin access */
        attribute c_bool                         accessBusy;  /* access is in progress */
        attribute c_cond                         accessCond;  /* triggered on accessBusy set FALSE */
        attribute v_serviceManager               serviceManager;
        attribute v_leaseManager                 livelinessLM;
        attribute v_deliveryService              deliveryService;
        attribute v_configuration                configuration;
        attribute c_ulong                        networkServiceCount;
        attribute pa_uint32_t                    transactionCount;
        /* ES: dds2476: Added a boolean to indicate if the spliced is running or not
         * this boolean is set to false when it is detected by any (non-service)
         * participant that the splice deamon is not longer running.
         * Once set to false the u_entityClaim functions will no longer work as those
         * check this boolean
         */
        attribute c_bool                        splicedRunning;
        /* ES: dds2235: added warning levels for resource limits
         * whenever the value is exceed a warning message will be printed.
         * To ensure the log files are not flooded by warning messages
         * a boolean is maintained to ensure a warning is only printed once
         */
        attribute c_ulong                        maxSamplesWarnLevel;
        attribute c_bool                         maxSamplesWarnShown;
        attribute c_ulong                        maxSamplesPerInstanceWarnLevel;
        attribute c_bool                         maxSamplesPerInstanceWarnShown;
        attribute c_ulong                        maxInstancesWarnLevel;
        attribute c_bool                         maxInstancesWarnShown;

        attribute v_builtin                      builtin;

        /* Set of enabled statistics categories */
        attribute SET<c_string>                  enabledStatisticsCategories;
        attribute v_kernelStatistics             statistics;

        /* List of dispose alls pending for groups not yet seen */
        attribute LIST<v_pendingDisposeElement>  pendingDisposeList;
        attribute c_mutex                        pendingDisposeListMutex;

        /* Set of shared entities */
        attribute c_mutex                        sharesMutex;
        attribute SET<v_entity>                  shares;
        attribute SET<v_processInfo>             attachedProcesses;
        attribute os_duration                    retentionPeriod;

        /* Flag to determine if (client)durability is enabled */
        attribute c_bool                         durabilitySupport;
    };

    /* -------------------------------------------------------------------------- */
    /* Kernel management implementation                                           */
    /* -------------------------------------------------------------------------- */

    const string V_SPLICED_NAME = "splicedaemon";

    class v_spliced extends v_service {
        attribute v_subscriber    builtinSubscriber;
        attribute v_dataReader    readers[V_INFO_ID_COUNT];
        attribute SET<v_message>  builtinData[V_INFO_ID_COUNT];
        attribute kernelModule::v_heartbeatInfo hb;       /* the heartbeat data */
        attribute v_lease         hbUpdate; /* lease for periodically writing heartbeat */
        attribute v_lease         hbCheck;  /* lease for next check on heartbeats */
        attribute v_leaseManager  hbManager;
        attribute v_waitset       ws;
        attribute c_bool          quit;
        attribute c_bool          cAndMCommandDispatcherQuit;
        attribute v_waitset       cAndMCommandWaitSet;

        attribute c_mutex         mtx;
        attribute c_mutex         cAndMCommandMutex;
        attribute c_mutex         builtinDataMutex;
        attribute SET<v_message>  missedHB; /* c_table missedHB<v_message> */

        attribute v_durabilityClient durabilityClient;
    };
};
