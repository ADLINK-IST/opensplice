#define _EXTENT_

module kernelModule {

typedef struct v_gid_s {
    c_ulong systemId; /* kernelId + sessionId */
    c_ulong localId;
    c_ulong serial;
} v_gid;

typedef c_time v_duration;

typedef c_ulong v_state;

enum v_writeResult {
    V_WRITE_UNDEFINED,
    V_WRITE_SUCCESS,
	V_WRITE_SUCCESS_NOT_STORED,
    V_WRITE_REGISTERED,
    V_WRITE_UNREGISTERED,
    V_WRITE_PRE_NOT_MET,
    V_WRITE_ERROR,
    V_WRITE_TIMEOUT,
    V_WRITE_REJECTED,
    V_WRITE_COUNT
};

enum v_historyResult {
    V_HISTORY_RESULT_UNDEFINED,
    V_HISTORY_RESULT_ERROR,
    V_HISTORY_RESULT_BAD_PARAM,
    V_HISTORY_RESULT_TIMEOUT,
    V_HISTORY_RESULT_PRE_NOT_MET,
    V_HISTORY_RESULT_OK
};

/* -------------------------------------------------------------------------- */
/* Statistics implementation                                                 */
/* -------------------------------------------------------------------------- */

typedef struct v_timedValue_s {
    c_time lastUpdate;
    c_ulong value;
} v_timedValue;

typedef v_timedValue v_minValue;
typedef v_timedValue v_maxValue;

typedef struct v_avgValue_s {
    c_float value;
    c_ulong count;
} v_avgValue;

typedef struct v_fullCounter_s {
    c_ulong    value;
    v_minValue min;
    v_maxValue max;
    v_avgValue avg;
} v_fullCounter;

/* This is an abstract class! */
class v_statistics {
    attribute c_time              lastReset;
};

class v_writerStatistics extends v_statistics {
    attribute c_ulong            numberOfWrites;
    attribute c_ulong            numberOfDisposes;
    attribute c_ulong            numberOfRegisters;
    attribute c_ulong            numberOfImplicitRegisters;
    attribute c_ulong            numberOfUnregisters;
    attribute c_ulong            numberOfTimedOutWrites;
    attribute c_ulong            numberOfWritesBlockedBySamplesLimit;
    attribute c_ulong            numberOfWritesBlockedByInstanceLimit;
    attribute c_ulong            numberOfWritesBlockedBySamplesPerInstanceLimit;
    attribute c_ulong            numberOfRetries;

    attribute c_ulong            numberOfInstancesWithStatusAlive;
    attribute c_ulong            numberOfInstancesWithStatusDisposed;
    attribute c_ulong            numberOfInstancesWithStatusUnregistered;
    attribute c_ulong            numberOfSamples;
    attribute v_maxValue         maxNumberOfSamplesPerInstance;
};

class v_readerStatistics extends v_statistics {
    attribute v_maxValue         maxSampleSize;
    attribute v_maxValue         maxSamplesPerInstance;
    attribute v_maxValue         maxNumberOfSamples;
    attribute v_maxValue         maxNumberOfInstances;

    attribute c_ulong            numberOfSamples;
    attribute c_ulong            numberOfInstances;

    attribute v_fullCounter      readLatency;
    attribute v_fullCounter      transportLatency;

    attribute c_ulong            numberOfInstancesWithStatusNew;
    attribute c_ulong            numberOfInstancesWithStatusAlive;
    attribute c_ulong            numberOfInstancesWithStatusDisposed;
    attribute c_ulong            numberOfInstancesWithStatusNoWriters;

    attribute c_ulong            numberOfSamplesWithStatusRead;
    attribute c_ulong            numberOfSamplesExpired;
    attribute c_ulong            numberOfSamplesPurgedByDispose;
    attribute c_ulong            numberOfSamplesPurgedByNoWriters;

    attribute c_ulong            numberOfSamplesArrived;
    attribute c_ulong            numberOfSamplesInserted;
    attribute c_ulong            numberOfSamplesDiscarded;
    attribute c_ulong            numberOfSamplesRead;
    attribute c_ulong            numberOfSamplesTaken;
    attribute c_ulong            numberOfSamplesRejectedBySamplesLimit;
    attribute c_ulong            numberOfSamplesRejectedByInstancesLimit;

    attribute c_ulong            numberOfReads;
    attribute c_ulong            numberOfInstanceReads;
    attribute c_ulong            numberOfNextInstanceReads;
    attribute c_ulong            numberOfInstanceLookups;
    attribute c_ulong            numberOfTakes;
    attribute c_ulong            numberOfInstanceTakes;
    attribute c_ulong            numberOfNextInstanceTakes;
};

class v_queryStatistics extends v_statistics {
    attribute c_ulong            numberOfReads;
    attribute c_ulong            numberOfInstanceReads;
    attribute c_ulong            numberOfNextInstanceReads;
    attribute c_ulong            numberOfTakes;
    attribute c_ulong            numberOfInstanceTakes;
    attribute c_ulong            numberOfNextInstanceTakes;
};

class v_networkQueueStatistics { /* Reachable via v_networkReaderStatistics only */
    attribute c_string           name;
    attribute c_ulong            numberOfSamplesArrived;
    attribute c_ulong            numberOfSamplesInserted;
    attribute c_ulong            numberOfSamplesRejected;
    attribute v_fullCounter      numberOfSamplesWaiting;
    attribute c_ulong            numberOfSamplesTaken;
};

class v_networkReaderStatistics extends v_statistics {
    attribute c_ulong            queuesCount;
    attribute ARRAY<v_networkQueueStatistics> queues;
};

class v_networkChannelStatistics { /* Reachable via v_networkingStatistics only */
    attribute c_string           name;
    attribute c_ulong            numberOfMessagesSent;
    attribute c_ulong            numberOfBytesSent;
    attribute c_ulong            numberOfPacketsSent;

    attribute c_ulong            numberOfMessagesFragmented;
    attribute c_ulong            numberOfMessagesPacked;

    attribute c_ulong            numberOfKnownNodes;
    attribute c_ulong            numberOfBytesResent;
    attribute c_ulong            numberOfPacketsResent;
    attribute c_ulong            numberOfBytesInResendBuffer;
    attribute c_ulong            numberOfPacketsInResendBuffer;
    attribute v_maxValue         maxNumberOfBytesResentToOneNode;
    attribute v_maxValue         maxNumberOfPacketsResentToOneNode;

    attribute c_ulong            numberOfMessagesReceived;
    attribute c_ulong            numberOfBytesReceived;
    attribute c_ulong            numberOfPacketsReceived;
    attribute c_ulong            numberOfPacketsLost;
    attribute c_ulong            numberOfAcksSent;

    attribute c_ulong            numberOfMessagesDelivered;
    attribute c_ulong            numberOfBytesDelivered;
    attribute c_ulong            numberOfMessagesNotInterested;
    attribute c_ulong            numberOfBytesNotInterested;
    attribute c_ulong            nofFreePacketBuffers;
    attribute c_ulong            nofUsedPacketBuffers;
    attribute v_fullCounter      adminQueueAcks;
    attribute v_fullCounter      adminQueueData;

    attribute c_ulong            nofBytesBeforeCompression;    
    attribute c_ulong            nofBytesAfterCompression;    
    attribute c_ulong            nofBytesBeforeDecompression;    
    attribute c_ulong            nofBytesAfterDecompression;    
};

class v_networkingStatistics extends v_statistics  {
    attribute c_ulong            numberOfErrors;
    attribute c_ulong            channelsCount;
    attribute ARRAY<v_networkChannelStatistics> channels;
};

class v_cmsoapStatistics  extends v_statistics {
    attribute v_maxValue         maxConnectedClients;
    attribute v_maxValue         maxClientThreads;
    attribute c_ulong            connectedClients;
    attribute c_ulong            clientThreads;
    attribute c_ulong            requestsHandled;
};

class v_durabilityStatistics extends v_statistics  {
    attribute c_ulong            persistentSamplesWritten;
    attribute v_maxValue         fellowsKnownMax;
    attribute c_ulong            fellowsKnown;
    attribute c_ulong            fellowsApproved;
    attribute c_ulong            fellowsIncompatibleState;
    attribute c_ulong            fellowsIncompatibleDataModel;
    attribute c_ulong            nameSpacesKnown;
    attribute c_ulong            nameSpacesMaster;
    attribute c_ulong            nameSpacesSlave;
    attribute c_ulong            groupsToCreateTotal;
    attribute c_ulong            groupsToCreateVolatile;
    attribute c_ulong            groupsToCreateTransient;
    attribute c_ulong            groupsToCreatePersistent;
    attribute c_ulong            groupsKnownTotal;
    attribute c_ulong            groupsKnownVolatile;
    attribute c_ulong            groupsKnownTransient;
    attribute c_ulong            groupsKnownPersistent;
    attribute c_ulong            groupsCompleteTotal;
    attribute c_ulong            groupsCompleteVolatile;
    attribute c_ulong            groupsCompleteTransient;
    attribute c_ulong            groupsCompletePersistent;
    attribute c_ulong            groupsIncompleteTotal;
    attribute c_ulong            groupsIncompleteVolatile;
    attribute c_ulong            groupsIncompleteTransient;
    attribute c_ulong            groupsIncompletePersistent;
    attribute c_ulong            groupsIgnoredTotal;
    attribute c_ulong            groupsIgnoredVolatile;
    attribute c_ulong            groupsIgnoredTransient;
    attribute c_ulong            groupsIgnoredPersistent;
    attribute c_ulong            alignerRequestsReceived;
    attribute c_ulong            alignerRequestsIgnored;
    attribute c_ulong            alignerRequestsAnswered;
    attribute c_ulong            alignerRequestsOpen;
    attribute v_maxValue         alignerRequestsOpenMax;
    attribute c_ulong            alignerRequestsCombined;
    attribute c_ulong            alignerRequestsCombinedOpen;
    attribute v_maxValue         alignerRequestsCombinedOpenMax;
    attribute c_ulong            alignerRequestsCombinedAnswered;
    attribute c_ulong            aligneeRequestsSent;
    attribute v_maxValue         aligneeRequestsOpenMax;
    attribute c_ulong            aligneeRequestsOpen;
    attribute c_ulong            aligneeRequestsWaiting;
    attribute v_maxValue         aligneeRequestsWaitingMax;
    attribute c_ulong            aligneeSamplesTotal;
    attribute c_ulong            aligneeSamplesRegister;
    attribute c_ulong            aligneeSamplesWrite;
    attribute c_ulong            aligneeSamplesDispose;
    attribute c_ulong            aligneeSamplesWriteDispose;
    attribute c_ulong            aligneeSamplesUnregister;
    attribute c_ulong            alignerSamplesTotal;
    attribute c_ulong            alignerSamplesRegister;
    attribute c_ulong            alignerSamplesWrite;
    attribute c_ulong            alignerSamplesDispose;
    attribute c_ulong            alignerSamplesWriteDispose;
    attribute c_ulong            alignerSamplesUnregister;
    attribute c_ulong            aligneeTotalSize;
    attribute c_ulong            alignerTotalSize;
};

class v_kernelStatistics extends v_statistics  {
    attribute v_maxValue         maxShmUsed;
    attribute v_maxValue         maxShmGarbage;
    attribute v_maxValue         maxShmClaims;

    attribute c_ulong            shmUsed;
    attribute c_ulong            shmClaims;
    attribute c_ulong            shmClaimFails;
    attribute c_ulong            shmGarbage;
};

/* -------------------------------------------------------------------------- */
/*  Handle server implementation                                              */
/* -------------------------------------------------------------------------- */

/* note that name convention applied to v_handleInfo_s is related to
   implementation of macro C_CAST */

typedef struct v_handleInfo_s {
    c_object object;      /* object that is managed associated to the handle described by this info */
    c_long   serial;      /* handle generation for this specific handle. */
    c_ulong  count;       /* the number of actual claims. */
    c_bool   freed;       /* a flag indicating that the handle is freed. */
    c_long   nextFree;    /* only used if this handle is ready for reuse, implements a free list. */
} v_handleInfo;

typedef ARRAY<v_handleInfo> v_handleInfoList;

class v_handleServer {
    attribute ARRAY<v_handleInfoList> handleInfos;   /* The list of all handle info records. */
    attribute c_long                  firstFree;     /* The head of the handle info free list. */
    attribute c_long                  lastIndex;     /* The last index allocated. */
    attribute c_mutex                 mutex;         /* The mutex that handles access to the server. */
    attribute c_bool                  suspended;     /* Whether the server currently is suspended. */
};

/* note that name convention applied to v_handle_s is related to
   implementation of macro C_CAST */

typedef struct v_handle_s {
    c_address server;       /* reference to the handle server. */
    c_long    index;        /* the index to the handle info record within the handle server. */
    c_long    serial;       /* the handle generation to which this handle belongs. */
} v_handle;

/* -------------------------------------------------------------------------- */
/*  Kernel Infrastructure                                                     */
/* -------------------------------------------------------------------------- */

enum v_kind {
    K_KERNEL,            K_OBJECT,             K_ENTITY,
    K_GROUPSET,
    K_WAITSET,           K_CONDITION,
    K_QUERY,             K_DATAREADERQUERY,    K_DATAVIEW,
    K_PROJECTION,        K_MAPPING,            K_FILTER,
    K_DEADLINEINSTANCE,
    K_MESSAGE,           K_TRANSACTION,
    K_WRITERINSTANCE,    K_WRITERSAMPLE,       K_WRITERCACHEITEM,
    K_GROUPINSTANCE,     K_GROUPSAMPLE,        K_GROUPCACHEITEM,
    K_DATAREADERINSTANCE,K_READERSAMPLE,
    K_DATAVIEWINSTANCE,  K_DATAVIEWQUERY,      K_DATAVIEWSAMPLE,
    K_WRITERINSTANCETEMPLATE,
    K_TOPIC,
    K_PUBLISHER,         K_SUBSCRIBER,
    K_DOMAIN,            K_DOMAININTEREST,     K_DOMAINADMIN,
    K_READER,            K_WRITER,
    K_ENTRY,             K_DATAREADERENTRY,    K_DELIVERYSERVICEENTRY,
    K_GROUP,             K_WRITERGROUP,        K_CACHE,
    K_GROUPACTION,       K_GROUPSTREAM,
    K_GROUPQUEUE,        K_GROUPQUEUESAMPLE,
    K_DATAREADER,        K_DELIVERYSERVICE,    K_PARTICIPANT,
    K_PURGELISTITEM,     K_GROUPPURGEITEM,
    K_INDEX,
    K_READERSTATUS,      K_WRITERSTATUS,
    K_PUBLISHERSTATUS,   K_SUBSCRIBERSTATUS,
    K_DOMAINSTATUS,      K_TOPICSTATUS,
    K_PARTICIPANTSTATUS, K_KERNELSTATUS,
    K_READERSTATISTICS,  K_WRITERSTATISTICS,   K_QUERYSTATISTICS,
    K_PROXY,              K_WAITSETEVENT,
    K_WAITSETEVENTHISTORYDELETE, K_WAITSETEVENTHISTORYREQUEST, K_WAITSETEVENTPERSISTENTSNAPSHOT,
    K_SERVICEMANAGER,    K_SERVICE,            K_SERVICESTATE,
    K_NETWORKING,        K_DURABILITY,         K_CMSOAP,
    K_LEASEMANAGER,      K_LEASE,              K_LEASEACTION,
    K_SPLICED,
    K_CONFIGURATION,
    K_REGISTRATION,
    /* Networking types */
    K_NETWORKREADER,       K_NETWORKREADERENTRY,   K_NETWORKMESSAGE,
    /* kinds needed for quick lookup. Note that these are no v_object
     * descendents */
    K_NETWORKMAPENTRY,
    K_HISTORICALDATAREQUEST,
    K_PERSISTENTSNAPSHOTREQUEST,
    K_PENDINGDISPOSEELEMENT,
    /* This constant must always be the last */
    K_TYPECOUNT
};

class v_object {
    attribute v_kind                         kind;
    attribute c_voidp                        kernel;
};

class v_public extends v_object {
    attribute v_handle                       handle;
    attribute c_voidp                        userDataPublic;
};

class v_status extends v_object {
    attribute c_ulong                        state;
};

enum v_entityState { V_ENTITYSTATE_DISABLED, V_ENTITYSTATE_SUSPENDED, V_ENTITYSTATE_ENABLED };

class v_entity extends v_public {
    attribute c_string                       name;
    attribute v_status                       status;
    attribute v_statistics                   statistics;
    attribute c_bool                         enabled;
};

/* This proxy can be used for both local and remote
   public objects.
*/
class v_proxy extends v_object {
    attribute v_handle                       source;
    attribute c_voidp                        userData;
    attribute c_voidp                        source2;
};

class v_observable extends v_entity {
    attribute c_mutex                        mutex;
    attribute SET<v_proxy>                   observers;
};

class v_observer extends v_observable {
    attribute c_cond                         cv;
    attribute c_mutex                        mutex;
    attribute c_long                         waitCount;
    attribute c_ulong                        eventMask;
    attribute c_ulong                        eventFlags;
/* place to store event data by the observer */
    attribute c_voidp                        eventData;
};

class v_query;

class v_collection extends v_observer {
    attribute SET<v_query>                   queries;
};

class v_query extends v_collection {
    attribute c_voidp                        source;
};

class v_dataReaderSample;

class v_dataReaderQuery extends v_query {
    attribute ARRAY<c_query>         instanceQ; /* predicate on key fields */
    attribute ARRAY<c_query>         sampleQ;   /* predicate on non-key fields */
    attribute c_ulong                state;
    attribute v_state                instanceMask;
    attribute v_state                sampleMask;
    attribute v_state                viewMask;
    attribute c_string               expression;
    attribute c_string               params;
    attribute v_dataReaderSample     triggerValue;
    attribute c_bool                 walkRequired;
    attribute c_ulong                updateCnt;
};

typedef v_dataReaderQuery v_dataViewQuery;

class v_historicalDataRequest;
class v_persistentSnapshotRequest;

class v_waitsetEvent {
    attribute v_handle source;
    attribute c_ulong kind;
    attribute c_voidp userData;
    attribute v_waitsetEvent next;
};

class v_waitsetEventHistoryDelete extends v_waitsetEvent {
    attribute c_time deleteTime;
    attribute c_string partitionExpr;
    attribute c_string topicExpr;
};

class v_waitsetEventHistoryRequest extends v_waitsetEvent {
    attribute v_historicalDataRequest request;
};

class v_waitsetEventPersistentSnapshot extends v_waitsetEvent {
    attribute v_persistentSnapshotRequest request;
};

class v_waitset extends v_observer {
    /* The eventlist for the waitset is stored as eventData in v_observer */
    attribute c_voidp participant;
    attribute v_waitsetEvent eventCache;
    attribute SET<v_proxy> observables;
};

enum v_leaseActionId {
    V_LEASEACTION_UNDEFINED,
    V_LEASEACTION_SERVICESTATE_EXPIRED,
    V_LEASEACTION_READER_DEADLINE_MISSED,
    V_LEASEACTION_WRITER_DEADLINE_MISSED,
    V_LEASEACTION_LIVELINESS_CHECK,
    V_LEASEACTION_HEARTBEAT_SEND,
    V_LEASEACTION_HEARTBEAT_CHECK,
    V_LEASEACTION_SPLICED_DEATH_DETECTED,
    V_LEASEACTION_COUNT /* This constant must always be the last */
};

class v_leaseManager;

class v_lease extends v_object {
    attribute c_mutex                        mutex;
    attribute c_time                         expiryTime;
    attribute v_duration                     duration;
    attribute SET<v_leaseManager>            observers;
};

class v_leaseAction extends v_object 
{
    attribute v_lease lease;
    attribute v_leaseActionId actionId;
    attribute v_handle actionObject;
    attribute c_bool repeat;
};

class v_leaseManager extends v_object {
    attribute c_mutex                        mutex;
    attribute c_cond                         cond;
    attribute c_bool                         quit;
    attribute v_leaseAction                  firstLeaseToExpire;
    attribute SET<v_leaseAction>             leases;
};

/* -------------------------------------------------------------------------- */
/*  Status implementation                                                  */
/* -------------------------------------------------------------------------- */

typedef c_long v_policyId;

struct v_QosPolicyCount {
    v_policyId                               policyId;
    c_long                                   count;
};

enum v_sampleRejectedKind {
    S_NOT_REJECTED,
    S_REJECTED_BY_INSTANCES_LIMIT,
    S_REJECTED_BY_SAMPLES_LIMIT,
    S_REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT
};

struct v_inconsistentTopicInfo {
    c_long                         totalCount;
    c_long                         totalChanged;
};

struct v_allDataDisposedInfo {
    c_long                         totalCount;
    c_long                         totalChanged;
};

struct v_sampleLostInfo {
    c_long                         totalCount;
    c_long                         totalChanged;
};

struct v_livelinessLostInfo {
    c_long                         totalCount;
    c_long                         totalChanged;
};

struct v_deadlineMissedInfo {
    c_long                         totalCount;
    c_long                         totalChanged;
    v_handle                       instanceHandle;
};

struct v_sampleRejectedInfo {
    c_long                         totalCount;
    c_long                         totalChanged;
    v_sampleRejectedKind           lastReason;
    v_gid                          instanceHandle;
};

struct v_incompatibleQosInfo {
    c_long                         totalCount;
    c_long                         totalChanged;
    v_policyId                     lastPolicyId;
    ARRAY<c_long>                  policyCount;
};

struct v_livelinessChangedInfo {
    c_long                         activeCount;
    c_long                         activeChanged;
    c_long                         inactiveCount;
    c_long                         inactiveChanged;
    v_gid                          instanceHandle;
};

struct v_topicMatchInfo {
    c_long                         totalCount;
    c_long                         totalChanged;
    c_long                         currentCount;
    c_long                         currentChanged;
    v_gid                          instanceHandle;
};

struct v_servicesChangedInfo {
    c_long                         totalCount;
    c_long                         totalChanged;
};

struct v_groupsChangedInfo {
    c_long                         totalCount;
    c_long                         totalChanged;
};

class v_kernelStatus extends v_status {
    attribute v_servicesChangedInfo          servicesInfo;
};

class v_partitionStatus extends v_status {
    attribute v_groupsChangedInfo            groupsChanged;
};

class v_topicStatus extends v_status {
    attribute v_inconsistentTopicInfo        inconsistentTopic;
    attribute v_allDataDisposedInfo          allDataDisposed;
};

class v_subscriberStatus extends v_status {
 attribute c_long       dummy;
};

class v_writerStatus extends v_status {
    attribute v_livelinessLostInfo           livelinessLost;
    attribute v_deadlineMissedInfo           deadlineMissed;
    attribute v_incompatibleQosInfo          incompatibleQos;
    attribute v_topicMatchInfo               publicationMatch;
};

class v_readerStatus extends v_status {
    attribute v_livelinessChangedInfo        livelinessChanged;
    attribute v_sampleRejectedInfo           sampleRejected;
    attribute v_sampleLostInfo               sampleLost;
    attribute v_deadlineMissedInfo           deadlineMissed;
    attribute v_incompatibleQosInfo          incompatibleQos;
    attribute v_topicMatchInfo               subscriptionMatch;
};

/* -------------------------------------------------------------------------- */
/* Policy implementations                                                     */
/* -------------------------------------------------------------------------- */

/* This value is used to specify unlimited resources and history depth */
const c_long V_LENGTH_UNLIMITED             = -1;

/* The value of a policy id is identical to
 * the value of the policy id at API level! */
/* added so id's can be used as index in array's */
const v_policyId V_UNKNOWN_POLICY_ID        = 0;

const v_policyId V_USERDATAPOLICY_ID          = 1;
const v_policyId V_DURABILITYPOLICY_ID        = 2;
const v_policyId V_PRESENTATIONPOLICY_ID      = 3;
const v_policyId V_DEADLINEPOLICY_ID          = 4;
const v_policyId V_LATENCYPOLICY_ID           = 5;
const v_policyId V_OWNERSHIPPOLICY_ID         = 6;
const v_policyId V_STRENGTHPOLICY_ID          = 7;
const v_policyId V_LIVELINESSPOLICY_ID        = 8;
const v_policyId V_PACINGPOLICY_ID            = 9;
const v_policyId V_PARTITIONPOLICY_ID         = 10;
const v_policyId V_RELIABILITYPOLICY_ID       = 11;
const v_policyId V_ORDERBYPOLICY_ID           = 12;
const v_policyId V_HISTORYPOLICY_ID           = 13;
const v_policyId V_RESOURCEPOLICY_ID          = 14;
const v_policyId V_ENTITYFACTORYPOLICY_ID     = 15;
const v_policyId V_WRITERLIFECYCLEPOLICY_ID   = 16;
const v_policyId V_READERLIFECYCLEPOLICY_ID   = 17;
const v_policyId V_TOPICDATAPOLICY_ID         = 18;
const v_policyId V_GROUPDATAPOLICY_ID         = 19;
const v_policyId V_TRANSPORTPOLICY_ID         = 20;
const v_policyId V_LIFESPANPOLICY_ID          = 21;
const v_policyId V_DURABILITYSERVICEPOLICY_ID = 22;
const v_policyId V_USERKEYPOLICY_ID           = 23;
const v_policyId V_VIEWKEYPOLICY_ID           = 24;
const v_policyId V_READERLIFESPANPOLICY_ID    = 25;
const v_policyId V_SHAREPOLICY_ID             = 26;
const v_policyId V_SCHEDULINGPOLICY_ID        = 27;

const v_policyId V_POLICY_ID_COUNT            = 28;

const c_string V_USERDATAPOLICY_NAME          = "UserData";
const c_string V_DURABILITYPOLICY_NAME        = "Durability";
const c_string V_PRESENTATIONPOLICY_NAME      = "Presentation";
const c_string V_DEADLINEPOLICY_NAME          = "Deadline";
const c_string V_LATENCYPOLICY_NAME           = "LatencyBudget";
const c_string V_OWNERSHIPPOLICY_NAME         = "Ownership";
const c_string V_STRENGTHPOLICY_NAME          = "OwnershipStrength";
const c_string V_LIVELINESSPOLICY_NAME        = "Liveliness";
const c_string V_PACINGPOLICY_NAME            = "TimeBasedFilter";
const c_string V_PARTITIONPOLICY_NAME         = "Partition";
const c_string V_RELIABILITYPOLICY_NAME       = "Reliability";
const c_string V_ORDERBYPOLICY_NAME           = "DestinationOrder";
const c_string V_HISTORYPOLICY_NAME           = "History";
const c_string V_RESOURCEPOLICY_NAME          = "ResourceLimits";
const c_string V_ENTITYFACTORYPOLICY_NAME     = "EntityFactory";
const c_string V_WRITERLIFECYCLEPOLICY_NAME   = "WriterDataLifecycle";
const c_string V_READERLIFECYCLEPOLICY_NAME   = "ReaderDataLifecycle";
const c_string V_TOPICDATAPOLICY_NAME         = "TopicData";
const c_string V_GROUPDATAPOLICY_NAME         = "GroupData";
const c_string V_TRANSPORTPOLICY_NAME         = "TransportPriority";
const c_string V_LIFESPANPOLICY_NAME          = "Lifespan";
const c_string V_DURABILITYSERVICEPOLICY_NAME = "DurabilityService";
const c_string V_USERKEYPOLICY_NAME           = "SubscriptionKey";
const c_string V_READERLIFESPANPOLICY_NAME    = "ReaderLifespan";
const c_string V_SHAREPOLICY_NAME             = "Share";
const c_string V_SCHEDULINGPOLICY_NAME        = "Scheduling";

/**
 * IMPORTANT: all enumeration values must be ordered according compatibility,
 * since they are used to check compatibility between readers and writers.
 */

enum v_durabilityKind {
    V_DURABILITY_VOLATILE,
    V_DURABILITY_TRANSIENT_LOCAL,
    V_DURABILITY_TRANSIENT,
    V_DURABILITY_PERSISTENT
};

enum v_presentationKind {
    V_PRESENTATION_INSTANCE,
    V_PRESENTATION_TOPIC,
    V_PRESENTATION_GROUP
};

enum v_livelinessKind {
    V_LIVELINESS_AUTOMATIC,
    V_LIVELINESS_PARTICIPANT,
    V_LIVELINESS_TOPIC
};

enum v_reliabilityKind {
    V_RELIABILITY_BESTEFFORT,
    V_RELIABILITY_RELIABLE
};

enum v_ownershipKind {
    V_OWNERSHIP_SHARED,
    V_OWNERSHIP_EXCLUSIVE
};

enum v_historyQosKind {
    V_HISTORY_KEEPLAST,
    V_HISTORY_KEEPALL
};

enum v_orderbyKind {
    V_ORDERBY_RECEPTIONTIME,
    V_ORDERBY_SOURCETIME
};

enum v_scheduleKind {
    V_SCHED_DEFAULT,
    V_SCHED_TIMESHARING,
    V_SCHED_REALTIME
};

enum v_schedulePriorityKind {
    V_SCHED_PRIO_RELATIVE,
    V_SCHED_PRIO_ABSOLUTE
};

typedef c_string v_partitionPolicy;

struct v_sharePolicy {
    c_string                          name;
    c_bool                            enable;
};

struct v_userDataPolicy {
     ARRAY<c_octet>                   value;
     c_long                           size;
};

struct v_topicDataPolicy {
     ARRAY<c_octet>                   value;
     c_long                           size;
};

struct v_groupDataPolicy {
     ARRAY<c_octet>                   value;
     c_long                           size;
};

struct v_transportPolicy {
    c_long                            value;
};

struct v_lifespanPolicy {
    v_duration                        duration;
};

struct v_durabilityPolicy {
    v_durabilityKind                  kind;
};

struct v_durabilityServicePolicy {
    v_duration                        service_cleanup_delay;
    v_historyQosKind                  history_kind;
    c_long                            history_depth;
    c_long                            max_samples;
    c_long                            max_instances;
    c_long                            max_samples_per_instance;
};

struct v_presentationPolicy {
    v_presentationKind                access_scope;
    c_bool                            coherent_access;
    c_bool                            ordered_access;
};

struct v_deadlinePolicy {
    v_duration                        period;
};

struct v_latencyPolicy {
    v_duration                        duration;
};

struct v_ownershipPolicy {
    v_ownershipKind                   kind;
};

struct v_strengthPolicy {
    c_long                            value;
};

struct v_livelinessPolicy {
    v_livelinessKind                  kind;
    v_duration                        lease_duration;
};

struct v_reliabilityPolicy {
    v_reliabilityKind                 kind;
    v_duration                        max_blocking_time;
    c_bool                            synchronous;
};

struct v_historyPolicy {
    v_historyQosKind                  kind;
    c_long                            depth;
};

struct v_orderbyPolicy {
    v_orderbyKind                     kind;
};

struct v_resourcePolicy {
    c_long                            max_samples;
    c_long                            max_instances;
    c_long                            max_samples_per_instance;
};

struct v_pacingPolicy {
    v_duration                        minSeperation;
};

struct v_entityFactoryPolicy {
    c_bool                            autoenable_created_entities;
};

struct v_writerLifecyclePolicy {
    c_bool                            autodispose_unregistered_instances;
    v_duration                        autopurge_suspended_samples_delay;
    v_duration                        autounregister_instance_delay;
};

struct v_readerLifecyclePolicy {
    v_duration                        autopurge_nowriter_samples_delay;
    v_duration                        autopurge_disposed_samples_delay;
    c_bool                            enable_invalid_samples;
};

struct v_simulationPolicy {
    c_time                            oldTime;
    c_time                            newTime;
    c_double                          relativeSpeed;
};

struct v_userKeyPolicy {
    c_bool                            enable;
    c_string                          expression;
};

struct v_readerLifespanPolicy {
    c_bool                            used;
    v_duration                        duration;
};

struct v_schedulePolicy {
    v_scheduleKind                    kind;
    v_schedulePriorityKind            priorityKind;
    c_long                            priority;
};

struct v_builtinTopicPolicy {
    c_bool enabled;
};

enum v_qosKind {
    V_PARTITION_QOS,
    V_PARTICIPANT_QOS,
    V_TOPIC_QOS,
    V_WRITER_QOS,
    V_READER_QOS,
    V_PUBLISHER_QOS,
    V_SUBSCRIBER_QOS,
    V_INDEX_QOS,
    V_WRITERHISTORY_QOS,
    V_GROUPHISTORY_QOS,
    V_VIEW_QOS,
    V_DATAVIEW_QOS,
    V_KERNEL_QOS,
    V_COUNT_QOS /* This constant must always be the last */
};

class v_qos {
    attribute v_qosKind                 kind;
};

class v_kernelQos extends v_qos {
    attribute v_builtinTopicPolicy      builtin;
};

class v_partitionQos extends v_qos {
    attribute v_simulationPolicy        simulation;
    attribute v_userDataPolicy          userData;
    attribute v_entityFactoryPolicy     entityFactory;
};

class v_participantQos extends v_qos {
    attribute v_entityFactoryPolicy     entityFactory;
    attribute v_userDataPolicy          userData;
    attribute v_schedulePolicy          watchdogScheduling;
};

class v_topicQos extends v_qos {
    attribute v_topicDataPolicy         topicData;
    attribute v_durabilityPolicy        durability;
    attribute v_durabilityServicePolicy durabilityService;
    attribute v_deadlinePolicy          deadline;
    attribute v_latencyPolicy           latency;
    attribute v_livelinessPolicy        liveliness;
    attribute v_reliabilityPolicy       reliability;
    attribute v_orderbyPolicy           orderby;
    attribute v_historyPolicy           history;
    attribute v_resourcePolicy          resource;
    attribute v_transportPolicy         transport;
    attribute v_lifespanPolicy          lifespan;
    attribute v_ownershipPolicy         ownership;
};

class v_writerQos extends v_qos {
    attribute v_durabilityPolicy        durability;
    attribute v_deadlinePolicy          deadline;
    attribute v_latencyPolicy           latency;
    attribute v_livelinessPolicy        liveliness;
    attribute v_reliabilityPolicy       reliability;
    attribute v_orderbyPolicy           orderby;
    attribute v_historyPolicy           history;
    attribute v_resourcePolicy          resource;
    attribute v_transportPolicy         transport;
    attribute v_lifespanPolicy          lifespan;
    attribute v_userDataPolicy          userData;
    attribute v_ownershipPolicy         ownership;
    attribute v_strengthPolicy          strength;
    attribute v_writerLifecyclePolicy   lifecycle;
};

class v_readerQos extends v_qos {
    attribute v_durabilityPolicy        durability;
    attribute v_deadlinePolicy          deadline;
    attribute v_latencyPolicy           latency;
    attribute v_livelinessPolicy        liveliness;
    attribute v_reliabilityPolicy       reliability;
    attribute v_orderbyPolicy           orderby;
    attribute v_historyPolicy           history;
    attribute v_resourcePolicy          resource;
    attribute v_userDataPolicy          userData;
    attribute v_ownershipPolicy         ownership;
    attribute v_pacingPolicy            pacing;
    attribute v_readerLifecyclePolicy   lifecycle;
    attribute v_readerLifespanPolicy    lifespan;
    attribute v_sharePolicy             share;
    attribute v_userKeyPolicy           userKey;
};

class v_publisherQos extends v_qos {
    attribute v_presentationPolicy      presentation;
    attribute v_partitionPolicy         partition;
    attribute v_groupDataPolicy         groupData;
    attribute v_entityFactoryPolicy     entityFactory;
};

class v_subscriberQos extends v_qos {
    attribute v_presentationPolicy      presentation;
    attribute v_partitionPolicy         partition;
    attribute v_groupDataPolicy         groupData;
    attribute v_entityFactoryPolicy     entityFactory;
    attribute v_sharePolicy             share;
};

class v_dataViewQos extends v_qos {
    attribute v_userKeyPolicy           userKey;
};

/* -------------------------------------------------------------------------- */
/*  Meta data implementation                                                  */
/* -------------------------------------------------------------------------- */

class v_mapping {
    attribute c_field                        source;
    attribute c_field                        destination;
};

class v_projection {
    attribute c_type                         resultType;
    attribute ARRAY<v_mapping>               rules;
};

enum v_accessMode { V_ACCESS_MODE_UNDEFINED,
                    V_ACCESS_MODE_READ,
                    V_ACCESS_MODE_WRITE,
                    V_ACCESS_MODE_READ_WRITE,
                    V_ACCESS_MODE_NONE,
                    V_ACCESS_MODE_COUNT };

class v_topic extends v_observer {
    attribute c_type                         messageType;
    attribute c_property                     dataField;
    attribute v_topicQos                     qos;
    attribute c_string                       keyExpr;
    attribute ARRAY<c_field>                 messageKeyList;
    attribute v_accessMode                   accessMode;
    /* keyType is a reference to a generated type 'topicName<Key>'.
       It is a structure that contains fields 'field1'.. 'fieldN'.
       The fields correspond to the fields specified by the keyList.
       Note that this reference is only for convenience so default
       DataWriters and DataReaders do not have to create the type themselves.
    */
    attribute c_type                         keyType;
    attribute c_ulong                        crcOfName;
    attribute c_ulong                        crcOfTypeName;
#ifdef _EXTENT_
    attribute c_extent                       messageExtent;
#endif
};

class v_filter {
    attribute v_topic                        topic;
    attribute c_object                       predicate;
};

/* -------------------------------------------------------------------------- */
/* Partition implementation
/* -------------------------------------------------------------------------- */

class v_partition extends v_entity {
    attribute v_qos                         qos;
};

/* -------------------------------------------------------------------------- */
/* Instance List Item implementation
/* -------------------------------------------------------------------------- */

class v_instance extends v_public {
    attribute c_time                         lastCheckTime;
    attribute c_voidp                        next;
    attribute c_voidp                        prev;
};

class v_deadLineInstanceList extends v_instance {
    attribute v_lease                        deadlineLease;
    attribute v_leaseManager                 leaseManager;
    attribute v_duration                     leaseDuration;
    attribute c_voidp                        actionObject; /* reader or writer */
    attribute v_leaseActionId                actionId;
};

class v_partitionInterest {
    /* attribute c_long                         index; */
    /* attribute c_bool                         interested; */
    attribute c_string                       expression;
};

class v_partitionAdmin extends v_object { /* only used by v_publisher and v_subscriber */
    attribute c_mutex                        mutex;
    attribute SET<v_partition>               partitions;
    attribute SET<v_partitionInterest>       partitionInterests;
};

/* -------------------------------------------------------------------------- */
/* Message implementation                                                     */
/* -------------------------------------------------------------------------- */

class v_node {
    attribute v_state                        nodeState;
};

typedef ARRAY<c_octet> v_messageQos;

#ifdef _MSG_STAMP_

typedef c_longlong v_hrtime;

typedef struct v_laptime_s {
    v_hrtime cur;
    v_hrtime min;
    v_hrtime max;
    v_hrtime tot;
    c_long count;
} v_laptime;
#endif

/*
 * allocTime is filled when a message is first written and subsequently used 
 * during the processing whenever the current time is used, upto the point where 
 * it is inserted in the reader databases where it is also used for the insertion_time.
 * For practical purposes this works okay, but for accurate internal latency
 * measurement this disturbes the outcome, as the time needed for processing can no 
 * longer be measured. For this purpose the _NAT_ compile flag exist. When this flag is 
 * cleared, allocTime isn't used and accurate latency measurements are possible.
 * This flag should only be cleared when doing such internal measurements.
 */
class v_message extends v_node {
#ifndef _NAT_
    attribute c_time                         allocTime;
#endif
    attribute c_time                         writeTime;
    attribute v_gid                          writerGID;
    attribute v_gid                          writerInstanceGID;
    attribute c_ulong                        sequenceNumber;
    attribute c_ulong                        transactionId;
    attribute v_messageQos                   qos;
#ifdef _MSG_STAMP_
    attribute c_long                         hops;
    attribute v_hrtime                       writerAllocTime[2];
    attribute v_hrtime                       writerCopyTime[2];
    attribute v_hrtime                       writerLookupTime[2];
    attribute v_hrtime                       groupInsertTime[2];
    attribute v_hrtime                       groupLookupTime[2];
    attribute v_hrtime                       readerInsertTime[2];
    attribute v_hrtime                       readerLookupTime[2];
    attribute v_hrtime                       readerDataAvailableTime[2];
    attribute v_hrtime                       readerInstanceTime[2];
    attribute v_hrtime                       readerNotifyTime[2];
    attribute v_hrtime                       readerReadTime[2];
    attribute v_hrtime                       readerCopyTime[2];

    attribute v_hrtime                       nwSerialisationTime[2];
    attribute v_hrtime                       nwBufferFullTime[2];
    attribute v_hrtime                       nwFlushBufferTime[2];
    attribute v_hrtime                       nwSendTime[2];
    attribute v_hrtime                       nwReceiveTime[2];
    attribute v_hrtime                       nwInsertTime[2];
#endif
};

/* -------------------------------------------------------------------------- */
/* Lifespan implementation                                                    */
/* -------------------------------------------------------------------------- */

class v_lifespanSample {
    attribute c_time           expiryTime;
    attribute v_lifespanSample next;
    attribute c_voidp          prev;
};

class v_lifespanAdmin {
    attribute c_long           sampleCount;
    attribute v_lifespanSample head;
    attribute v_lifespanSample tail;
};

/* -------------------------------------------------------------------------- */
/* Instance pipeline cache implementation                                     */
/* -------------------------------------------------------------------------- */

enum v_cacheKind { V_CACHE_CONNECTION,
                   V_CACHE_TARGETS,
                   V_CACHE_SOURCES,
                   V_CACHE_ANY };

struct v_cacheLink {
    c_voidp                                  next;
    c_voidp                                  prev;
};

class v_cacheNode {
    attribute v_cacheLink                    connections;
    attribute v_cacheLink                    targets;
    attribute v_cacheLink                    sources;
};

class v_cache extends v_cacheNode {
    attribute v_cacheKind                    kind;
    attribute c_type                         itemType;
};

class v_cacheItem extends v_cacheNode {
    attribute c_voidp                        instance;
};

typedef v_cacheItem v_writerCacheItem;

class v_groupCacheItem extends v_cacheItem {
    attribute c_voidp                        groupInstance;
    attribute c_long                         registrationCount;
    attribute c_long                         pendingResends;
};

/* -------------------------------------------------------------------------- */
/* Reader implementation                                                      */
/* -------------------------------------------------------------------------- */

class v_dataViewSampleList;

class v_readerSample extends v_lifespanSample {
    attribute c_time                         readTime;
    attribute v_state                        sampleState;
    attribute c_voidp                        instance;
    attribute c_voidp                        viewSamples;
};

class v_dataViewSampleList extends v_readerSample {
    attribute c_voidp                        next;
    attribute c_voidp                        prev;
};

class v_dataViewSample extends v_dataViewSampleList {
    attribute v_dataViewSample               prev;
    attribute c_voidp                        next;
};

class v_dataViewSampleTemplate extends v_dataViewSample {
    attribute v_readerSample                 sample;
};

class v_dataViewInstance extends v_public {
    attribute c_voidp                        dataView;
    attribute v_state                        instanceState;
    attribute c_long                         sampleCount;
};

class v_dataViewInstanceTemplate extends v_dataViewInstance {
    attribute v_dataViewSample               sample;
};

class v_dataReaderSample extends v_readerSample {
    attribute v_dataReaderSample             older;
    attribute c_voidp                        newer;
    attribute c_time                         insertTime;
    attribute c_long                         disposeCount;
    attribute c_long                         noWritersCount;
    attribute v_gid                          publicationHandle;
    /* This ID is the readCnt value of the reader.
     * when this sample is processed by any read or take method and
     * this value is equal to the actual value of the reader then
     * this sample is already processed and can be skipped.
     */
    attribute c_ulong                        readId;
};

class v_dataReaderSampleTemplate extends v_dataReaderSample {
    attribute v_message                      message;
};

struct v_owner {
    v_gid  gid;
    c_long strength;
    c_bool exclusive;
};

struct v_historyBookmark {
    c_time sourceTimestamp;
    v_gid gid;
};

class v_dataReaderInstance extends v_instance {
    attribute c_voidp                        index;
    attribute v_state                        instanceState;
    attribute c_long                         disposeCount;
    attribute c_long                         noWritersCount;
    attribute c_long                         sampleCount;
    attribute c_time                         purgeInsertionTime;
    attribute c_time                         epoch;
    attribute v_historyBookmark              lastConsumed;
    attribute c_voidp                        userDataDataReaderInstance;
    attribute c_long                         liveliness;
    attribute v_owner                        owner;
    attribute c_bool                         hasBeenAlive;
    attribute c_bool                         inNotEmptyList;
    attribute v_cache                        sourceCache;
};

class v_dataReaderInstanceTemplate extends v_dataReaderInstance {
    attribute v_dataReaderSampleTemplate     sample;
    attribute c_voidp                        oldest;
};

class v_entry extends v_object {
    attribute c_voidp                        reader;
    attribute SET<v_proxy>                   groups;
};

struct v_entrySet {
    c_mutex                                  mutex;
    SET<v_entry>                             entries;
};

class v_historicalDataRequest {
    attribute c_string                       filter;
    attribute ARRAY<c_string>                filterParams;
    attribute v_resourcePolicy               resourceLimits;
    attribute c_time                         minSourceTimestamp;
    attribute c_time                         maxSourceTimestamp;
};

class v_persistentSnapshotRequest {
    attribute c_string                       topicExpr;
    attribute c_string                       partitionExpr;
    attribute c_string                       uri;
};

class v_reader extends v_collection {
    attribute v_entrySet                     entrySet;
    attribute c_voidp                        subscriber;
    attribute v_subscriberQos                subQos; /* ref is ro */
    attribute v_readerQos                    qos;

    /* Attributes to support historical data requests with conditions */
    attribute v_historicalDataRequest        historicalDataRequest;
    attribute c_cond                         historicalDataCondition;
    attribute c_bool                         historicalDataComplete;
};


/* -------------------------------------------------------------------------- */
/* Group implementation                                                       */
/* -------------------------------------------------------------------------- */

class v_groupStream;

class v_groupSample extends v_lifespanSample {
    attribute v_groupSample                  older;
    attribute c_voidp                        newer;
    attribute c_voidp                        instance;
};

class v_groupSampleTemplate extends v_groupSample {
    attribute v_message                      message;
};

class v_registration {
    attribute v_gid                          writerGID;
    attribute v_messageQos                   qos;
    attribute c_time                         writeTime;
    attribute v_registration                 next;
};

class v_groupInstance extends v_object {
    attribute c_ulong                        state;
    attribute c_long                         messageCount; /* only write messages */
    attribute c_long                         count; /* write AND disposed messages */
    attribute c_voidp                        group;
    attribute c_voidp                        oldest;
    attribute v_cache                        targetCache;
    attribute v_registration                 registrations;
    attribute v_registration                 unregistrations;
    attribute c_time                         epoch;
    attribute v_owner                        owner;
};

class v_groupInstanceTemplate extends v_groupInstance {
    attribute v_groupSampleTemplate          newest;
};

class v_groupEntry {
    attribute v_entry                        entry;
    attribute c_long                         sequenceNumber;
    attribute v_cache                        connectionCache;
    attribute v_groupEntry                   next;
};

struct v_groupEntrySet {
    v_groupEntry                             firstEntry;
    c_long                                   lastSequenceNumber;
};

class v_groupPurgeItem {
    attribute v_groupInstance                instance;
    attribute c_time                         insertionTime;
    attribute v_groupPurgeItem               next;
};

enum v_groupAttachState {
    V_GROUP_ATTACH_STATE_UNKNOWN,
    V_GROUP_ATTACH_STATE_ATTACHED,
    V_GROUP_ATTACH_STATE_NO_INTEREST
};

/** Class v_group:
    The attributes topic and partition specifies the data space of
    the group. The attribute writers is a set of all the writers
    currently writing to this group. The attribute disposedInstances
    is a deathrow for disposed instances which will be deleted after
    a qos defined delay.
*/
class v_group extends v_entity {

    /* Group meta description */
    attribute v_topic                        topic;
    attribute v_partition                    partition;
    attribute c_long                         depth;
    attribute v_accessMode                   partitionAccessMode;
    /* Group associated Reader Entries */
    attribute v_groupEntrySet topicEntrySet;   /* Normal dataReader entries. */
    attribute v_groupEntrySet networkEntrySet; /* Network interface entries. */
    attribute v_groupEntrySet variantEntrySet; /* Variant keyed dataReader entries. */
    attribute SET<v_groupStream> streams; /* Streams interested in all actions */

    /* Group process control. */
    attribute c_mutex                        mutex;
    attribute c_cond                         cv; /* for group complete */

    /* Group state */
    attribute c_long                         sequenceNumber;
    attribute c_long                         count;
    attribute c_time                         creationTime;
    attribute c_bool                         infWait;
    attribute c_bool                         complete;

    /* Service attachment states*/
    attribute SET<c_string>                  attachedServices;
    attribute SET<c_string>                  notInterestedServices;

    /* group data storage */
    attribute SET<v_groupInstance>           instances;
    attribute v_groupPurgeItem               disposedInstances;
    attribute c_voidp                        disposedInstancesLast;
    attribute v_groupPurgeItem               purgeListEmpty;
    attribute c_voidp                        purgeListEmptyLast;

    attribute v_lifespanAdmin                lifespanAdmin;

    /* Group resource optimisation */
    attribute v_message                      cachedRegMsg;
    attribute v_groupInstance                cachedInstance;
#ifdef _EXTENT_
    attribute c_extent                       instanceExtent;
    attribute c_extent                       sampleExtent;
#endif
};

/* -------------------------------------------------------------------------- */
/* Writer implementation                                                      */
/* -------------------------------------------------------------------------- */

typedef c_octet v_resendScope;

class v_writerSample {
    attribute v_writerSample                 next;
    attribute c_voidp                        prev;
    attribute c_ulong                        sequenceNumber;
    attribute c_long                         decayCount;
    attribute c_bool                         resend;
    attribute c_bool                         sentBefore;
    attribute v_resendScope                  resendScope;
};

class v_writerSampleTemplate extends v_writerSample {
    attribute v_message                      message;
};

class v_writerInstance extends v_instance {
    /* The current state of this instance */
    attribute c_ulong                        state;
    /* The current number of messages in this instance */
    attribute c_long                         messageCount;
    /* The total number of messages ever inserted in this sample */
    attribute c_long                         sampleSequenceNumber;
    attribute c_voidp                        writer;  /* v_writer, backref */
    attribute c_voidp                        last;    /* v_writerSample, not counted */
    attribute v_cache                        targetCache;
    attribute c_long                         deadlineCount;
    attribute c_bool                         resend;
};

class v_writerInstanceTemplate extends v_writerInstance {
    attribute v_writerSample                 sample;
};

class v_writerGroup {
    attribute v_group                        group;
    attribute v_cache                        targetCache;
    attribute v_writerGroup                  next;
};

struct v_writerGroupSet {
    v_writerGroup                            firstGroup;
};

class v_deliveryWaitList {
    attribute c_ulong        sequenceNumber;
    attribute c_mutex        mutex;
    attribute c_cond         cv;
    attribute ARRAY<v_gid>   readerGID;
    attribute c_voidp        guard;
};

class v_deliveryPublisher {
    attribute v_gid readerGID;
    attribute c_ulong count;
};

class v_deliveryGuard {
    attribute v_gid writerGID;
    attribute c_voidp owner;
    attribute c_type gidType;
    attribute SET<v_deliveryPublisher> publications;
    attribute SET<v_deliveryWaitList> waitlists;
};


class v_writer extends v_observer {
    attribute v_topic                        topic;
    attribute v_writerGroupSet               groupSet;
    attribute c_property                     messageField;
    attribute c_long                         depth;
    attribute SET<v_writerInstance>          instances;
    attribute c_long                         count;
    attribute c_ulong                        sequenceNumber;
    attribute c_ulong                        transactionId;
    attribute c_ulong                        transactionCount;
    attribute c_bool                         infWait;

    attribute v_deadLineInstanceList         deadlineList;
    attribute c_long                         deadlineCountLimit;
    attribute c_voidp                        publisher;
    attribute v_writerQos                    qos;
    attribute v_publisherQos                 pubQos;
    attribute v_messageQos                   msgQos;
    attribute v_messageQos                   relQos;
    attribute c_type                         msgQosType;
    attribute c_bool                         alive;           /* alive wrt liveliness policy */
    attribute v_lease                        livelinessLease; /* readonly */

    attribute SET<v_writerInstance>          resendInstances; /* instances to be resend */
#ifdef _EXTENT_
    attribute c_extent                       instanceExtent;
    attribute c_extent                       sampleExtent;
#endif

    attribute v_writerInstance               cachedInstance;

    attribute v_deliveryGuard                deliveryGuard;

#ifdef PROFILER
/* PROFILER attributes */
    attribute c_voidp                        t1;
    attribute c_voidp                        t2;
    attribute c_voidp                        t3;
    attribute c_voidp                        t4;
    attribute c_voidp                        t5;
    attribute c_voidp                        t6;
#endif
};

/* -------------------------------------------------------------------------- */
/* Pub/Sub factory implementation                                             */
/* -------------------------------------------------------------------------- */

class v_subscriber extends v_observer {
    attribute v_partitionAdmin               partitions;
    attribute SET<v_reader>                  readers;
    attribute c_mutex                        sharesMutex;
    attribute SET<v_reader>                  shares;
    attribute c_lock                         lock;
    attribute c_voidp                        participant;
    attribute v_subscriberQos                qos;
    attribute c_ulong                        shareCount;
};

class v_publisher extends v_observer {
    attribute v_partitionAdmin               partitions;
    attribute SET<v_writer>                  writers;
    attribute c_lock                         lock;
    attribute c_voidp                        participant;
    attribute v_publisherQos                 qos;
    attribute c_time                         suspendTime; /* inf means not suspended */
    attribute c_ulong                        transactionId;
};
const string V_BUILT_IN_PARTICIPANT_NAME = "Built-in participant";
class v_participant extends v_observer {
    attribute SET<v_entity>                  entities;
    attribute c_lock                         lock;
    attribute v_participantQos               qos;
    attribute v_leaseManager                 leaseManager;
/* resend thread will wait on this condition. This thread is created in the
   user layer!
 */
    attribute c_bool                         resendQuit;
    attribute c_cond                         resendCond;
    attribute c_mutex                        resendMutex;
    attribute SET<v_proxy>                   resendWriters;
    attribute c_mutex                        builtinLock;
    attribute v_subscriber                   builtinSubscriber;
    attribute c_mutex                        newGroupListMutex;
    attribute LIST<v_group>                  newGroupList;
};

/* -------------------------------------------------------------------------- */
/* Service framework implementation                                           */
/* -------------------------------------------------------------------------- */

enum v_serviceStateKind {
    STATE_NONE,
    STATE_INITIALISING,
    STATE_OPERATIONAL,
    STATE_TERMINATING,
    STATE_TERMINATED,
    STATE_DIED
};

class v_serviceState extends v_observable {
    attribute c_lock             lock;
    attribute v_serviceStateKind stateKind;
};

class v_service extends v_participant {
    attribute v_lease lease;
    attribute v_serviceState state;
};

class v_networking extends v_service {
 attribute c_long dummy;
};

class v_durability extends v_service {
 attribute c_long dummy;
};

class v_cmsoap extends v_service {
 attribute c_long dummy;
};

class v_serviceManager extends v_observer {
    attribute c_mutex             mutex;
    attribute SET<v_serviceState> serviceStates;
};

/* -------------------------------------------------------------------------- */
/* Configuration framework implementation                                     */
/* -------------------------------------------------------------------------- */

enum v_cfKind {
    V_CFNODE,
    V_CFATTRIBUTE,
    V_CFELEMENT,
    V_CFDATA,
    V_CFNODECOLLECTION,
    V_CFCOUNT
};

class v_cfElement;

class v_configuration extends v_public {
    attribute v_cfElement        root;
    attribute c_ulong            idCounter;
    attribute c_string           uri;
};

/* This is an abstract class! */
class v_cfNode {
    attribute c_ulong            id;
    attribute v_cfKind           kind;
    attribute c_string           name;
    attribute v_configuration configuration;
};

class v_cfAttribute extends v_cfNode {
    attribute c_value            value;
};

class v_cfElement extends v_cfNode {
    attribute SET<v_cfAttribute> attributes;
    attribute SET<v_cfNode>      children;
};

class v_cfData extends v_cfNode {
    attribute c_value            value;
};

/* -------------------------------------------------------------------------- */
/* Built-in Topic type definitions                                            */
/* -------------------------------------------------------------------------- */

typedef v_gid v_builtinTopicKey;

enum v_infoId {
    V_PARTICIPANTINFO_ID,
    V_TOPICINFO_ID,
    V_PUBLICATIONINFO_ID,
    V_SUBSCRIPTIONINFO_ID,
    V_HEARTBEATINFO_ID,
    V_DELIVERYINFO_ID,
    V_C_AND_M_COMMAND_ID,
    V_INFO_ID_COUNT
};

struct v_builtinPartitionPolicy {
    sequence<c_string> name;
};

struct v_builtinTopicDataPolicy {
    ARRAY<c_octet> value;
};

struct v_builtinGroupDataPolicy {
    ARRAY<c_octet> value;
};

struct v_builtinUserDataPolicy {
    ARRAY<c_octet> value;
};

struct v_participantInfo {
/* The '_' before the fieldname is an escape, since the word 'key' is reserved.
   The odl parser will remove this '_' character and process accordingly.
*/
    v_builtinTopicKey                        _key;
    v_userDataPolicy                         user_data;
};

struct v_topicInfo {
    v_builtinTopicKey                        _key;
    c_string                                 name;
    c_string                                 type_name;
    v_durabilityPolicy                       durability;
    v_durabilityServicePolicy                durabilityService;
    v_deadlinePolicy                         deadline;
    v_latencyPolicy                          latency_budget;
    v_livelinessPolicy                       liveliness;
    v_reliabilityPolicy                      reliability;
    v_transportPolicy                        transport_priority;
    v_lifespanPolicy                         lifespan;
    v_orderbyPolicy                          destination_order;
    v_historyPolicy                          history;
    v_resourcePolicy                         resource_limits;
    v_ownershipPolicy                        ownership;
    v_builtinTopicDataPolicy                 topic_data;
/* all fields above must be memory layout compatible with the dds spec. */
    c_string                                 meta_data;
    c_string                                 key_list;
};

struct v_publicationInfo {
    v_builtinTopicKey                        _key;
    v_builtinTopicKey                        participant_key;
    c_string                                 topic_name;
    c_string                                 type_name;
    v_durabilityPolicy                       durability;
    v_deadlinePolicy                         deadline;
    v_latencyPolicy                          latency_budget;
    v_livelinessPolicy                       liveliness;
    v_reliabilityPolicy                      reliability;
    v_lifespanPolicy                         lifespan;
    v_orderbyPolicy                          destination_order;
    v_builtinUserDataPolicy                  user_data;
    v_ownershipPolicy                        ownership;
    v_strengthPolicy                         ownership_strength;
    v_presentationPolicy                     presentation;
    v_builtinPartitionPolicy                 partition;
    v_builtinTopicDataPolicy                 topic_data;
    v_builtinGroupDataPolicy                 group_data;
/* all fields above must be memory layout compatible with the dds spec. */
    v_writerLifecyclePolicy                  lifecycle;
    c_bool                                   alive; /* Indicates whether the writer is alive or not,
                                                     * with respect to liveliness policy.
                                                     */
};

class v_publicationInfoTemplate extends v_message {
    attribute v_publicationInfo userData;
};

struct v_subscriptionInfo {
    v_builtinTopicKey                        _key;
    v_builtinTopicKey                        participant_key;
    c_string                                 topic_name;
    c_string                                 type_name;
    v_durabilityPolicy                       durability;
    v_deadlinePolicy                         deadline;
    v_latencyPolicy                          latency_budget;
    v_livelinessPolicy                       liveliness;
    v_reliabilityPolicy                      reliability;
    v_ownershipPolicy                        ownership;
    v_orderbyPolicy                          destination_order;
    v_builtinUserDataPolicy                  user_data;
    v_pacingPolicy                           time_based_filter;
    v_presentationPolicy                     presentation;
    v_builtinPartitionPolicy                 partition;
    v_builtinTopicDataPolicy                 topic_data;
    v_builtinGroupDataPolicy                 group_data;
/* all fields above must be memory layout compatible with the dds spec. */
    /* Reader lifespan attribute added */
    v_readerLifespanPolicy                   lifespan;
};

class v_subscriptionInfoTemplate extends v_message {
    attribute v_subscriptionInfo userData;
};

struct v_deliveryInfo {
    v_gid   writerGID;
    v_gid   readerGID;
    c_ulong sequenceNumber;
};

class v_deliveryInfoTemplate extends v_message {
    attribute v_deliveryInfo userData;
};

struct v_heartbeatInfo {
    v_gid      id;
    v_duration period;
};

/* Note: Additional values may only be added at the end of this enum
   otherwise compatiability with previous versions will be broken! */
enum v_controlAndMonitoringCommandKind {
    V_COMMAND_DISPOSE_ALL_DATA
};

/* Note: To preseve compatablity this struct must never be altered, 
   ( changed api's must be implemented by adding a new struct and registering
   in the above enum ) */
struct v_commandDisposeAllData
{
   c_string topicExpr;
   c_string partitionExpr;
};

typedef struct v_controlAndMonitoringCommand_s 
{
    v_builtinTopicKey                        _key;
    union command_kind switch ( v_controlAndMonitoringCommandKind ) {
       case V_COMMAND_DISPOSE_ALL_DATA : v_commandDisposeAllData dispose_all_data_info;
    } u;
} v_controlAndMonitoringCommand;

/* -------------------------------------------------------------------------- */
/* Table reader type implementation                                           */
/* -------------------------------------------------------------------------- */

const c_long V_OWNERSTRENGTH_MINIMUM = 0x7fffffff;

class v_index extends v_object {
    attribute ARRAY<c_field>                 sourceKeyList;
    attribute ARRAY<c_field>                 messageKeyList;
    attribute c_voidp                        reader;
    attribute SET<v_object>                  objects;
    attribute SET<v_object>                  notEmptyList;
    attribute c_voidp                        entry; /* temporary until dataReaderEntry extends from index */
#ifdef _EXTENT_
    attribute c_extent                       objectExtent;
#endif
};

class v_purgeListItem {
    attribute v_dataReaderInstance           instance;
    attribute c_time                         insertionTime;
    attribute c_long                         genCount; /* generation equal or older should be removed */
};

class v_transaction {
    attribute v_gid                          writerGID;
    attribute c_ulong                        transactionId;
    attribute c_long                         count;
};

class v_dataReaderEntry extends v_entry {
    attribute v_topic                        topic;
    attribute v_index                        index;
    attribute v_filter                       filter;
    /* timed list of samples with a limited lifespan. */
    attribute v_lifespanAdmin                lifespanAdmin;
    /* Lists for garbagecollection/autopurging
     * Two lists are used because each of them is time-ordered but the
     * union of the lists is not */
    attribute LIST<v_transaction>            transactionList;
    attribute LIST<v_purgeListItem>          purgeListDisposed; /* No Writers */
    attribute LIST<v_purgeListItem>          purgeListNotEmpty; /* No Writers */
};

class v_deadLineReaderInstanceList {
    attribute v_dataReaderInstance           firstInstance;
    attribute c_voidp                        lastInstance;
};

class v_dataView extends v_collection {
    attribute SET<v_dataViewInstance>        instances;
    attribute c_voidp                        reader;
    attribute c_type                         sampleType;
    attribute v_dataViewQos                  qos;
    /* The takenInstance attribute is used for 'take' operations
       Normally the instance is destroyed after a take and the
       instance handle is expired, but an application should be
       be able to use the instance handle for a 'take_next_instance'
       operation. So we always remember the last instance taken, so
       we determine the next instance.
    */
    attribute v_dataViewInstance             takenInstance;
#ifdef _EXTENT_
    attribute c_extent                       instanceExtent;
    attribute c_extent                       sampleExtent;
#endif
};

class v_dataReader extends v_reader {
/* Attributes are protected by the observer lock! */
    attribute v_index                        index;
    attribute SET<v_dataView>                views;
    attribute v_deadLineInstanceList         deadLineList;
    attribute v_dataReaderSample             cachedSample;
#define _SL_
#ifdef _SL_
    attribute c_long                         cachedSampleCount;
#endif
    attribute c_long                         sampleCount;
    attribute c_long                         notReadCount;
    attribute c_bool                         maxInstances;
    /* Attributes maintaining the current state wrt the policies */
    attribute c_long                         depth;
    attribute c_ulong                        shareCount;
#ifdef _EXTENT_
    attribute c_extent                       sampleExtent;
#endif
    attribute v_projection                   projection;
    attribute v_dataReaderSample             triggerValue;
    attribute c_bool                         walkRequired;
    attribute c_ulong                        updateCnt;
    
    /* This Count is the read/take sequence number of the reader.
     * Any read or take operation will increment this value and mark
     * all processed samples with this value by assigning this value to
     * the samples readId attribute.
     * Any subsequent accesses to this sample during thie read action can
     * detect already processed samples and skip them.
     * (Samples can be accesses multiple times during one read or take
     * action as result of queries containing OR operations).
     */
    attribute c_ulong                        readCnt;

#ifdef _MSG_STAMP_
    attribute v_laptime                      writerCopyTime[2];
    attribute v_laptime                      writerLookupTime[2];
    attribute v_laptime                      writerWriteTime[2];
    attribute v_laptime                      groupLookupTime[2];
    attribute v_laptime                      groupWriteTime[2];
    attribute v_laptime                      readerLookupTime[2];
    attribute v_laptime                      readerInstanceTime[2];
    attribute v_laptime                      readerInsertTime[2];
    attribute v_laptime                      readerNotifyTime[2];
    attribute v_laptime                      readerReadTime[2];
    attribute v_laptime                      readerCopyTime[2];
    attribute v_laptime                      nwSerialisationTime[2];
    attribute v_laptime                      nwBufferFullTime[2];
    attribute v_laptime                      nwFlushBufferTime[2];
    attribute v_laptime                      nwSendTime[2];
    attribute v_laptime                      nwReceiveTime[2];
    attribute v_laptime                      nwInsertTime[2];
#endif
};

/* v_deliveryService is a nodal service that provides
 * a wait for delivery acknowledgements method.
 */
class v_deliveryService extends v_reader {
    attribute SET<v_subscriptionInfoTemplate> subscriptions;
    attribute SET<v_deliveryGuard> guards;
};

class v_deliveryServiceEntry extends v_entry {
    attribute v_topic topic;
};

/* -------------------------------------------------------------------------- */
/* Group stream implementation                                                */
/* -------------------------------------------------------------------------- */

enum v_groupActionKind {
    V_GROUP_ACTION_WRITE, V_GROUP_ACTION_DISPOSE,
    V_GROUP_ACTION_REGISTER, V_GROUP_ACTION_UNREGISTER,
    V_GROUP_ACTION_LIFESPAN_EXPIRE, V_GROUP_ACTION_CLEANUP_DELAY_EXPIRE,
    V_GROUP_ACTION_DELETE_DATA, V_GROUP_ACTION_DISPOSE_ALL
};

class v_groupAction extends v_object {
    attribute v_groupActionKind kind;
    attribute c_time            actionTime;
    attribute v_message         message;
    attribute v_group           group;
};

/* Abstract base class for all readers interested in all events in the group.*/
class v_groupStream extends v_reader {
    attribute SET<v_group>      groups;
};

class v_groupQueueSample {
    attribute v_groupAction action;
    attribute v_groupQueueSample next;
};

class v_groupQueue extends v_groupStream {
    attribute c_ulong            size;
    attribute c_ulong            maxSize;
    attribute v_groupQueueSample head;
    attribute v_groupQueueSample tail;
    attribute v_groupQueueSample marker;
    attribute c_bool			 markerReached;
};

/* -------------------------------------------------------------------------- */
/* Networking reader type implementation                                      */
/* -------------------------------------------------------------------------- */
typedef c_ulong v_networkId;
const v_networkId V_NETWORKID_LOCAL = 0x0;
const v_networkId V_NETWORKID_ANY = 0xffffffff;
const v_networkId V_NETWORKID_DDSI = 0xABADBABE;

typedef c_ulong v_networkPartitionId;
const v_networkPartitionId V_NETWORKPARTITIONID_LOCALHOST = 0xffffffff;

typedef struct v_networkHashValue_s {
    c_octet h1;
    c_octet h2;
    c_octet h3;
    c_octet h4;
} v_networkHashValue;

class v_networkReaderEntry extends v_entry {
    /* Hash for quick lookup by networking; */
    attribute v_networkHashValue             hashValue;
    /* Has a one-to-one relationship with group */
    attribute c_voidp                        group;
    /* ID of the network connected to this entry */
    attribute v_networkId                    networkId;
    /* Countdown until all channels have connected */
    attribute c_ulong                        channelCountdown;
    attribute c_mutex                        channelCountdownMutex;
    /* Networkpartition to send data to */
    attribute v_networkPartitionId           networkPartitionId;
};


/* New implementation of networkQueue */
class v_networkQueueSample {
    attribute v_message                      message;
    attribute v_networkReaderEntry           entry;
    attribute c_ulong                        sequenceNumber;
    attribute v_gid                          sender;
    attribute c_bool                         sendTo;
    attribute v_gid                          receiver; /* if sendTo is TRUE */
    attribute v_networkQueueSample                next;
};

class v_networkStatusMarker {
    attribute c_time                         sendBefore;
    attribute c_ulong                        priority;
    attribute v_networkQueueSample           firstSample;
    attribute c_voidp                        lastSample; /* v_networkSample */
    attribute c_mutex                        mutex;
    attribute v_networkStatusMarker          next;
};

class v_networkQueue {
    /* Qos properties for this queue */
    attribute c_ulong                        priority;
    attribute c_bool                         reliable;
    attribute c_bool                         P2P;
    /* The queue itself */
    attribute c_ulong                        maxMsgCount;
    attribute c_ulong                        currentMsgCount;
    /* List of statusmarkers in use */
    attribute v_networkStatusMarker          firstStatusMarker;
    attribute c_voidp                        lastStatusMarker; /* v_networkStatusMarker */
    /* List of free objects to avoid exhaustive mmMalloc/mmFree calls */
    attribute v_networkStatusMarker          freeStatusMarkers;
    attribute v_networkQueueSample           freeSamples;
    /* Types stored for caching, avoid resolving */
    attribute c_type                         statusMarkerType;
    attribute c_type                         sampleType;
    /* Behavioral attributes for this queue */
    attribute c_bool                         periodic;
    attribute c_bool                         triggered;
    attribute c_bool                         threadWaiting;
    attribute c_time                         resolution;
    attribute c_ulong                        msecsResolution;
    attribute c_ulong                        phaseMilliSeconds;
    attribute c_time                         nextWakeup;
    attribute c_mutex                        mutex;
    attribute c_cond                         cv;
    attribute v_networkQueueStatistics       statistics;
};

class v_networkReader extends v_reader {
    attribute c_ulong                        nofQueues;
    attribute ARRAY<v_networkQueue>          queues;
    attribute v_networkQueue                 defaultQueue;
    /* Boolean indicating if anybody is alive remotely */
    attribute c_bool                         remoteActivity;
    attribute c_bool                         ignoreReliabilityQoS; /* required re-usage of code for DDSi service */
    /* Queue cache to store bestQueue's per priority */
    attribute ARRAY<v_networkQueue>          queueCache;
};

/* -------------------------------------------------------------------------- */
/* Kernel Class implementation                                                */
/* -------------------------------------------------------------------------- */

class v_groupSet extends v_observable {
    attribute SET<v_group>                   groups;
    attribute c_lock                         lock;
    attribute c_long                         sequenceNumber;
};

typedef c_string v_statisticsCategory;

class v_builtin {
    /* built-in topics */
    attribute v_participant                  participant;
    attribute v_publisher                    publisher;
    attribute v_topic                        topics[V_INFO_ID_COUNT];
    attribute v_writer                       writers[V_INFO_ID_COUNT];
    attribute v_kernelQos                    kernelQos;
};

const c_ulong V_CRC_TABLE_SIZE = 256; /* for every possible byte value */
const c_ulong V_CRC_KEY        = 0x04c11db7; /* identical to ethernet key */

class v_crc {
    attribute c_ulong _key;
    attribute c_ulong table[V_CRC_TABLE_SIZE];
};

class v_pendingDisposeElement {
    attribute v_commandDisposeAllData disposeCmd;
    attribute c_time disposeTimestamp;
};

class v_kernel extends v_observable {
    attribute v_gid                          GID;
    attribute SET<v_participant>             participants;
    attribute SET<v_topic>                   topics;
    attribute SET<v_partition>               partitions;
    attribute v_groupSet                     groupSet;
    attribute c_type                         type[K_TYPECOUNT];
    attribute c_lock                         lock;
    attribute v_handleServer                 handleServer;
    attribute v_kernelQos                    qos;
    attribute v_serviceManager               serviceManager;
    attribute v_leaseManager                 livelinessLM;
    attribute v_deliveryService              deliveryService;
    attribute v_configuration                configuration;
    attribute c_ulong                        userCount;
    attribute c_ulong                        transactionCount;
    /* ES: dds2476: Added a boolean to indicate if the spliced is running or not
     * this boolean is set to false when it is detected by any (non-service)
     * participant that the splice deamon is not longer running. 
     * Once set to false the u_entityClaim functions will no longer work as those
     * check this boolean
     */
    attribute c_bool                        splicedRunning;
    /* ES: dds2235: added warning levels for resource limits
     * whenever the value is exceed a warning message will be printed.
     * To ensure the log files are not flooded by warning messages
     * a boolean is maintained to ensure a warning is only printed once
     */
    attribute c_ulong                        maxSamplesWarnLevel;
    attribute c_bool                         maxSamplesWarnShown;
    attribute c_ulong                        maxSamplesPerInstanceWarnLevel;
    attribute c_bool                         maxSamplesPerInstanceWarnShown;
    attribute c_ulong                        maxInstancesWarnLevel;
    attribute c_bool                         maxInstancesWarnShown;

    attribute v_builtin                      builtin;

    /* Set of enabled statistics categories */
    attribute SET<v_statisticsCategory>      enabledStatisticsCategories;

    /* List of dispose alls pending for groups not yet seen */
    attribute LIST<v_pendingDisposeElement>  pendingDisposeList;
    attribute c_mutex                        pendingDisposeListMutex;

    /* Set of shared entities */
    attribute c_mutex                        sharesMutex;
    attribute SET<v_entity>                  shares;

    attribute v_crc                          crc;
};

/* -------------------------------------------------------------------------- */
/* Kernel management implementation                                           */
/* -------------------------------------------------------------------------- */

const string V_SPLICED_NAME = "splicedaemon";

class v_spliced extends v_service {
    attribute v_subscriber    builtinSubscriber;
    attribute v_dataReader    readers[V_INFO_ID_COUNT];
    attribute SET<v_message>  builtinData[V_INFO_ID_COUNT];
    attribute v_heartbeatInfo hb;       /* the heartbeat data */
    attribute v_lease         hbUpdate; /* lease for periodically writing heartbeat */
    attribute v_lease         hbCheck;  /* lease for next check on heartbeats */
    attribute v_waitset       ws;
    attribute c_bool          quit;
    attribute c_bool          cAndMCommandDispatcherQuit;
    attribute v_waitset       cAndMCommandWaitSet;

    attribute c_mutex         mtx;
    attribute c_mutex         cAndMCommandMutex;
    attribute c_mutex         builtinDataMutex;
    attribute SET<v_message>  missedHB; /* c_table missedHB<v_message> */
};

};
