<?xml version="1.0" encoding="UTF-8"?>
<splice_meta_config version="1.0">
  <!--xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.splice-dds.org/splice_metaconfig.xsd"-->
  <rootElement name="OpenSplice" minOccurrences="1" maxOccurrences="1">
    <comment><![CDATA[
            <p>OpenSplice utilizes a shared-memory architecture where data is physically
            present only once on any machine and where smart administration still
            provides each subscriber with his own private view on this data. This
            allows a subscribers data cache to be perceived as an individual
            database that can content-filtered, queried, etc. (using the
            content-subscription profile as supported by OpenSplice). This
            shared-memory architecture results in an extremely low footprint,
            excellent scalability and optimal performance when compared to
            implementations where each reader/writer are communication-end points
            each with its own storage (i.e. historical data both at reader and
            writer) and where the data itself still has to be moved, even within
            the same platform.</p>

            <p>Shared-memory is not only used to interconnect all applications that
            reside within one computing node, but also for a configurable and
            extensible set of services. These services provide pluggable functionality
            such as networking (providing QoS-driven real-time networking based
            on multiple reliable multicast 'channels'), durability (providing
            fault-tolerant storage for both real-time state data as well as
            persistent settings) and a remote control & monitoring soap-service
            (providing remote web-based access using the SOAP protocol from the
            OpenSplice Tuner tool).</p>

            <p>Because of the pluggable architecture, the OpenSplice middleware
            can be easily configured on the fly by specifying which services to
            be used as well as specifying their optimal configuration for the
            application domain (networking parameters, durability levels, etc.).
            Typically, there are many nodes within a system.</p>

            <p>The OpenSplice middleware including its services can be configured
            by means of easy maintainable XML-file(s).</p>
        ]]></comment>
  </rootElement>
  <element name="Domain" minOccurrences="1" maxOccurrences="1">
    <comment><![CDATA[
            <p>The Domain service is responsible for creating and initialising a shared nodal administration(in shared memory)
            for a specific DDS Domain on a computing node. Without this administration, no other service or application is able
            to participate in a DDS Domain.</p>

            <p>Once the administration has been initialised, the Domain service starts the set of pluggable services. The
            lifecycle of the started services is under control of the Domain service, which means it will monitor the health
            of all started services, take corrective actions if needed and stop the services when it is terminated.</p>

            <p>When a shutdown of the OpenSplice Domain service is requested, it will react by announcing the shutdown using the
            shared administration. Applications will not be able to use DDS functionality anymore and services are requested
            to terminate elegantly. Once this has succeeded, the Domain service will destroy the shared administration and
            finally terminate itself.</p>
        ]]></comment>
    <leafString name="Name" minOccurrences="1" maxOccurrences="1">
      <comment><![CDATA[
                    This element specifies the name of the instantiated DDS domain. In general, it is recommended to change
                    this name to a name that identifies the domain. If several different DDS domains are required to run
                    simultaneously, then they all need to have their own domain name.
            ]]></comment>
      <maxLength>0</maxLength>
      <default>OpenSpliceV5</default>
    </leafString>
    <leafString name="Role" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                This (optional) element specifies the role of the instantiated domain. For dynamic discovery, this role will
                be used to define the communication scope of instantiated domains on other nodes in the system. The purpose
                of specifying roles within the system is to 'overlay' the underlying physical network with a node's scope-of-interest
                that allows to bound topology discovery effort and related overhead in large scale (WAN) systems.
            ]]></comment>
      <maxLength>0</maxLength>
      <default>DefaultRole</default>
    </leafString>
    <element name="Lease" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                    The Lease parameters specify how the Domain service as well as the services started by the
                    Domain service must announce their liveliness in the shared administration.
            ]]></comment>
      <leafFloat name="ExpiryTime" minOccurrences="1" maxOccurrences="1">
        <comment><![CDATA[
                    <p>This element specifies the interval in which services have to announce their liveliness.</p>
                    <p>Every OpenSplice service including the Domain service itself has to announce its liveliness regularly.
                    This allows corrective actions to be taken when one of the services becomes non-responsive. This
                    element specifies the required interval. Decreasing the interval decreases the time in which
                    non-responsiveness of a service is detected, but leads to more processing. Increasing it has
                    the opposite effect.</p>
                ]]></comment>
        <default>10.0</default>
        <minimum>0.2</minimum>
        <attributeFloat name="update_factor" required="true">
          <comment><![CDATA[
                        In case of a (temporary) high CPU load, the scheduling behaviour of the operating system might
                        affect the capability of a service to assert its liveliness 'on time'. The <i>update_factor</i> attribute
                        introduces some elasticity in this mechanism by making the services assert their liveliness more
                        often than required by the <i>ExpiryTime</i>. Services will report their liveliness every
                        <i>ExpiryTime</i> multiplied by this <i>update_factor</i>.
                    ]]></comment>
                    <minimum>0.01</minimum>
                    <maximum>1.0</maximum>
                    <default>0.2</default>
                </attributeFloat>
            </leafFloat>
        </element>
        <element name="Watchdog" minOccurrences="0" maxOccurrences="1">
               <comment><![CDATA[
                This element controls the characteristics of the Watchdog thread.
            ]]></comment>
            <element name="Scheduling" minOccurrences="1" maxOccurrences="1">
                <comment><![CDATA[
                    This element specifies the type of OS scheduling class will be
                    used by the thread that announces its liveliness periodically.
                ]]></comment>
                <leafInt name="Priority" minOccurrences="1" maxOccurrences="1">
                    <comment><![CDATA[
                        This element specifies the thread priority that will be used by the
                        watchdog thread. Only priorities that are supported by the
                        underlying operating system can be assigned to this element.
                        The user may need special privileges from the underlying operating
                        system to be able to assign some of the privileged priorities.
                    ]]></comment>
                    <default>0</default>
                </leafInt>
                <leafEnum name="Class" minOccurrences="1" maxOccurrences="1">
                    <comment><![CDATA[
                        This element specifies the thread scheduling class that will be used by
                        the watchdog thread. The user may need the appropriate privileges from
                        the underlying operating system to be able to assign some of the
                        privileged scheduling classes.
                    ]]></comment>
                    <value>Timeshare</value>
                    <value>Realtime</value>
                    <value>Default</value>
                    <default>Default</default>
                </leafEnum>
            </element>
        </element>
        <leafFloat name="ServiceTerminatePeriod" minOccurrences="0" maxOccurrences="1">
            <comment><![CDATA[
                This element specifies the amount of time the Domain Service,
                when instructed to terminate, should wait for the other configured
                Services to terminate. When this element is configured to '0' the
                Domain service will terminate without any wait time at all. Be
                aware that without any wait time the deamon will use a hard kill
                on any lingering service that can not terminate fast enough.
                This may prevent graceful termination and thus leave applications
                that are still attached to the DDS domain in an undefined state.
                Consequently the '0' value should only be used when there is
                some form of process management on top of OpenSplice DDS.
            ]]></comment>
      <minimum>0.0</minimum>
      <maximum>60.0</maximum>
      <default>10.0</default>
    </leafFloat>
    <leafBoolean name="SingleProcess" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                    <p>This element specifies whether the OpenSplice Domain and other OpenSplice
                      services and applications are intended to be all deployed within the same
                      process.  The default is to start each service in a seperate new process,
                      but it is an optimisation under certain conditions to be able to have all
                      OpenSplice components running in the same process.</p>
                    <p>Refer to the OpenSplice documentation for more details of how this deployment
                       style can optimise your system.</p>
                    <p>There are two modes of a "Single Process" style deployment:</p>
                    <p><b>Mode 1</b> : the user starts an application as a new process.  In this
                      case, the create_participant operation will implicitly start the OpenSplice
                      daemon as a thread in the existing application process.  The OpenSplice daemon
                      thread will then also implicitly start all services (and other applications)
                      specified in the configuration as threads within the same process.</p>
                    <p><b>Mode 2</b> : "ospl start" is ran as normal, in which case the OpenSplice
                      daemon will be started as a new process but will start all services (and other
                      applications) specified in the configuration as threads within the same process.</p>
                    <p>Please note that the Application elements specified under Domain will only
                      take effect for either mode when this SingleProcess attribute has a value
                      of true.</p>
                    <p>Please note also that the choice to use the SingleProcess deployment also
                      implies the use of heap memory for the OpenSplice database management rather
                      than shared memory that is typically used for this purpose.  Heap memory is
                      limited by the Operating System, so the Database element under Domain does
                      not take effect when SingleProcess has a value of true.</p>
                ]]></comment>
      <default>false</default>
    </leafBoolean>
    <element name="Daemon" minOccurrences="0" maxOccurrences="1">
    <comment><![CDATA[
            Every domain is controlled by exactly one daemon: the Splice Daemon.
            The Splice Daemon configuration expects a root element named
            <i>OpenSplice/Daemon</i>. Within this root element, the Splice Daemon will
            look for several child-elements. Each of these child elements is
            listed and explained.
        ]]></comment>
    <leafBoolean name="Locking" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                <p>This element specifies the locking policy for the Splice Deamon
                process, indicating whether its pages should be locked in physical
                memory or not.</p>
                On platforms with a virtual memory architecture, the operating
                system decides when to swap memory pages from internal memory to disk.
                This results in execution delays for the corresponding code because it
                has to be paged back into main memory. The element <i>Locking</i> can be
                used to avoid such swapping for the Splice Deamon. The user needs the
                appropriate privileges from the underlying operating system to be able
                to use this option.
            ]]></comment>
      <default>false</default>
    </leafBoolean>
    <element name="KernelManager" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                 <p>This element specifies the behaviour of the KernelManager.</p>
                 <p>The kernel manager actively monitors the OpenSplice kernel
                 and executes administrative tasks:</p>
                 <ul>
                   <li>check topic consistency</li>
                   <li>determine liveliness status of readers and writers</li>
                   <li>notify readers and writers on incompatible QoS</li>
                 </ul>
            ]]></comment>
      <element name="Scheduling" minOccurrences="1" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies the scheduling policies used to control
                    the KernelManager thread.
                ]]></comment>
        <leafInt name="Priority" minOccurrences="1" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the thread priority that will be used by the
                        KernelManager thread. Only priorities that are supported by the
                        underlying operating system can be assigned to this element.
                        The user may need special privileges from the underlying operating
                        system to be able to assign some of the privileged priorities.
                    ]]></comment>
          <default>0</default>
          <attributeEnum name="priority_kind" required="false">
            <comment><![CDATA[
                            This attribute specifies whether the specified
                            Priority is a relative or absolute priority.
                        ]]></comment>
            <value>Relative</value>
            <value>Absolute</value>
            <default>Relative</default>
          </attributeEnum>
        </leafInt>
        <leafEnum name="Class" minOccurrences="1" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the thread scheduling class that will be
                        used by the KernelManager thread. The user may need the appropriate
                        privileges from the underlying operating system to be able to
                        assign some of the privileged scheduling classes.
                    ]]></comment>
          <value>Timeshare</value>
          <value>Realtime</value>
          <value>Default</value>
          <default>Default</default>
        </leafEnum>
      </element>
    </element>
    <element name="GarbageCollector" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                <p>This element specifies the behaviour of the GarbageCollector.</p>
                <p>The garbage collector is a safety mechanism and is responsible for
                reclaiming resources in case an application or remote node does not
                terminate properly.</p>
            ]]></comment>
      <element name="Scheduling" minOccurrences="1" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies the scheduling policies used to control the
                    GarbageCollector thread.
                ]]></comment>
        <leafInt name="Priority" minOccurrences="1" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the thread priority that will be used by
                        the GarbageCollector thread. Only priorities that are supported
                        by the underlying operating system can be assigned to this element.
                        The user may need special privileges from the underlying operating
                        system to be able to assign some of the privileged priorities.
                    ]]></comment>
          <default>0</default>
          <attributeEnum name="priority_kind" required="false">
            <comment><![CDATA[
                            This attribute specifies whether the specified
                            Priority is a relative or absolute priority.
                        ]]></comment>
            <value>Relative</value>
            <value>Absolute</value>
            <default>Relative</default>
          </attributeEnum>
        </leafInt>
        <leafEnum name="Class" minOccurrences="1" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the thread scheduling class that will be
                        used by the GarbageCollector thread. The user may need the
                        appropriate privileges from the underlying operating system to
                        be able to assign some of the privileged scheduling classes.
                    ]]></comment>
          <value>Timeshare</value>
          <value>Realtime</value>
          <value>Default</value>
          <default>Default</default>
        </leafEnum>
      </element>
    </element>
    <element name="ResendManager" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                This element controls the characteristics of the ResendManager thread.
            ]]></comment>
      <element name="Scheduling" minOccurrences="1" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies the type of OS scheduling class used by
                    the thread that does local resends for the builtin participant.
                ]]></comment>
        <leafInt name="Priority" minOccurrences="1" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the thread priority that will be used by the
                        ResendManager thread. Only priorities that are supported by the
                        underlying operating system can be assigned to this element.
                        The user may need special privileges from the underlying operating
                        system to be able to assign some of the privileged priorities.
                    ]]></comment>
          <default>0</default>
          <attributeEnum name="priority_kind" required="false">
            <comment><![CDATA[
                            This attribute specifies whether the specified
                            Priority is a relative or absolute priority.
                        ]]></comment>
            <value>Relative</value>
            <value>Absolute</value>
            <default>Relative</default>
          </attributeEnum>
        </leafInt>
        <leafEnum name="Class" minOccurrences="1" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the thread scheduling class that will be used by
                        the ResendManager thread. The user may need the appropriate privileges from
                        the underlying operating system to be able to assign some of the
                        privileged scheduling classes.
                    ]]></comment>
          <value>Timeshare</value>
          <value>Realtime</value>
          <value>Default</value>
          <default>Default</default>
        </leafEnum>
      </element>
    </element>
  </element>
    <element name="Database" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                    This element contains information about the nodal administration (shared memory) to be used.
            ]]></comment>
      <leafSize name="Size" minOccurrences="1" maxOccurrences="1">
        <comment><![CDATA[
                        This element specifies the size of the shared memory segment holding the database. Change
                        this value if your system requires more memory than the default. Please note that the
                        operating system should be configured support the requested size. On most platforms you need
                        'root' privileges to set large sizes.
                ]]></comment>
        <minimum>0</minimum>
        <default>10485760</default>
      </leafSize>
      <leafSize name="Threshold" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                        This element specifies the threshold size used by OpenSplice DDS. Whenever there is less
                        free shared memory then indicated by the threshold then no new allocations will be allowed
                        within shared memory. Services are allowed to continue allocating shared memory until less then
                        50% of the threshold value is available. It is strongly discouraged to configure a threshold
                        value of less then the default value, but for some embedded systems it might be needed as
                        only limited memory is available.
                ]]></comment>
        <minimum>0</minimum>
        <default>1048576</default>
      </leafSize>
      <leafString name="Address" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    <p>This element specifies the start address where the
                    nodal shared administration is mapped into the virtual
                    memory for each process that attaches to the current Domain.
                    The possible values are platform dependent.</p>
                    <p>Change this value if the default address is already in
                    use, for example by another Domain Service or another
                    product.</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <minimum>0x40000000</minimum>
        <maximum>0x80000000</maximum>
        <default>0x40000000</default>
      </leafString>
      <leafEnum name="Locking" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    <p>This element specifies the locking policy of the Database, indicating
                    whether to lock pages in physical memory or not.</p>
                    <p>With the virtual memory architecture, the operating system decides when
                    to swap memory pages from internal memory to disc. This results in execution
                    delays for the corresponding code because it has to be paged back into main
                    memory. The element <i>Locking</i> can be used to avoid such swapping for the
                    shared memory where the database resides. The user needs the appropriate
                    privileges from the underlying operating system to be able to use this option.</p>
                    <p>The possible values are:</p>
                    <ul>
                    <li><b>True</b>: lock the pages in memory.</li>
                    <li><b>False</b>: don't lock the pages in memory.</li>
                    <li><b>Default</b>: use the platform-dependent default value.</li>
                    </ul>
                ]]></comment>
        <value>True</value>
        <value>False</value>
        <value>Default</value>
        <default>Default</default>
      </leafEnum>
    </element>
    <element name="Listeners" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                    This element specifies policies for the thread that services the listeners that
                    the application specifies on the API-level.
            ]]></comment>
            <leafSize name="StackSize" minOccurrences="1" maxOccurrences="1">
                <comment><![CDATA[
                        This element specifies the stack size of the listener thread.
                ]]></comment>
                <minimum>64000</minimum>
                <default>64000</default>
            </leafSize>
        </element>
        <element name="Service" minOccurrences="0" maxOccurrences="0">
            <comment><![CDATA[
                The Domain service is responsible for starting, monitoring and stopping the pluggable services.
                One Service element must be specified for every service that needs to be started by the Domain service.
            ]]></comment>
      <attributeString name="name" required="true">
        <comment><![CDATA[
                    <p>This attribute specifies the name by which the corresponding service is
                    identified in the rest of the configuration file.</p>
                    <p>In the OpenSplice DDS configuration file, services and their settings
                    are identified by a name. When the Domain Service starts a particular
                    service, its corresponding name is passed. The service in question uses
                    this name in order to find its own configuration settings in the rest of
                    the configuration file. The name specified here must match the name
                    attribute of the main element of the corresponding service.</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default>durability</default>
      </attributeString>
      <attributeBoolean name="enabled" required="false">
        <comment><![CDATA[
                    <p>This attribute indicates whether the service is actually started or not.</p>
                    <p>Toggling a service between enabled and disabled is a quick alternative for
                    commenting out the corresponding lines in the configuration file.</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default>true</default>
      </attributeBoolean>
      <leafString name="Command" minOccurrences="1" maxOccurrences="1">
        <comment><![CDATA[
                    <p>This element specifies the command to be executed in order to start the service.</p>
                    <p>OpenSplice DDS comes with a set of pluggable services. The Command element specifies
                    the name of the actual service executable (possibly including its path, but always
                    including its extension, e.g. ‘.exe’ on the Windows platform). When no path is included,
                    the Domain Service will search the <i>PATH</i> environment variable for the corresponding
                    executable. Once located, it will be started as a separate process.</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default>durability</default>
      </leafString>
      <leafString name="MemoryPoolSize" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    <p>CAUTION: GHS INTEGRITY ONLY OPTION!! This element maps directly into the integrate file
                    for the address space for this service. Consult the GHS Integrate documentation for
                    further information on this setting. Valid values are decimal or hexadecimal numbers and
                    they express the number of bytes.</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default>0</default>
      </leafString>
      <leafString name="HeapSize" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    <p><b>CAUTION</b>: This element should only be used on the GHS Integrity platform!!</p>
                    <p>This element maps directly into the integrate file
                    for the address space for this service. Consult the GHS Integrate documentation for
                    further information on this setting. Valid values are decimal or hexadecimal numbers and
                    they express the number of bytes.</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default>0</default>
      </leafString>
      <leafString name="StackSize" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    <p>CAUTION: GHS INTEGRITY ONLY OPTION!! This element maps directly into the integrate file
                    for the address space for this service. Consult the GHS Integrate documentation for
                    further information on this setting. Valid values are decimal or hexadecimal numbers and
                    they express the number of bytes.</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default>0</default>
      </leafString>
      <leafString name="Configuration" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    <p>This element allows overriding of the default URI (specified in the
                    <i>OSPL_URI</i> environment variable, or passed explicitly as command-
                    line parameter to the <i>ospl</i> executable) with the configuration
                    resource specified here.</p>
                    <p>When the Domain Service is started by the <i>ospl</i> executbale,
                    by default it passes on its own URI to the services that it starts.
                    This is valid when the configuration of the service is located in the
                    same resource file as the configuration of the Domain Service itself.
                    (This is a convenient situation in most cases).</p>
                    <p>If the configuration of the current service is located in a separate
                    resource file, a separate URI identifying that particular resource file
                    must be specified in this element.</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default>${OSPL_URI}</default>
      </leafString>
      <element name="Scheduling" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies the type of OS scheduling class will be
                    used by the Domain service to create the service process. Services
                    can only be started within the scheduling classes that are
                    supported by the underlying operating system.
                ]]></comment>
        <leafInt name="Priority" minOccurrences="1" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the thread priority that the Domain Service will
                        assign to the current Service when it is started. Only priorities that
                        are supported by the underlying operating system can be assigned to this
                        element. The user may need special privileges from the underlying
                        operating system to be able to assign some of the privileged priorities.
                    ]]></comment>
          <default>0</default>
          <attributeEnum name="priority_kind" required="false">
            <comment><![CDATA[
                            This attribute specifies whether the specified Priority is a relative
                            or absolute priority.
                        ]]></comment>
            <value>Relative</value>
            <value>Absolute</value>
            <default>Relative</default>
          </attributeEnum>
        </leafInt>
        <leafEnum name="Class" minOccurrences="1" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the thread scheduling class that the Domain
                        Service will assign to the current Service when it is started.
                        The user may need the appropriate privileges from the underlying
                        operating system to be able to assign some of the privileged
                        scheduling classes.
                    ]]></comment>
          <value>Timeshare</value>
          <value>Realtime</value>
          <value>Default</value>
          <default>Default</default>
        </leafEnum>
      </element>
      <leafBoolean name="Locking" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    <p>This element specifies the locking policy of the current Service
                    process, indicating whether pages should be locked in physical memory
                    or not.</p>
                    <p>On platforms with a virtual memory architecture, the operating
                    system decides when to swap memory pages from internal memory to disk.
                    This results in execution delays for the corresponding code because it
                    has to be paged back into main memory. The element <i>Locking</i> can be
                    used to avoid such swapping for the current Service. The user needs the
                    appropriate privileges from the underlying operating system to be able
                    to use this option.</p>
                ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafEnum name="FailureAction" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    <p>This element specifies what action to take at the moment that the service seems
                    to have become non-responsive.</p>
                    <p>Each service reports its liveliness regularly using the shared administration.
                    If the service fails to do so, the Domain service will assume the service has
                    become non-responsive. This element determines what action is taken
                    by the DomainService in case this happens.</p>
                    <p>The following actions are available:</p>
                    <ul>
                        <li><b>skip</b>: Ignore the non-responsiveness and continue.</li>
                        <li><b>kill</b>: End the service process by force.</li>
                        <li><b>restart</b>: End the service process by force and restart it.</li>
                        <li><b>systemhalt</b>:  End all OpenSplice services including the Domain service
                        (for the current DDS Domain on this computing node).</li>
                    </ul>
                ]]></comment>
        <value>kill</value>
        <value>restart</value>
        <value>skip</value>
        <value>systemhalt</value>
        <default>skip</default>
      </leafEnum>
    </element>
    <element name="Application" minOccurrences="0" maxOccurrences="0">
      <comment><![CDATA[
                <p>The Domain service can deploy DDS applications by dynamically loading application
                shared libraries and starting threads within the existing process.</p>
                <p><b>Note that Applications only take affect when the SingleProcess configuration
                 is enabled</b></p>
            ]]></comment>
      <attributeString name="name" required="true">
        <comment><![CDATA[
                    <p>The name uniquely identifies the application</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default>application1</default>
      </attributeString>
      <attributeBoolean name="enabled" required="false">
        <comment><![CDATA[
                    <p>This attribute indicates whether the application is actually started or not.</p>
                    <p>Toggling an applicatione between enabled and disabled is a quick alternative for
                    commenting out the corresponding lines in the configuration file.</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default>true</default>
      </attributeBoolean>
      <leafString name="Command" minOccurrences="1" maxOccurrences="1">
        <comment><![CDATA[
                    <p>Command is the name of both the entry point function to invoked and the name of the
                    shared library to be dynamically loaded into the process.  The signature of the entry
                    point function is the same as argc/argv usually seen with main.</p>
                    <p>For example, if Command is "HelloWorld", OpenSpliceDDS will attempt to load
                    "libHelloWorld.so" on Unix (or "HelloWorld.dll" on Windows) into the existing process
                    and then  invoke the "HelloWorld" entry point to start that DDS application.</p>
                    <p>If the name of the shared library does not have the same name as the entry point the
                    user is able to override the name of the library by using the Application's Library attribute</p>
                    <p>The shared library is located by way of the current working directory, or LD_LIBRARY_PATH
                    for Unix systems, and PATH for Windows systems.</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default>application1</default>
      </leafString>
      <leafString name="Arguments" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    <p>This optional attribute allows the user to specify arguments to be passed to the
                    DDS application's entry point when it is invoked.</p>
                    <p>For example, if Command is "HelloWorld" and Arguments is "arg1 arg2", OpenSplice will
                    invoke the HelloWorld function with the argc = 3 and argv = {"HelloWorld", "arg1", "arg2"}</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default></default>
      </leafString>
      <leafString name="Library" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    <p>The optional Library attribute allows the user to override the name of the shared
                    library if it is different to the name of the entry point specified by Command.</p>
                    <p>The shared library is located by way of the current working directory, or LD_LIBRARY_PATH
                    for Unix systems, and PATH for Windows systems.</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default>application1</default>
      </leafString>
    </element>
    <element name="BuiltinTopics" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
            This element specifies the granularity of the builtin topics.
            ]]></comment>
      <attributeBoolean name="enabled" required="true">
        <comment><![CDATA[
                This attribute enables or disables the publication of builtin topics
                for the existence of individual Participants/DataWriters/DataReaders.
                The existence of Topics will always be communicated by means of builtin
                topics, regardless of the value specified here.
                ]]></comment>
        <default>true</default>
      </attributeBoolean>
    </element>
    <element name="PriorityInheritance" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
            This element specifies the usage on Priority Inheritance on Muexes in this domain.
            ]]></comment>
      <attributeBoolean name="enabled" required="true">
        <comment><![CDATA[
                This attribute enables or disables priority inheritance for mutexes,
                if that is supported by the underlying Operating System.
                ]]></comment>
        <default>true</default>
      </attributeBoolean>
    </element>
    <element name="Statistics" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
            This element specifies the policies regarding statistics. Various statistics
            can be generated by OpenSplice DDS to help you analyze and tune application
            behaviour during application development.  Since this introduces extra overhead,
            it is generally turned off in a runtime system.
            ]]></comment>
      <element name="Category" minOccurrences="0" maxOccurrences="0">
        <comment><![CDATA[
                    This element specifies the properties for a particular category of statistics.
                ]]></comment>
        <attributeBoolean name="enabled" required="false">
          <comment><![CDATA[
                        This attribute enables or disables the generation of statistics for the
                        specified category.
                    ]]></comment>
          <default>true</default>
        </attributeBoolean>
        <attributeEnum name="name" required="true">
          <comment><![CDATA[
                        This attribute specifies the name of a particular category of statistics.
                    ]]></comment>
          <value>durability</value>
          <value>reader</value>
          <value>writer</value>
          <value>networking</value>
          <default>reader</default>
        </attributeEnum>
      </element>
    </element>
    <element name="ReportPlugin" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
            This Tag specifies user defined report functionality to be used by
            the domain. All services and applications will load a user provides
            report library that will implement the report plugin interface.
            The report interface consists of three operations;
            initialize, report and finalize.
        ]]></comment>
      <element name="Library" minOccurrences="1" maxOccurrences="1">
        <comment><![CDATA[
                This tag specifies the library to be loaded.
            ]]></comment>
        <attributeString name="file_name" required="true">
          <comment><![CDATA[
                    This attribute specifies the library to be loaded.
                ]]></comment>
          <default/>
          <maxLength>0</maxLength>
        </attributeString>
      </element>
      <element name="Initialize" minOccurrences="1" maxOccurrences="1">
        <comment><![CDATA[
                This tag specifies the library symbol that will be assigned to the
                report Initialize operation. This operation will be invoked
                initially after loading the library to perform initialization of
                the report facility if needed.
            ]]></comment>
        <attributeString name="symbol_name" required="true">
          <comment><![CDATA[
                    This attribute specifies the library symbol that will be
                    assigned to the report Initialize operation. This operation
                    will be invoked initially after loading the library to
                    perform initialization of the report facility if needed.
                ]]></comment>
          <default/>
          <maxLength>0</maxLength>
        </attributeString>
        <attributeString name="argument" required="false">
          <comment><![CDATA[
                    This attribute is a string value that is passed to the function
                    specified by the symbol_name.  The string value has no meaning
                    to the service and is used to pass any context-specific
                    information that may be required.
                ]]></comment>
          <default/>
          <maxLength>0</maxLength>
        </attributeString>
      </element>
      <element name="Report" minOccurrences="1" maxOccurrences="1">
        <comment><![CDATA[
                This tag specifies the library symbol that will be assigned to
                the report Report operation. This operation will be invoked
                on all reports performed by the DDS service.
            ]]></comment>
        <attributeString name="symbol_name" required="true">
          <comment><![CDATA[
                    This attribute specifies the library symbol that will be
                    assigned to the report Report operation. This operation will
                    be invoked on all reports performed by the DDS service.
                ]]></comment>
          <default/>
          <maxLength>0</maxLength>
        </attributeString>
      </element>
      <element name="Finalize" minOccurrences="1" maxOccurrences="1">
        <comment><![CDATA[
                This tag specifies the library symbol that will be assigned
                to the report Finalize operation. This operation will be
                invoked upon process termination to perform de-initialization
                of the report facility if needed.
            ]]></comment>
        <attributeString name="symbol_name" required="true">
          <comment><![CDATA[
                    This attribute specifies the library symbol that will be assigned
                    to the report Finalize operation. This operation will be
                    invoked upon process termination to perform de-initialization
                    of the report facility if needed.
                ]]></comment>
          <default/>
          <maxLength>0</maxLength>
        </attributeString>
      </element>
      <leafBoolean name="SuppressDefaultLogs" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
            This attribute specifies whether the default error and info
            report logs are to be produced when a user Report Plugin has
            been defined.  If registration of the Report Plugin fails the
            default error and info logs will not be suppressed regardless of
            the value of this attribute
            ]]></comment>
        <default>false</default>
      </leafBoolean>
    </element>
    <element name="ResourceLimits" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
            This configuration tag allows for the specification of certain
            characteristics of resource limits that will be applied throughout
            the domain
        ]]></comment>
      <element name="MaxSamples" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                This configuration tag allows for the specification of certain
                characteristics of the max samples resource limit that will
                be applied throughout the domain
            ]]></comment>
        <leafLong name="WarnAt" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the number of samples that, once
                        reached, will result in a warning message printed in
                        the info log. This is to allow the detection of excessive
                        use of resources within the domain more easily.
                ]]></comment>
          <minimum>1</minimum>
          <default>5000</default>
        </leafLong>
      </element>
      <element name="MaxInstances" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                This configuration tag allows for the specification of certain
                characteristics of the max instances resource limit that will
                be applied throughout the domain
            ]]></comment>
        <leafLong name="WarnAt" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the number of instances that, once
                        reached, will result in a warning message printed in
                        the info log. This is to allow the detection of excessive
                        use of resources within the domain more easily.
                ]]></comment>
          <minimum>1</minimum>
          <default>5000</default>
        </leafLong>
      </element>
      <element name="MaxSamplesPerInstance" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                This configuration tag allows for the specification of certain
                characteristics of the max samples per instance resource limit
                that will be applied throughout the domain
            ]]></comment>
        <leafLong name="WarnAt" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the number of samples per
                        instance that, once reached, will result in a warning
                        message printed in the info log. This is to allow the
                        detection of excessive use of resources within the
                        domain more easily.
                ]]></comment>
          <minimum>1</minimum>
          <default>5000</default>
        </leafLong>
      </element>
    </element>
    <element name="PartitionAccess" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
            This configuration tag specifies the access rights for a
            selection of partitions.
        ]]></comment>
      <attributeString name="partition_expression" required="true">
        <comment><![CDATA[
                This attribute specifies the partitions by name.
                The wildcards ‘*’ and ‘?’ are allowed and the specified
                access rights will be applied to all matching partitions.
                In case partitions match multiple rules the rules will be
                applied in sequence of declaration.
            ]]></comment>
        <default>*</default>
        <maxLength>0</maxLength>
      </attributeString>
      <attributeEnum name="access_mode" required="true">
        <comment><![CDATA[
                This attribute specifies the access rights that will be
                applied to the specified partitions. The following values
                are applicable:
                <ul>
                    <li>none</li>
                    <li>read</li>
                    <li>write</li>
                    <li>readwrite</li>
                </ul>
            ]]></comment>
        <value>none</value>
        <value>read</value>
        <value>write</value>
        <value>readwrite</value>
        <default>readwrite</default>
      </attributeEnum>
    </element>
    <element name="TopicAccess" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
            This configuration tag specifies the access rights for a
            selection of topics.
        ]]></comment>
      <attributeString name="topic_expression" required="true">
        <comment><![CDATA[
                This attribute specifies the topics by name.
                The wildcards ‘*’ and ‘?’ are allowed and the specified
                access rights will be applied to all matching topics.
                In case topics match multiple rules the rules will be
                applied in sequence of declaration.
            ]]></comment>
        <default>*</default>
        <maxLength>0</maxLength>
      </attributeString>
      <attributeEnum name="access_mode" required="true">
        <comment><![CDATA[
                This attribute specifies the access rights that will be
                applied to the specified topics. The following values
                are applicable:
                <ul>
                    <li>none</li>
                    <li>read</li>
                    <li>write</li>
                    <li>readwrite</li>
                </ul>
            ]]></comment>
        <value>none</value>
        <value>read</value>
        <value>write</value>
        <value>readwrite</value>
        <default>readwrite</default>
      </attributeEnum>
    </element>
  </element>

  <element name="DurabilityService" minOccurrences="0" maxOccurrences="1">
    <comment><![CDATA[
            The responsibilities of the durability service are to realize the
            durable properties of data in an OpenSplice system.
        ]]></comment>
    <attributeString name="name" required="true">
      <comment><![CDATA[
                This attribute identifies the configuration for the Durability service.
                Multiple Durability service configurations can be specified in one single
                resource. The actual applicable configuration is determined by the value
                of the name attribute, which must match the one specified under the
                <i>OpenSplice/Domain/Service[@name]</i> in the configuration of
                the DomainService.
            ]]></comment>
      <maxLength>0</maxLength>
      <default>durability</default>
    </attributeString>
    <element name="Watchdog" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                This element controls the characteristics of the Watchdog thread.
            ]]></comment>
      <element name="Scheduling" minOccurrences="1" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies the type of OS scheduling class will be
                    used by the thread that announces its liveliness periodically.
                ]]></comment>
        <leafInt name="Priority" minOccurrences="1" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the thread priority that will be used by the
                        watchdog thread. Only priorities that are supported by the
                        underlying operating system can be assigned to this element.
                        The user may need special privileges from the underlying operating
                        system to be able to assign some of the privileged priorities.
                    ]]></comment>
          <default>0</default>
          <attributeEnum name="priority_kind" required="false">
            <comment><![CDATA[
                            This attribute specifies whether the specified
                            Priority is a relative or absolute priority.
                        ]]></comment>
            <value>Relative</value>
            <value>Absolute</value>
            <default>Relative</default>
          </attributeEnum>
        </leafInt>
        <leafEnum name="Class" minOccurrences="1" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the thread scheduling class that will be used by
                        the watchdog thread. The user may need the appropriate privileges from
                        the underlying operating system to be able to assign some of the
                        privileged scheduling classes.
                    ]]></comment>
          <value>Timeshare</value>
          <value>Realtime</value>
          <value>Default</value>
          <default>Default</default>
        </leafEnum>
      </element>
    </element>
    <element name="Network" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                    <p>Applications need to be able to gain access to historical data in a system.
                    When the local DDS service gets connected to a remote DDS service by means
                    of the Networking service, (parts of) the historical data might not be
                    consistent between the local and remote Durability services. The Durability
                    service needs to be able to detect the other available Durability services
                    and exchange historical data with them to keep and/or restore consistency
                    in historical data between them.</p>

                    <p>The Network element provides handles to fine-tune the behavior of the
                    communication between Durability services on different computing nodes on
                    network level. These settings only apply when the Networking service is active.</p>
            ]]></comment>
      <attributeFloat name="latency_budget" required="false">
        <comment><![CDATA[
                    <p>This attribute controls the latency_budget QoS setting
                    that is used by the Durability service for its communication
                    with other Durability services.</p>
                    <p>It specfies the maximum acceptable delay (in seconds) from
                    the time the data is written until the data is insterted in the
                    cache of the receiving Durability service(s) and the receiver is
                    notified of the fact. The default value is zero, indicating the
                    delay should be minimized.</p>
                ]]></comment>
        <minimum>0.0</minimum>
        <default>0.0</default>
      </attributeFloat>
      <attributeInt name="transport_priority" required="false">
        <comment><![CDATA[
                    <p>This attribute controls the transport priority QoS
                    setting that is used by the Durability service for its
                    communication with other Durability services.</p>
                    <p>It indicates the importance of the communication of the
                    Durability service with other Durability services in the
                    system. The transport priority specified here will be
                    interpreted by the Networking service and should be
                    used to differentiate the priority between communication
                    of user applications and communication of the Durability
                    service.</p>
                    ]]></comment>
        <minimum>0</minimum>
        <default>0</default>
      </attributeInt>
      <element name="Heartbeat" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    <p>During startup and at runtime, the network topology can change
                    dynamically. This happens when OpenSplice services are started/stopped
                    or when a network cable is plugged in/out. The Durability services
                    need to keep data consistency in that environment. To detect newly
                    joining services as well as detecting nodes that are leaving, the
                    Durability service uses a hearbeat mechanism. This element allows
                    fine-tuning of this mechanism.</p>

                    <p>Please note this heartbeat mechanism is similar to but not the
                    same as the service liveliness assertion.</p>
                ]]></comment>
        <attributeFloat name="latency_budget" required="false">
          <comment><![CDATA[
                        This attribute controls the latency budget QoS setting that
                        is only used by the Durability service for sending its heartbeats.
                        It overrules the value of the <i>DurabilityService/Network[@latency_budget]</i>.
                    ]]></comment>
          <minimum>0.0</minimum>
          <default>0.0</default>
        </attributeFloat>
        <attributeInt name="transport_priority" required="false">
          <comment><![CDATA[
                        This attribute controls the transport priority QoS setting (in seconds) that
                        is only used by the Durability service for for sending its heartbeats.
                        It overrules the value of the <i>DurabilityService/Network[@transport_priorrity]</i>.
                    ]]></comment>
          <minimum>0</minimum>
          <default>0</default>
        </attributeInt>
        <element name="Scheduling" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the scheduling parameters used by the
                        thread that periodically sends the heartbeats.
                    ]]></comment>
          <leafInt name="Priority" minOccurrences="1" maxOccurrences="1">
            <comment><![CDATA[
                            This element specifies the thread priority that will be used
                            by the thread that periodically sends the heartbeats. Only
                            priorities that are supported by the underlying operating
                            system can be assigned to this element. The user may need
                            special privileges from the underlying operating system to
                            be able to assign some of the privileged priorities.
                        ]]></comment>
            <default>0</default>
            <attributeEnum name="priority_kind" required="false">
              <comment><![CDATA[
                                This attribute specifies whether the specified
                                Priority is a relative or absolute priority.
                            ]]></comment>
              <value>Relative</value>
              <value>Absolute</value>
              <default>Relative</default>
            </attributeEnum>
          </leafInt>
          <leafEnum name="Class" minOccurrences="1" maxOccurrences="1">
            <comment><![CDATA[
                            This element specifies the thread scheduling class that will
                            be used by the thread that periodically sends the heartbeats.
                            The user may need the appropriate privileges from the underlying
                            operating system to be able to assign some of the privileged
                            scheduling classes.
                        ]]></comment>
            <value>Timeshare</value>
            <value>Realtime</value>
            <value>Default</value>
            <default>Default</default>
          </leafEnum>
        </element>
        <leafFloat name="ExpiryTime" minOccurrences="1" maxOccurrences="1">
          <comment><![CDATA[
                        <p>This element specifies the maximum amount of time in
                        which the Durability service expects a new heartbeat of
                        other Durability services. This is obviously also the
                        same amount of time in which the Durability service must
                        send a heartbeat itself.</p>
                        <p>Increasing this value will lead to less networking
                        traffic and overhead but also to less responsiveness with
                        respect to the liveliness of a Durability service. Change
                        this value according to the need of your system with respect
                        to these aspects.</p>
                    ]]></comment>
          <default>10.0</default>
          <minimum>0.2</minimum>
          <attributeFloat name="update_factor" required="true">
            <comment><![CDATA[
                            <p>In case of a (temporary) high CPU load, the scheduling
                            behaviour of the operating system might affect the
                            capability of the Durability service to send its
                            heartbeat 'on time'. This attribute introduces some
                            elasticity in this mechanism by making the service
                            send its heartbeat more often then required by the
                            ExpiryTime.</p>
                            <p>The Durability service will report its liveliness
                            every <i>ExpiryTime</i> multiplied by this
                            <i>update_factor</i>.</p>
                        ]]></comment>
            <minimum>0.1</minimum>
            <maximum>0.9</maximum>
            <default>0.2</default>
          </attributeFloat>
        </leafFloat>
      </element>
      <leafFloat name="InitialDiscoveryPeriod" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    <p>To be able to ensure data consistency of historical data, the
                    Durability service needs to know which other Durability services
                    are available in the system. The value of this element determines
                    the amount of time the Durability service takes at startup to get
                    acquinted with all other Durability services in the system.</p>
                    <p>Increasing the value will increase the startup time of the
                    Durability service, but is required in larger domains where a lot
                    of network bandwidth is used.</p>
                ]]></comment>
        <default>3.0</default>
        <minimum>0.1</minimum>
        <maximum>10.0</maximum>
      </leafFloat>
      <element name="Alignment" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    The Durability service is responsible for keeping its local cache
                    consistent with the other available Durability caches in the
                    system. To do this, it needs to exchange data to recover from
                    inconsistencies. The exchange of durable data to restore
                    consistency is called alignment. This element allows fine-tuning
                    alignment behaviour of the Durability service.
                ]]></comment>
        <attributeFloat name="latency_budget" required="false">
          <comment><![CDATA[
                        This attribute specifies the latency budget QoS setting (in seconds)
                        that is only used by the Durability service for the alignment of data.
                        It overrules the value of the
                        OpenSplice/DurabilityService/Network[@latency_budget].
                    ]]></comment>
          <minimum>0.0</minimum>
          <default>0.0</default>
        </attributeFloat>
        <attributeInt name="transport_priority" required="false">
          <comment><![CDATA[
                        This attribute specifies the transport priority QoS setting
                        that is used by the Durability service for the alignment of data.
                        It overrules the value of the
                        <i>DurabilityService/Network[@transport_priorrity]</i> for the
                        alignment of data only.
                    ]]></comment>
          <minimum>0</minimum>
          <default>0</default>
        </attributeInt>
        <leafBoolean name="TimeAlignment" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        This attribute specifies whether time on all nodes in
                        the domain can be considered aligned or not. This setting
                        needs to be consistent for all durability services in the
                        domain. In case there is no time alignment, the durability
                        service needs to align more data since to compensate possible
                        timing gaps between different nodes in the domain.
                    ]]></comment>
          <default>true</default>
        </leafBoolean>
        <element name="AlignerScheduling" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the scheduling parameters used to
                        control the thread that aligns other durability services.
                    ]]></comment>
          <leafInt name="Priority" minOccurrences="1" maxOccurrences="1">
            <comment><![CDATA[
                            This element specifies the thread priority that will be
                            used by the aligner thread. Only priorities that are
                            supported by the underlying operating system can be
                            assigned to this element. The user may need special
                            privileges from the underlying operating system to be
                            able to assign some of the privileged priorities.
                        ]]></comment>
            <default>0</default>
            <attributeEnum name="priority_kind" required="false">
              <comment><![CDATA[
                                This attribute specifies whether the specified
                                Priority is a relative or absolute priority.
                            ]]></comment>
              <value>Relative</value>
              <value>Absolute</value>
              <default>Relative</default>
            </attributeEnum>
          </leafInt>
          <leafEnum name="Class" minOccurrences="1" maxOccurrences="1">
            <comment><![CDATA[
                            This element specifies the thread scheduling class that
                            will be used by the aligner thread. The user may need the
                            appropriate privileges from the underlying operating
                            system to be able to assign some of the privileged
                            scheduling classes.
                        ]]></comment>
            <value>Timeshare</value>
            <value>Realtime</value>
            <value>Default</value>
            <default>Default</default>
          </leafEnum>
        </element>
        <element name="AligneeScheduling" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the scheduling parameters used to
                        control the thread that makes sure the local node becomes
                        and stays aligned.
                    ]]></comment>
          <leafInt name="Priority" minOccurrences="1" maxOccurrences="1">
            <comment><![CDATA[
                            This element specifies the thread priority that will be
                            used by the alignee thread. Only priorities that are
                            supported by the underlying operating system can be
                            assigned to this element. The user may need special
                            privileges from the underlying operating system to be
                            able to assign some of the privileged priorities.
                        ]]></comment>
            <default>0</default>
            <attributeEnum name="priority_kind" required="false">
              <comment><![CDATA[
                                This attribute specifies whether the specified
                                Priority is a relative or absolute priority.
                            ]]></comment>
              <value>Relative</value>
              <value>Absolute</value>
              <default>Relative</default>
            </attributeEnum>
          </leafInt>
          <leafEnum name="Class" minOccurrences="1" maxOccurrences="1">
            <comment><![CDATA[
                            This element specifies the thread scheduling class that
                            will be used by the alignee thread. The user may need the
                            appropriate privileges from the underlying operating
                            system to be able to assign some of the privileged
                            scheduling classes
                        ]]></comment>
            <value>Timeshare</value>
            <value>Realtime</value>
            <value>Default</value>
            <default>Default</default>
          </leafEnum>
        </element>
        <element name="RequestCombinePeriod" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        <p>When the Durability service detects an inconsistency with
                        another Durability service, it requests that service to align
                        it. The service that receives this request will restore
                        consistency by sending the requested information. In some
                        cases, the Durability service may receive alignment requests
                        from multiple Durability services for the same information
                        around the same moment in time. To reduce the processing and
                        networking load in that case, the Durability service is
                        capable of aligning multiple Durability services concurrently.</p>
                        <p>The RequestCombinePeriod has 2 child-elements: a setting
                        that is used when the current Durability Service is not yet
                        aligned with all others (<i>Initial</i>) and one for the period
                        after that (<i>Operational</i>). These values specify the maximum
                        amount of time the Durability service is allowed to wait with
                        alignment after an alignment request has been received.</p>
                        <p>Increasing the value will increase the amount of time in
                        which the Durability service restores from inconsistencies,
                        but will decrease the processing and network load in
                        case multiple Durability services need to resolve the
                        same data around the same time. Increasing the value
                        is useful in case OpenSplice is started at the same time
                        with more than two computing nodes.</p>
                    ]]></comment>
          <leafFloat name="Initial" minOccurrences="0" maxOccurrences="1">
            <comment><![CDATA[
                            This element specifies the maximum amount of time the Durability
                            Service is allowed to wait with alignment after an alignment
                            request has been received and the service itself is not yet
                            considered operational because it has not yet aligned itself
                            with all other Durability Services.
                        ]]></comment>
            <default>0.5</default>
            <minimum>0.01</minimum>
            <maximum>5.0</maximum>
          </leafFloat>
          <leafFloat name="Operational" minOccurrences="0" maxOccurrences="1">
            <comment><![CDATA[
                            This element specifies the maximum amount of time the Durability
                            Service is allowed to wait with alignment after an alignment
                            request has been received and the service itself is already
                            considered operational.
                        ]]></comment>
            <default>0.01</default>
            <minimum>0.01</minimum>
            <maximum>5.0</maximum>
          </leafFloat>
        </element>
        <element name="Partition" minOccurrences="0" maxOccurrences="0">
          <comment><![CDATA[
                        This tag specified an inter durability communication
                        partition with specific qos settings. Alignment between
                        durability services managed through this partition.
                        In case multiple partitions are defined the partition
                        with the highest alignment_priority that can provide
                        the requested data will be used as data source.
                        By default (no Partition specified) the
                        durability services will use an internal partition
                        that inherits the default qos policies and has the
                        default alignment_priority.
                    ]]></comment>
          <attributeString name="Name" required="true">
            <comment><![CDATA[
                            The name of the partition to use for alignment.
                        ]]></comment>
            <maxLength>0</maxLength>
            <default>partition</default>
          </attributeString>
          <attributeInt name="alignment_priority" required="false">
            <comment><![CDATA[
                            This attribute specifies the alignment priority of
                            the partition used by the durability service to
                            select the preferred partition to align from. If
                            no alignment_priority is configured, the service
                            uses 0 as default.
                        ]]></comment>
            <default>0</default>
            <minimum>0</minimum>
          </attributeInt>
          <attributeFloat name="latency_budget" required="false">
            <comment><![CDATA[
                            This attribute overrules the latency budget for
                            this partition specified at this point.
                        ]]></comment>
            <default>0.0</default>
            <minimum>0.0</minimum>
          </attributeFloat>
          <attributeInt name="transport_priority" required="false">
            <comment><![CDATA[
                            This attribute overrules the transport priority for
                            this partition specified at this point.
                        ]]></comment>
            <default>0</default>
            <minimum>0</minimum>
          </attributeInt>
        </element>
      </element>
      <element name="WaitForAttachment" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    The Durability service depends on the Networking service for its
                    communication with other Durability services. Before it starts
                    communicating, it must make sure the Networking service is ready to
                    send the data. This element specifies what services must
                    be available and how long the Durability service must wait for them
                    to become available before sending any data.
                ]]></comment>
        <attributeInt name="maxWaitCount" required="false">
          <comment><![CDATA[
                        This attribute specifies the number of times the Durability
                        service checks if the services specified in the
                        <i>DurabilityService/Network/WaitForAttachment/ServiceName</i>
                        elements are available before sending any data. An error is
                        logged if one of the services still is unavailable afterwards.
                        The service will continue after that, but this indicates
                        a problem in the configuration and the service might not
                        function correctly anymore.
                    ]]></comment>
          <minimum>1</minimum>
          <maximum>1000</maximum>
          <default>200</default>
        </attributeInt>
        <leafString name="ServiceName" minOccurrences="1" maxOccurrences="0">
          <comment><![CDATA[
                        This element specifies the name of the service(s) that the
                        Durability service waits for, before starting alignment activities
                        for a specific topic-partition combination. In a multinode
                        environment the name of the Networking service MUST be included
                        here to assure a proper functioning of the Durability service.
                    ]]></comment>
          <default>networking</default>
          <maxLength>0</maxLength>
        </leafString>
      </element>
      <!-- ResendTimeRange not supported yet.
            <leafFloat name="ResendTimeRange" minOccurrences="0" maxOccurrences="1">
                <comment><![CDATA[
                    The period (in seconds) ending with the time of the request, over
                    which the service wants samples produced by a node that has stopped.
                ]]></comment>
                <minimum>0.2</minimum>
                <maximum>2.0</maximum>
                <default>0.7</default>
            </leafFloat>
            -->
    </element>
    <element name="Persistent" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                <p>Durable data is divided in transient and persistent data. Transient
                data must stay available for as long as at least one Durability
                service is available in the system. For persistent data it is
                the same, but that type of data must also outlive the downtime
                of the system. The Durability service stores the persistent data
                on permanent storage to realize this. This element can be used
                to fine-tune the behaviour of the Durability service concerning
                the persistent properties of the data.</p>
                <p>Note these elements are only available as part of the DDS
                persistence profile of OpenSplice.</p>
            ]]></comment>
      <leafString name="StoreDirectory" minOccurrences="1" maxOccurrences="1">
        <comment><![CDATA[
                    This element determines the location where the persistent data will
                    be stored on disk. If this parameter is not configured,
                    the Durability service will not manage persistent data.
                ]]></comment>
        <maxLength>0</maxLength>
        <default>/tmp/pstore</default>
      </leafString>
      <leafFloat name="StoreSessionTime" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies the maximum session time (in seconds)
                    for the persistency thread. After this period of time, it makes
                    sure data is flushed to disk.
                ]]></comment>
        <maximum>60.0</maximum>
        <minimum>5.0</minimum>
        <default>20.0</default>
      </leafFloat>
      <leafFloat name="StoreSleepTime" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies the period of time (in seconds) the
                    persistency thread sleeps between two sessions. This allows
                    influencing the CPU load of the persistency thread.
                ]]></comment>
        <maximum>10.0</maximum>
        <minimum>0.5</minimum>
        <default>2.0</default>
      </leafFloat>
      <leafEnum name="StoreMode" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies the plug-in that is used to store the
                    persistent data on disk. With "XML" mode, the service will store
                    persistent data in XML files. With "MMF", the service will store
                    persistent data in a Memory Mapped File that exactly represents
                    the memory that is being used by the persistent store.
                    !!! The "MMF" store is currently only implemented on linux !!!
                ]]></comment>
                <value>XML</value>
                <value>MMF</value>
                <default>XML</default>
            </leafEnum>
            <attributeInt name="SmpCount" required="false">
                <comment><![CDATA[
                    This element determines how many threads the durability
                    service will spawn to persist data to disk. Currently only supported for MMF
                    (memory mapped file) storemode.
                ]]></comment>
                <minimum>1</minimum>
                <default>1</default>
            </attributeInt>

            <element name="MemoryMappedFileStore" minOccurrences="0" maxOccurrences="1">
                <comment><![CDATA[
                    This element specifies the memory mapped file store mode parameters. This
                    element is only valid when the Persistent/StoreMode element is set to "MMF".
                ]]></comment>

                <leafSize name="Size" minOccurrences="0" maxOccurrences="1">
	                <comment><![CDATA[
	                        This element specifies the size of the memory mapped file used to
	                        store persistent data. Change this value according to the size of
	                        your persistent data. The file should be big enough to store:
	                        <ul>
	                        <li>all persistent data in your specified namespaces</li>
	                        <li>PLUS a potential backup for all persistent data in
	                        namespaces whose content may be replaced by persistent
	                        data from another master.</li>
	                        </ul>
	                        <p>As a rule of thumb, you could state that the persistent store should
	                        be twice the size of your combined persistent data in your specified
	                        namespaces. Please note that the operating system should be configured
	                        to support the requested size.</p>
                            <p>If this value is not specified, the size of the persistent store will be
                            set to twice the size of the shared memory segment.</p>
	                ]]></comment>
	                <minimum>1048576</minimum>
	                <default>10485760</default>
            	</leafSize>
                <leafString name="Address" minOccurrences="0" maxOccurrences="1">
	                <comment><![CDATA[
	                    <p>This element specifies the start address where the
	                    file is mapped into the virtual memory.
	                    The possible values are platform dependent.</p>
	                    <p>Change this value if the default address is already in
	                    use, for example by another Domain Service or another
	                    product.</p>
                        <p>If this value is not specified, the file will be mapped
                        just after the shared memory segment.</p>
	                ]]></comment>
          <maxLength>0</maxLength>
          <default>0x80000000</default>
        </leafString>
      </element>
      <leafInt name="StoreOptimizeInterval" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element determines after how many write actions the
                    persistent set for a specific partition-topic combination
                    is optimized on disk.
                ]]></comment>
        <maximum>1000000000</maximum>
        <minimum>0</minimum>
        <default>0</default>
      </leafInt>
      <element name="Scheduling" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies the scheduling parameters used to
                    control the thread that stores persistent data on permanent
                    storage.
                ]]></comment>
        <leafInt name="Priority" minOccurrences="1" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the thread priority that will be used by the
                        persistent thread. Only priorities that are supported by the
                        underlying operating system can be assigned to this element.
                        The user may need special privileges from the underlying operating
                        system to be able to assign some of the privileged priorities.
                    ]]></comment>
          <default>0</default>
          <attributeEnum name="priority_kind" required="false">
            <comment><![CDATA[
                            This attribute specifies whether the specified
                            Priority is a relative or absolute priority.
                        ]]></comment>
            <value>Relative</value>
            <value>Absolute</value>
            <default>Relative</default>
          </attributeEnum>
        </leafInt>
        <leafEnum name="Class" minOccurrences="1" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the thread scheduling class that will be
                        used by the persistent thread. The user may need the appropriate
                        privileges from the underlying operating system to be able to
                        assign some of the privileged scheduling classes.
                    ]]></comment>
          <value>Timeshare</value>
          <value>Realtime</value>
          <value>Default</value>
          <default>Default</default>
        </leafEnum>
      </element>
      <!-- Deprecated parameter
            <leafInt name="QueueSize" minOccurrences="0" maxOccurrences="1">
                <comment><![CDATA[
                    Maximum number of samples in the persistent queue. The available
                    resources determine the maximum value of this setting. Specify
                    0 for unlimited resources.
                ]]></comment>
                <minimum>0</minimum>
                <maximum>10000</maximum>
                <default>0</default>
            </leafInt>
            -->
    </element>
    <element name="NameSpaces" minOccurrences="1" maxOccurrences="1">
      <comment><![CDATA[
                Scalability of durable data is an issue in large systems. Keeping
                all historical data on each node may not be feasible. Often nodes are
                interested in a small part of the total system data, on one hand
                driven by application interest, on the other hand driven by
                fault-tolerance (the need for replicates). This setting controls
                which historical data is managed by this Durability service
                (both transient and persistent).
            ]]></comment>
      <element name="NameSpace" minOccurrences="1" maxOccurrences="0">
        <comment><![CDATA[
                    A namespace describes a dependency between data in two or
                    more partitions by means of a partition expression. The
                    dependency specifies that the data within one of the
                    partitions has no right to exist separately from the data in
                    the other partition(s). Namespaces determine which data must
                    be managed by the Durability service. Data that does not
                    match any of the namespaces, is ignored by the Durability service.
                ]]></comment>
        <attributeString name="name" minOccurrences="1" maxOccurrences="1" required="true">
          <comment><![CDATA[
                		This element specifies the name for a namespace. A name is used
                    to match a namespace with a policy.
                	]]></comment>
          <maxLength>0</maxLength>
          <default>defaultNameSpace</default>
        </attributeString>
        <leafString name="Partition" minOccurrences="0" maxOccurrences="0">
          <comment><![CDATA[
                        This element specifies a partition-topic expression that
                        matches the namespace. A namespace consists of a set of
                        partition expressions. Together they determine the
                        partitions that belong to the namespace. Make sure the
                        different namespaces do not have an overlap in partitions.
                        The default configuration has one namespace containing all
                        partitions. A partition may contain the
                        wildcards '*' to match any number of characters and '?'
                        to match one single character.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default>*</default>
        </leafString>
        <leafString name="PartitionTopic" minOccurrences="0" maxOccurrences="0">
          <comment><![CDATA[
                        This element specifies a partition-topic - or 'group' expression that
                        matches the namespace. A group expression is a combination of a 
                        partition- and a topic expression. The notation is 'partition.topic'. 
                        A namespace consists of a set of group expressions. Together they 
                        determine the groups that belong to the namespace. Make sure the
                        different namespaces do not have an overlap in groups.
                        The default configuration has one namespace containing all
                        groups. A group expression may contain the wildcards '*' to match 
                        any number of characters and '?' to match one single character.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default>*.*</default>
        </leafString>
      </element>
      <element name="Policy" minOccurrences="1" maxOccurrences="0">
        <comment><![CDATA[
                    A namespace describes a dependency between data in two or
                    more partitions by means of a partition expression. The
                    dependency specifies that the data within one of the
                    partitions has no right to exist separately from the data in
                    the other partition(s). Namespaces determine which data must
                    be managed by the Durability service. Data that does not
                    match any of the namespaces, is ignored by the Durability service.

                    A template specifies behaviour for a namespace. It
                    matches a namespace name with an expression that may contain
                    wildcards, thereby allowing dynamic configuration for
                    namespaces. The order in which templates are specified is
                    important, as the first matching template
                    will be the one that is selected for a namespace.
                ]]></comment>
        <element name="Merge" minOccurrences="0" maxOccurrences="0">
          <attributeEnum name="type" required="true">
            <default>Ignore</default>
            <value>Ignore</value>
            <value>Merge</value>
            <value>Delete</value>
            <value>Replace</value>
          </attributeEnum>
          <attributeString name="scope" required="true">
            <maxLength>0</maxLength>
            <default>*</default>
          </attributeString>
        </element>
        <attributeString name="nameSpace" required="true">
          <comment><![CDATA[
                          The element specifies an expression that matches a namespace name.
                          A namespace may contain the wildcards '*' to match any number of
                          characters and '?' to match one single character.
                      ]]></comment>
          <maxLength>0</maxLength>
          <default>*</default>
        </attributeString>
        <attributeEnum name="durability" required="true">
          <comment><![CDATA[
                        <p>This element specifies how the durability service
                        manages the data within the NameSpace. The original
                        durability of the data (determined by the DataWriter
                        that wrote it) can be 'weakened' (Persistent > Transient
                        > Transient_local). This is useful to improve
                        resource usage of the durability service in the
                        situation where resource usage is more important
                        then fault-tolerance. This parameter cannot be used
                        to increase the original durability of samples.</p>
                        <p>In case the value of this parameter is larger then
                        the value a sample was published with, the sample will
                        be handled as specified in the DataWriter durability
                        QoS.</p>
                        <ul>
                         <li><b>Persistent</b>: Data is maximally handled as persistent.
                                               In practice this means a sample is
                                               handled exactly as specified in the
                                                DataWriter durability QoS that wrote
                                               it.</li>
                         <li><b>Transient</b>: A sample is maximally handled as if it
                                              were published with a transient
                                              durability QoS.</li>
                         <li><b>Transient_Local</b>: Data is maximally handled as if it
                                              were published with a
                                              transient_local durability QoS.</li>
                         <li><b>Durable</b>: Convenience value that behaves equal to
                                            Persistent.</li>
                         </ul>
                    ]]></comment>
          <default>Durable</default>
          <value>Durable</value>
          <value>Persistent</value>
          <value>Transient</value>
          <value>Transient_Local</value>
        </attributeEnum>
        <attributeBoolean name="aligner" required="true">
          <comment><![CDATA[
                		This element determines if the durability service will provide
                		historical data to other durability services.
                	]]></comment>
          <default>True</default>
        </attributeBoolean>
        <attributeBoolean name="delayedAlignment" required="false">
	        <comment><![CDATA[
	                		[BETA] This element determines if the durability allows delayed alignment of initial data.
	                		This can be usefull for systems where there can be late-joining nodes with a persistent
	                		dataset, which by default are then not inserted.
	                		When this option is enabled, durability will only insert a persistent set from a late joining 
	                		node when no writers have been created in the partitions matched by the namespace!
	                	]]></comment>
	        <default>False</default>
        </attributeBoolean>
        <attributeEnum name="alignee" required="true">
          <comment><![CDATA[
                        <p>This element determines how the durability service manages
                        the data that matches the namespace. Scalability of durable
                        data is an issue in large systems. Keeping all historical data
                        on each node may not be feasible. Often nodes are interested
                        in a small part of the total system data. They are driven
                        by both performance (boot time, memory usage, network load,
                        CPU load) and fault tolerance (the need for replicates).</p>
                        <p>The durability service provides the following
                        mechanisms to request and provide historical data:
                        <ul>
                        <li><b>Initial</b>: The durability service requests
                        historical data at startup and caches it locally. Historical
                        data will be available relatively fast for new local data
                        readers and the system is more fault-tolerant. However,
                        caching of historical data requires a relatively large
                        amount of resources and a long boot time.</li>
                        <li><b>Lazy</b>: The Durability service caches historical data
                        after local application interest arises for the first
                        time and a remote Durability service aligns the first
                        data reader. Historical data is available relatively slow
                        for the first data reader, but for every new data reader
                        it is relatively fast. The caching resources are only used
                        when local interest in the data arises, so it only requires
                        resources if there is actual local interest. However,
                        this method provides no fault-tolerance for the domain,
                        because the local Durability service is only partly a replica
                        and is not able to provide historical data to remote
                        Durability service and/or remote data readers.</li>
                        <li><b>On_Request</b>: The Durability service will not cache
                        historical data, but will align each separate DataReader
                        on a request basis (in the situation where it calls
                        wait_for_historical_data). Each new DataReader that
                        wants historical data therefore leads to a new alignment
                        action. This is a good setting to limit the amount of
                        resources used on the node, but will potentially lead to
                        more network traffic. This method provides no
                        fault-tolerance for the domain.</li>
                        </ul></p>
                    ]]></comment>
          <default>Initial</default>
          <value>Initial</value>
          <value>Lazy</value>
          <value>On_Request</value>
        </attributeEnum>
        <attributeEnum name="mergePolicy" required="false">
          <comment><![CDATA[
                    This tag specifies the merge policy applicable for a
                    specific namespace. The following merge policy values are
                    applicable:
                    <ul>
                    <li>Ignore - No alignment will take place. This is also
                    the default value if not specified.</li>
                    <li>Merge - Existing data will remain and data from others
                    will be aligned.</li>
                    <li>Reset - Existing data is removed.</li>
                    <li>Replace - Existing data is removed and data from
                    others will be aligned.</li>
                    ]]></comment>
          <default>Merge</default>
          <value>Merge</value>
          <value>Reset</value>
          <value>Replace</value>
          <value>Ignore</value>
        </attributeEnum>
      </element>
    </element>
    <element name="EntityNames" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                This element specifies the names of the various entities used by the
                DurabilityService. The names specified here will be displayed in the
                OpenSplice DDS Tuner when viewing the DurabilityService..
            ]]></comment>
      <leafString name="Publisher" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies the name of the durability publisher.
                ]]></comment>
        <maxLength>64</maxLength>
        <default>durabilityPublisher</default>
      </leafString>
      <leafString name="Subscriber" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies the name of the durability subscriber.
                ]]></comment>
        <maxLength>64</maxLength>
        <default>durabilitySubscriber</default>
      </leafString>
      <leafString name="Partition" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies the name of the durability partition.
                ]]></comment>
        <maxLength>64</maxLength>
        <default>durabilityPartition</default>
      </leafString>
    </element>
    <element name="Tracing" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                    This element controls the amount and type of information that is
                    written into the tracing log by the Durability Service. This is
                    useful to track the Durability Service during application
                    development. In the runtime system it should be turned off.
            ]]></comment>
      <attributeBoolean name="synchronous" required="false">
        <comment><![CDATA[
                    This attribute specifies whether tracing log updates are synchronous
                    or not. A synchronous update is immediately flushed to disk: there is
                    no buffering and therefore some performance overhead. Only use this
                    option if you are debugging and you want to make sure all Tracing info
                    is on disk when the service crashes.
                ]]></comment>
        <default>FALSE</default>
      </attributeBoolean>
      <leafString name="OutputFile" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This option specifies where the logging is printed to. Note that
                    "stdout" is considered a legal value that represents "standard out"
                    and "stderr" is a legal value representing "standard error".
                    The default value is an empty string, indicating that all tracing
                    is disabled.
                ]]></comment>
        <maxLength>0</maxLength>
        <default>durability.log</default>
      </leafString>
      <leafBoolean name="Timestamps" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies whether the logging must contain timestamps.
                ]]></comment>
        <attributeBoolean name="absolute" required="false">
          <comment><![CDATA[
                        This attribute specifies whether the timestamps are absolute or
                        relative to the startup time of the service.
                    ]]></comment>
          <default>true</default>
        </attributeBoolean>
        <default>true</default>
      </leafBoolean>
      <leafEnum name="Verbosity" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies the verbosity level of the logging
                    information. The higher the level, the more (detailed)
                    information will be logged.
                ]]></comment>
        <value>SEVERE</value>
        <value>WARNING</value>
        <value>INFO</value>
        <value>CONFIG</value>
        <value>FINE</value>
        <value>FINER</value>
        <value>FINEST</value>
        <value>NONE</value>
        <default>INFO</default>
      </leafEnum>
    </element>
  </element>
  <element name="NetworkService" minOccurrences="0" maxOccurrences="0">
    <comment><![CDATA[
            When communication endpoints are located on different computing nodes,
            the data produced using the local DDS service must be communicated to
            the remote DDS service and the other way around. The Networking service
            provides a bridge between the local DDS service and a network interface.
            Multiple Networking services can exist next to each other; each serving
            one (or more) physical network interface(s). The Networking service
            is responsible for forwarding data to the network and for receiving data
            from the network. It can be configured to distinguish multiple
            communication channels with different QoS policies assigned to be able
            to schedule sending and receival of specific messages to provide optimal
            performance for a specific application domain.
        ]]></comment>
    <attributeString name="name" required="true">
      <comment><![CDATA[
                This attribute identifies the configuration for the Networking service.
                Multiple Network service configurations can be specified in one single
                resource. The actual applicable configuration is determined by the value
                of the name attribute, which must match the one specified under the
                <i>//OpenSplice/Domain/Service[@name]</i> in the configuration of
                the DomainService.
            ]]></comment>
      <maxLength>0</maxLength>
      <default>networking</default>
    </attributeString>
    <element name="Watchdog" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                This element controls the characteristics of the Watchdog thread.
            ]]></comment>
      <element name="Scheduling" minOccurrences="1" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies the type of OS scheduling class will be
                    used by the thread that announces its liveliness periodically.
                ]]></comment>
        <leafInt name="Priority" minOccurrences="1" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the thread priority that will be used by the
                        watchdog thread. Only priorities that are supported by the
                        underlying operating system can be assigned to this element.
                        The user may need special privileges from the underlying operating
                        system to be able to assign some of the privileged priorities.
                    ]]></comment>
          <default>0</default>
          <attributeEnum name="priority_kind" required="false">
            <comment><![CDATA[
                            This attribute specifies whether the specified
                            Priority is a relative or absolute priority.
                        ]]></comment>
            <value>Relative</value>
            <value>Absolute</value>
            <default>Relative</default>
          </attributeEnum>
        </leafInt>
        <leafEnum name="Class" minOccurrences="1" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the thread scheduling class that will be used by
                        the watchdog thread. The user may need the appropriate privileges from
                        the underlying operating system to be able to assign some of the
                        privileged scheduling classes.
                    ]]></comment>
          <value>Timeshare</value>
          <value>Realtime</value>
          <value>Default</value>
          <default>Default</default>
        </leafEnum>
      </element>
    </element>
    <element name="General" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                This element contains general parameters that concern the networking service
                as a whole.
            ]]></comment>
      <leafString name="NetworkInterfaceAddress" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies which network interface card should be used.
                    Every Networking service is bound to only one network interface card
                    (NIC). The card can be uniquely identified by its corresponding
                    IP address or by its symbolic name (e.g. eth0). If the
                    value "first available" is entered here, the OpenSplice
                    middleware will try to look up an interface that has
                    the required capabilities.
                 ]]></comment>
        <maxLength>15</maxLength>
        <default>first available</default>
        <attributeBoolean name="forced" required="false">
          <comment><![CDATA[
                    This attribute specifies whether only the selected NetworkInterfaceAddress should be used or others can be used too.
                    <ul>
                        <li>false - Specifies that the NetworkInterfaceAddress is first used but when not available another,
                        when available, is used.
                        (default).
                        <li>true - Specifies that only the selected NetworkInterfaceAddress can be used.
                     </ul>
                     ]]></comment>
                    <default>false</default>
                </attributeBoolean>
                <attributeBoolean name="ipv6" required="false">
                    <comment><![CDATA[
                    This attribute specifies whether IPv6 should be used for communication.
                    <ul>
                        <li>false - specifies that IPv4 should be used
                        (default).
                        <li>true - Specifies that IPv6 should be used.
                     </ul>
                     This setting will be overriden & ignored if the element NetworkInterfaceAddress has an explicit value
                     that is unequivocally either an IPv4 or IPv6 address. This attribute is therefore only
                     optionally required to specify IPv6 communication when special values like "first available" or
                     an interface name are used instead of IP addresses.
                     ]]></comment>
                    <default>false</default>
                </attributeBoolean>
            </leafString>
            <element name="Reconnection" minOccurrences="0" maxOccurrences="1">
                <comment><![CDATA[
                     This element specifies the desired networking-behavior with respect to the
                     validity of restoring lost connectivity with remote nodes.
                     Here ‘lost connectivity’ means a prolonged inability to communicate with a known
                     and still active remote node (typically because of network-issues)
                     that has resulted in such a node being declared ‘dead’ either by the topology-discovery or
                     lost-reliability being detected by a reliable channel’s reactivity-checking mechanism.
                     If automatic reconnection is allowed, communication channels with the now-reachable-again node will be restored,
                     even though reliable data might have been lost during the disconnection period.
                ]]></comment>
        <attributeBoolean name="allowed" required="true">
          <comment><![CDATA[
                    This attribute specifies whether the network service must
                    resume communication with an other network service when it
                    has already been seen before but has been disconnected
                    for a while.
                    <ul>
                        <li>false - Specifies that the network service must NOT
                        resume communication.
                        (default).
                        <li>true -  Specifies that the network service must
                        resume communication.
                    </ul>
                    ]]></comment>
          <default>false</default>
        </attributeBoolean>
      </element>
    </element>
    <element name="Partitioning" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                <p>The OpenSplice Networking service is capable of leveraging
                the network's multicast and routing capabilities. If some a-priori
                knowledge about the participating
                nodes and their topic and partition interest is available, then the
                networking services in the system can be explicitly instructed to use
                specific unicast or multicast addresses for its networking traffic.
                This is done by means of so-called network partitions</p>
                <p>A network partition is defined by one or more unicast, multicast
                of broadcast IP addresses. Any networking service that is started
                will read the network partition settings and, if applicable, join
                the required multicast groups. For every sample distributed by the
                networking service, both its partition and topic name will be
                inspected. In combination with a set of network partition mapping rules,
                the service will determine to which network partition the sample is
                written. The mapping rules are configurable as well.</p>
                <p>Using
                networking configuration, nodes can be disconnected from any
                networking partition. If a node is connected via a low speed
                interface, it is not capable of receiving high volume data. If
                the DCPS partitioning is designed carefully, high volume data is
                published into a specific partition, which on its turn is mapped
                onto a specific networking partition, which on its turn is only
                connected to those nodes that are capable of handling high volume data.</p>
            ]]></comment>
      <element name="GlobalPartition" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies the global or default networking partition.
                ]]></comment>
        <attributeString name="Address" required="true">
          <comment><![CDATA[
                        The global
                        networking partition transports data that is either meant
                        to be global, like discovery heartbeats, or that is not
                        mapped onto any other networking partition. The address is a list
                        of one or more unicast, multicast or broadcast addresses. If more
                        than one address is specified, then the different
                        addresses are separated by a colon (,) semicolon (;) or space ( ).
                        Samples for the global partition will be sent to all addresses
                        that are specified in this list of addresses. To specify the
                        default broadcast address, use the expression "broadcast".
                        Addresses can be entered as dotted decimal notation or as the
                        symbolic hostname, in which case the middleware will try to resolve
                        the corresponding IP address.
                    ]]></comment>
          <default>broadcast</default>
          <maxLength>0</maxLength>
        </attributeString>
        <attributeString name="SecurityProfile" required="false">
          <comment><![CDATA[
                        In the context of secure networking, the GlobalPartition element provides
						support for the attribute SecurityProfile. The attribute is referencing a security
						profile declared in the context of the Security element.
						If the given reference is invalid, the global partition configuration is invalid. In this
						case, the partition will be blocked to prevent unwanted information leaks. A
						configuration error message will be logged to the ospl-error.log file. If the
						security feature has been enabled, but no profile is declared, then the NULL profile is
						used by default: this means that no security is added to the transport
                    ]]></comment>
          <default>nullProfile</default>
          <maxLength>0</maxLength>
        </attributeString>
        <attributeLong name="MulticastTimeToLive" required="false">
          <comment><![CDATA[For each UDP packet sent out, The TimeToLive header value is set to this value for Multicast packets.]]></comment>
          <minimum>0</minimum>
          <maximum>255</maximum>
          <default>32</default>
        </attributeLong>
      </element>
      <element name="NetworkPartitions" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    Networking configuration can contain a set of networking partitions,
                    which are grouped under the NetworkPartitions element.
                ]]></comment>
        <element name="NetworkPartition" minOccurrences="1" maxOccurrences="0">
          <comment><![CDATA[
                        Every NetworkPartition has a name, an address and a connected flag.
                    ]]></comment>
          <attributeString name="Name" required="false">
            <comment><![CDATA[
                            A networking partition is uniquely identified by its name.
                        ]]></comment>
            <default>networkPartition</default>
            <maxLength>0</maxLength>
          </attributeString>
          <attributeString name="Address" required="true">
            <comment><![CDATA[
                            The address is a list
                            of one or more unicast, multicast or broadcast addresses. If more
                            than one address is specified, then the different
                            addresses are separated by a colon (,) semicolon (;) or space ( ).
                            Samples for this network partition will be sent to all addresses
                            that are specified in this list of addresses. To specify the
                            default broadcast address, use the expression "broadcast".
                            Addresses can be entered as dotted decimal notation or as the
                            symbolic hostname, in which case the middleware will try to
                            resolve the corresponding IP address.
                        ]]></comment>
            <default>broadcast</default>
            <maxLength>0</maxLength>
          </attributeString>
          <attributeBoolean name="Connected" required="true">
            <comment><![CDATA[
                            <p>A node can choose to be not connected to a networking
                            partition by setting the Connected attribute.</p>
                            <p>If a node is connected to a networking partition,
                            it will join the corresponding multicast group and
                            it will receive data distributed over the partition.
                            If it is not connected, data distributed over the
                            partition will not reach the node but will be
                            filtered by the networking interface or multicast
                            enabled switches.</p>
                        ]]></comment>
            <default>true</default>
          </attributeBoolean>
          <attributeBoolean name="Compression" required="false">
            <comment><![CDATA[
                            This attribute specifies if networking will apply
                            compression to limit bandwidth for a specific
                            network partition. This provides great flexibility
                            as network partition are dynamically bind to
                            logical partitions. The following compression
                            values are allowed:
                            <ul>
                                <li>false - No compression is applied. This is
                                also the default value if not specified.</li>
                                <li>true - Compression is applicable</li>
                            </ul>
                        ]]></comment>
            <default>false</default>
          </attributeBoolean>
          <attributeString name="SecurityProfile" required="false">
            <comment><![CDATA[
	                        In the context of secure networking, the NetworkPartition element provides
							support for the attribute SecurityProfile. The attribute is referencing a security
							profile declared in the context of the Security element.
							If the given reference is invalid, the network partition configuration is invalid. In
							this case the partition will be blocked to prevent unwanted information leaks. A
							configuration error message will be logged to the ospl-error.log file. If the
							security feature has been enabled but no profile is declared, the NULL profile will be
							used by default.
							The ordering of network partition declarations in the OSPL configuration file must
							be the same for all nodes within the OpenSplice domain. If certain nodes shall not
							use one of the network partitions, the network partition in question must be declared
							as connected="false". In this case the declared security profile would not be
							evaluated or initialized, and the associated secret cipher keys need not to be defined
							for the OpenSplice node in question.
	                    ]]></comment>
            <default>nullProfile</default>
            <maxLength>0</maxLength>
          </attributeString>
          <attributeLong name="MulticastTimeToLive" required="false">
            <comment><![CDATA[For each UDP packet sent out, The TimeToLive header value is set to this value for Multicast packets.]]></comment>
            <minimum>0</minimum>
            <maximum>255</maximum>
            <default>32</default>
          </attributeLong>
        </element>
      </element>
      <element name="IgnoredPartitions" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element is used to group the set of IgnoredPartition elements.
                ]]></comment>
        <element name="IgnoredPartition" minOccurrences="1" maxOccurrences="0">
          <comment><![CDATA[
                        This element can be used to create a "Local Partition" that is only
                        available on the node on which it is specified, and therefore won't
                        generate network-load. Any DCPS partition-topic combination specified
                        in this element will not be distibuted by the Networking service.
                    ]]></comment>
          <attributeString name="DCPSPartitionTopic" required="true">
            <comment><![CDATA[
                            The Networking service will match any DCPS messages
                            to the DCPSPartitionTopic expression and determine
                            if it matches. The PartitionExpression and
                            TopicExpression are allowed to contain a '*' wildcard,
                            meaning that anything matches. An exact match is
                            considered better than a wildcard match. If a DCPS messages
                            matches an expression it will not be send to the network.
                        ]]></comment>
            <default>*.*</default>
            <maxLength>0</maxLength>
          </attributeString>
        </element>
      </element>
      <element name="PartitionMappings" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element is used to group the set of PartitionMapping elements.
                ]]></comment>
        <element name="PartitionMapping" minOccurrences="1" maxOccurrences="0">
          <comment><![CDATA[
                        <p>This element specifies a mapping between a network partition
                        and a partition-topic combination.</p>
                        <p>In order to give networking partitions a meaning in the context
                        of DCPS, mappings from DCPS partitions and topics onto networking
                        partitions should be defined. Networking allows for a set of
                        partition mappings to be defined.</p>
                    ]]></comment>
          <attributeString name="NetworkPartition" required="true">
            <comment><![CDATA[
                            The NetworkPartition attribute of a partition mapping
                            defines that networking partitition that data in a
                            specific DCPS partition of a specific DCPS topic
                            should be sent to.
                        ]]></comment>
            <default>networkPartition</default>
            <maxLength>0</maxLength>
          </attributeString>
          <attributeString name="DCPSPartitionTopic" required="true">
            <comment><![CDATA[
                            The Networking service will match any DCPS messages
                            to the DCPSPartitionTopic expression and determine
                            if it matches. The PartitionExpression and
                            TopicExpression are allowed to contain a '*' wildcard,
                            meaning that anything matches. An exact match is
                            considered better than a wildcard match. For every
                            DCPS message, the best matching partition is determined
                            and the data is sent over the corresponding networking
                            partition as specified by the matching
                            <i>NetworkPartition</i> element.
                        ]]></comment>
            <default>*.*</default>
            <maxLength>0</maxLength>
          </attributeString>
        </element>
      </element>
    </element>
    <element name="Security" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                The Security section defines the parameters relevant for secure networking.
				Declaring this element in the OSPL configuration file will activate the secure
				networking feature. Without any additional security settings, all network partitions
				of the node would use the NULL cipher encoding. If confidentiality and integrity is
				required for a network partition, the network partition must be associated with a
				security profile
            ]]></comment>
      <attributeBoolean name="enabled" required="false">
        <comment><![CDATA[
                        This is an optional attribute. If not defined it defaults to true and all network
						partitions, if not specified otherwise, will be encoded using the NULL cipher. The
						NULL cipher does not provide for any level of integrity or confidentiality, but
						message items will be sent unencrypted.
						In case of enabled="false" the security feature will not be activated, and the
						node acts like any other OpenSplice node not being security aware. Security profiles
						defined in the configuration file will not take effect, but will cause the system to log
						warnings.
                    ]]></comment>
        <values>true</values>
        <values>false</values>
        <default>false</default>
      </attributeBoolean>
      <element name="SecurityProfile" minOccurrences="0" maxOccurrences="0">
        <comment><![CDATA[
                   This element defines the security profile which can be applied to one or more
                   network partitions. This element is optional.
                ]]></comment>
        <attributeString name="Name" required="true">
          <comment><![CDATA[
                       This is a mandatory attribute. The name must be unique for all Security Profiles
					   being declared. If the name is not specified, the security profile will be ignored as it
					   cannot be referenced anyway.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default>aSecurityProfile</default>
        </attributeString>
        <attributeString name="Cipher" required="true">
          <comment><![CDATA[
                        This is a mandatory attribute. Depending on the declared cipher, the cipher key must
						have a specific length, 128 bits, 192 bits, 256 bits or none at all. The following
						case-insensitive values are supported by the current implementation:
						<p>• aes128, implements AES cipher with 128 bit cipher-key (16 Bytes, 32
						hexadecimal characters). This cipher will occupy 34 bytes of each UDP packet
						being sent.</p>
						<p>• aes192, implements the AES cipher with 192 bit cipher-key (24 Bytes, 48
						hexadecimal characters). This cipher will occupy 34 bytes of each UDP packet
						being sent.</p>
						<p>• aes256, implements the AES cipher with 256 bit cipher-key (32 Bytes, 64
						hexadecimal characters. This cipher will occupy 34 bytes of each UDP packet
						being sent.</p>
						<p>• blowfish, implements the Blowfish cipher with 128 bit cipher-key (16 Bytes, 32
						hexadecimal characters). This cipher will occupy 26 bytes of each UDP packet
						being sent.</p>
						<p>• null, implements the NULL cipher. The only cipher that does not require a
						cipher-key. This cipher will occupy 4 bytes of each UDP packet being sent.
						</p>
						All ciphers except for the NULL cipher are combined with SHA1 to achieve data
						integrity. Also, the rsa- prefix can be added to the ciphers. In this case, digital
						signatures using RSA will be available.
                    ]]></comment>
          <maxLength>0</maxLength>
          <value>aes128</value>
          <value>aes192</value>
          <value>aes256</value>
          <value>blowfish</value>
          <value>null</value>
          <value>rsa-aes128</value>
          <value>rsa-aes192</value>
          <value>rsa-aes256</value>
          <value>rsa-blowfish</value>
          <value>rsa-null</value>
          <default>null</default>
        </attributeString>
        <attributeString name="CipherKey" required="true">
          <comment><![CDATA[
                        The CipherKey attribute is used to define the secret key required by the declared
						cipher. The value can be a URI referencing an external file containing the secret key,
						or the secret key can be defined in-place directly as a string value. The key must be
						defined as a hexadecimal string, each character representing 4 bits of the key, for
						example. 1ABC represents the 16 bit key 0001 1010 1011 1100. The key must
						not follow a well-known pattern and must match exactly the key length required by
						the chosen cipher. In case of malformed cipher-keys, the security profile in question
						will be marked as invalid. Moreover, each network partition referring to the invalid
						Security Profile will not be operational and thus traffic will be blocked to prevent
						information leaks.
						As all OpenSplice applications require read access to the XML configuration file,
						for security reasons it is recommended to store the secret key in an external file in
						the file system, referenced by the URI in the configuration file. The file must be
						protected against read and write access from other users on the host. Verify that
						access rights are not given to any other user or group on the host.

						Alternatively, storing the secret key in-place in the XML configuration file will give
						read/write access to all DDS applications joining the same OpenSplice node.
						Because of this, the ‘in-place’ method is strongly discouraged.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
      </element>
      <element name="AccessControl" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    The optional AccessControl element defines settings for access control enforcement
                    and which access control module shall be used.
                ]]></comment>
        <attributeBoolean name="enabled" required="false">
          <comment><![CDATA[
                        The access control feature will be activated when enabled="true"
                    ]]></comment>
          <values>true</values>
          <values>false</values>
          <default>false</default>
        </attributeBoolean>
        <attributeString name="policy" required="false">
          <comment><![CDATA[
                        The policy attribute references a file containing the access control policy.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <element name="AccessControlModule" minOccurrences="0" maxOccurrences="0">
          <comment><![CDATA[
	                    The AccessControlModule element defines which access control module will be
						used. More than one module may be defined. All defined and enabled modules will
						be used to determine if access should be granted.
	                ]]></comment>
          <attributeBoolean name="enabled" required="false">
            <comment><![CDATA[
	                        The module specified in the type attribute is used to evaluate access control rules
	                        when enabled="true".
	                    ]]></comment>
            <values>true</values>
            <values>false</values>
            <default>true</default>
          </attributeBoolean>
          <attributeString name="type" required="false">
            <comment><![CDATA[
	                        The type attribute defines the access control model type. Currently, OpenSplice only
							supports mandatory access control, accordingly the only valid value for this
							attribute is “MAC”.
	                    ]]></comment>
            <values>MAC</values>
            <default>none</default>
            <maxLength>0</maxLength>
          </attributeString>
        </element>
      </element>
      <element name="Authentication" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                     The optional Authentication element defines whether additional sender
					 authorization shall be performed. Enabling Authentication requires that a cipher,
					 including RSA (such as rsa-aes256), is used.
                  ]]></comment>
        <attributeBoolean name="enabled" required="false">
          <comment><![CDATA[
                         Authentication is performed when enabled is set to true.
                      ]]></comment>
          <values>true</values>
          <values>false</values>
          <default>true</default>
        </attributeBoolean>
        <element name="X509Authentication" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        The X509Authentication element defines where keys and certificates required for
                        X509 authentication may be found.
                    ]]></comment>
          <element name="Credentials" minOccurrences="0" maxOccurrences="1">
            <comment><![CDATA[
		                   The Credentials element is an optional element. If it is missing, then the node does
		                   not sign messages (in other words, does not send credentials).
		               ]]></comment>
            <leafString name="Key" minOccurrences="1" maxOccurrences="1">
              <comment><![CDATA[
	                       The Key element references the file containing the key.

	                       It is recommended that the absolute path is used. A relative path
						   will be interpreted relative to the directory from which the
						   OpenSplice daemon is started.
	                   ]]></comment>
              <maxLength>0</maxLength>
              <default/>
            </leafString>
            <leafString name="Cert" minOccurrences="1" maxOccurrences="1">
              <comment><![CDATA[
	                       The Cert element references the file containing the certificate.

	                       It is recommended that the absolute path is used. A relative path
	                       will be interpreted relative to the directory from which the
	                       OpenSplice daemon is started.
	                   ]]></comment>
              <maxLength>0</maxLength>
              <default/>
            </leafString>
          </element>
          <leafString name="TrustedCertificates" minOccurrences="1" maxOccurrences="1">
            <comment><![CDATA[
                        The TrustedCertificates element references a file containing the trusted certificates.

                        It is recommended that the absolute path is used. A relative path
                        will be interpreted relative to the directory from which the
                        OpenSplice daemon is started.
                    ]]></comment>
            <maxLength>0</maxLength>
            <default/>
          </leafString>
        </element>
      </element>
    </element>
    <element name="Channels" minOccurrences="1" maxOccurrences="1">
      <comment><![CDATA[
                <p>This element is used to group a set of Channels.</p>
                <p>The set of channels define the behaviour of the 'network' concerning
                aspects as priority, reliability and latency budget. By configuring
                a set of channels, the Networking service is able to function as a
                'scheduler' for the network bandwidth. It achieves this by using the
                application-defined DDS QoS policies of the data to select the most
                appropriate channel to send the data.</p>
            ]]></comment>
      <element name="Channel" minOccurrences="1" maxOccurrences="42">
        <comment><![CDATA[
                    <p>This element specifies all properties of an individual Channel.</p>
                    <p>The Networking service will make sure messages with a higher
                    priority precede messages with a lower priority and it uses the
                    latency budget to assemble multiple messages into one UDP packet
                    where possible, to optimize the bandwidth usage. Of course, its
                    performance depends heavily on the compatbility of the configured
                    channels with the used DDS QoS policies of the applications.</p>
                ]]></comment>
        <attributeString name="name" required="true">
          <comment><![CDATA[
                        The name uniquely identifies the channel.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default>aChannel</default>
        </attributeString>
        <attributeBoolean name="reliable" required="true">
          <comment><![CDATA[
                        <p>If this attribute is set to true, the channel sends all messages reliably.
                        If not, data is sent only once (fire-and-forget).</p>
                        <p>The specific channel a message is written into depends on the attached
                        quality of service. Once a message has arrived in a channel, it will be
                        transported with the quality of service attached to the channel. If the
                        reliable attribute happens to be set to true, the message will be sent
                        over the network using a reliability protocol.</p>
                    ]]></comment>
          <default>false</default>
        </attributeBoolean>
        <attributeBoolean name="default" required="false">
          <comment><![CDATA[
                        <p>This attribute indicates whether the channel is selected as the
                        default channel in case no channel offers the quality of service
                        requested by a message.</p>
                        <p>The networking channels should be configured corresponding
                        to the quality of service settings that are expected to be
                        requested by the applications. It might happen, however,
                        that none of the available channels meets the requested
                        quality of service for a specific message. In that case,
                        the message will be written into the default channel.</p>
                        <p>Note that only one channel is allowed to have this attribute
                        set to true</p>
                    ]]></comment>
          <default>false</default>
        </attributeBoolean>
        <attributeBoolean name="enabled" required="true">
          <comment><![CDATA[
                        This attribute toggles a channel on or off. Toggling a
                        channel between enabled and disabled is a quick alternative
                        for commenting out the corresponding lines in the configuration
                        file.
                    ]]></comment>
          <default>false</default>
        </attributeBoolean>
        <attributeInt name="priority" required="false">
          <comment><![CDATA[
                        This attribute sets the transport priority of the channel.
                        Messages sent to the network have a transport_priority
                        quality of service value. Selection of a networking channel
                        is based on the priority requested by the message and the
                        priority offered by the channel. The priority settings
                        of the different channels divide the priority range
                        into intervals. Within a channel, messages are sorted in
                        order of priority.
                    ]]></comment>
          <default>0</default>
        </attributeInt>
        <leafInt name="PortNr" minOccurrences="1" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the port number used by the Channel.
                        Messages for the channel are sent to the port number given.
                        Each channel needs its own unique port number. Please note
                        that 'reliable' channels use a second port, which is the
                        specified PortNr + 1.
                    ]]></comment>
          <minimum>1</minimum>
          <maximum>65535</maximum>
          <default>53430</default>
        </leafInt>
        <leafSize name="FragmentSize" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        The networking module will fragment large message into smaller
                        fragments with size <b>FragmentSize</b>. These fragments
                        are sent as datagrams to the UDP stack. OS-settings determine
                        the maximum datagram size.
                    ]]></comment>
          <minimum>200</minimum>
          <maximum>65535</maximum>
          <default>1300</default>
        </leafSize>
        <leafInt name="Resolution" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        <p>The resolution indicates the number of milliseconds that
                        this channel sleeps between two consecutive resend or
                        packing actions. Latency budget values are truncated to a
                        multiple of "Resolution" milliseconds.</p>
                        <p>It is considered good practice to specify the ThrottleTreshold consistently throughout
                        the system.</p>
                    ]]></comment>
          <minimum>1</minimum>
          <default>10</default>
        </leafInt>
        <leafInt name="AdminQueueSize" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        <p>For reliable channels the receiving side needs to keep the sending
                        side informed about the received data and the received control messages.</p>
                        <p>This is done by means of an "AdminQueue". This setting determines the
                        size of this queue, and it must be greater than the maximum number of reliable
                        messages send or received during each "Resolution" milliseconds.</p>
                    ]]></comment>
          <minimum>400</minimum>
          <default>4000</default>
        </leafInt>
        <element name="Sending" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        This element describes all properties for the transmitting side
                        of the Channel.
                    ]]></comment>
          <leafBoolean name="CrcCheck" minOccurrences="0" maxOccurrences="1">
            <comment><![CDATA[
                       In order to protect OpenSplice network packets from malicious attack the CrcCheck(cyclic redundancy check) configuration item has been added.
                       CRCs are specifically designed to protect against common types of errors on communication channels.
                       When enabled the integrity of delivered network packets from one DDS process to another is assured.
                       There is a small performance cost using this feature due to the addtional overhead of carrying out the crc calculation.

                       When the sending side is enabled the network packet will contain a valid crc field.
                    ]]></comment>
            <default>false</default>
          </leafBoolean>
          <leafInt name="QueueSize" minOccurrences="0" maxOccurrences="1">
            <comment><![CDATA[
                            This element specifies the number of messages the networking queue
                            can contain.
                            Messages sent to the network are written into the networking queue.
                            The networking service will read from this queue. If this
                            queue is full, the writer writing into the queue is suspended
                            and will retry until success. Note that a full networking queue is
                            a symptom of an improperly designed system.
                        ]]></comment>
            <minimum>1</minimum>
            <default>400</default>
          </leafInt>
          <leafSize name="MaxBurstSize" minOccurrences="0" maxOccurrences="1">
            <comment><![CDATA[
                            Amount in bytes to be sent at maximum every
                            "Resolution" milliseconds. The default value is set to 1GB per resolution tick. This can be
                            considered "unlimited" as this far exceeds the capacity of modern physical networks.
                        ]]></comment>
            <minimum>1024</minimum>
            <maximum>1073741823</maximum>
            <default>1073741823</default>
          </leafSize>
          <leafInt name="ThrottleLimit" minOccurrences="0" maxOccurrences="1">
            <comment><![CDATA[
                            Throttling will enable you to further limit (below MaxBurstSize) the amount of data that is
                            sent every Resolution interval. This happens if one of the receiving nodes in the network
                            indicates that it has trouble processing all incoming data. This value is the lower boundary
                            of the range over which the throttling can adapt the limit. If this value is set to the same
                            value (or higher) as MaxBurstSize throttling is disabled.
                        ]]></comment>
            <minimum>128</minimum>
            <default>10240</default>
          </leafInt>
          <leafInt name="ThrottleThreshold" minOccurrences="0" maxOccurrences="1">
            <comment><![CDATA[
                            <p>This is the number of unprocessed network fragments that a node will store before it will inform
                            the other nodes in the network that it has trouble processing the incoming data. Those other nodes
                            can use this information to adjust their throttle values, effectively reducing the amount of incoming
                            data in case of a temporary overflow, and increasing again when the node is able to catch up.</p>
                            <p>It is considered good practice to specify the ThrottleTreshold consistently throughout
                            the system.</p>
                        ]]></comment>
            <minimum>2</minimum>
            <default>50</default>
          </leafInt>
          <leafInt name="MaxRetries" minOccurrences="0" maxOccurrences="1">
            <comment><![CDATA[
                            The number of retransmissions the service has to execute before considering the addressed node
                            as not responding.
                        ]]></comment>
            <minimum>1</minimum>
            <default>100</default>
          </leafInt>
          <leafInt name="RecoveryFactor" minOccurrences="0" maxOccurrences="1">
            <comment><![CDATA[A lost message is resent after Resolution * RecoveryFactor milliseconds.]]></comment>
            <minimum>2</minimum>
            <default>3</default>
          </leafInt>
          <leafInt name="DiffServField" minOccurrences="0" maxOccurrences="1">
            <comment><![CDATA[
                        This element describes the DiffServ setting the channel will apply to all its
                        networking messages.
                        ]]></comment>
            <minimum>0</minimum>
            <maximum>255</maximum>
            <default>0</default>
          </leafInt>
          <leafBoolean name="DontRoute" minOccurrences="0" maxOccurrences="1">
            <comment><![CDATA[The IP DONTROUTE
                              socket option is set to the value specified.]]></comment>
            <value>True</value>
            <value>False</value>
            <default>True</default>
          </leafBoolean>
          <leafInt name="TimeToLive" minOccurrences="0" maxOccurrences="1">
            <comment><![CDATA[For each UDP packet sent out, the IP Time To Live
                              header value is set to the value specified.]]></comment>
            <minimum>0</minimum>
            <maximum>255</maximum>
            <default>0</default>
          </leafInt>
          <element name="Scheduling" minOccurrences="0" maxOccurrences="1">
            <comment><![CDATA[
                            This element specifies the scheduling policies used to control the transmitter
                            thread of the current Channel.
                        ]]></comment>
            <leafInt name="Priority" minOccurrences="1" maxOccurrences="1">
              <comment><![CDATA[
                                This element specifies the thread priority that will be used by the transmitter
                                thread. Only priorities that are supported by the underlying operating system
                                can be assigned to this element. The user may need special privileges from the
                                underlying operating system to be able to assign some of the privileged priorities.
                            ]]></comment>
              <default>0</default>
              <attributeEnum name="priority_kind" required="false">
                <comment><![CDATA[
                                    This attribute specifies whether the specified
                                    <i>Priority</i> is a relative or absolute priority.
                                ]]></comment>
                <value>Relative</value>
                <value>Absolute</value>
                <default>Relative</default>
              </attributeEnum>
            </leafInt>
            <leafEnum name="Class" minOccurrences="1" maxOccurrences="1">
              <comment><![CDATA[
                                This element specifies the thread scheduling class that will be used by the transmitter
                                thread. The user may need the appropriate privileges from the underlying operating system
                                to be able to assign some of the privileged scheduling classes.
                            ]]></comment>
              <value>Timeshare</value>
              <value>Realtime</value>
              <value>Default</value>
              <default>Default</default>
            </leafEnum>
          </element>
        </element>
        <element name="Receiving" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        This element describes all properties for the receiving side
                        of the Channel.
                    ]]></comment>
          <leafBoolean name="CrcCheck" minOccurrences="0" maxOccurrences="1">
            <comment><![CDATA[
                       In order to protect OpenSplice network packets from malicious attack the CrcCheck(cyclic redundancy check) configuration item has been added.
                       CRCs are specifically designed to protect against common types of errors on communication channels.
                       When enabled the integrity of delivered network packets from one DDS process to another is assured.
                       There is a small performance cost using this feature due to the addtional overhead of carrying out the crc calculation.

                       When the receiving side is enabled only network packets that contain a valid crc field are accepted.
                    ]]></comment>
            <default>false</default>
          </leafBoolean>
          <leafSize name="ReceiveBufferSize" minOccurrences="0" maxOccurrences="1">
            <comment><![CDATA[
                            The UDP receive buffer of the best effort channel socket is
                            set to the value given. If many message are lost, the
                            receive buffer size has to be increased.
                        ]]></comment>
            <minimum>1024</minimum>
            <default>1000000</default>
          </leafSize>
          <element name="Scheduling" minOccurrences="0" maxOccurrences="1">
            <comment><![CDATA[
                            This element specifies the scheduling policies used to control the
                            receiver thread of the current Channel.
                        ]]></comment>
            <leafInt name="Priority" minOccurrences="1" maxOccurrences="1">
              <comment><![CDATA[
                                This element specifies the thread priority that will be used by the receiver
                                thread. Only priorities that are supported by the underlying operating system
                                can be assigned to this element. The user may need special privileges from
                                the underlying operating system to be able to assign some of the privileged
                                priorities.
                            ]]></comment>
              <default>0</default>
              <attributeEnum name="priority_kind" required="false">
                <comment><![CDATA[
                                    This attribute specifies whether the specified
                                    <i>Priority</i> is a relative or absolute priority.
                                ]]></comment>
                <value>Relative</value>
                <value>Absolute</value>
                <default>Relative</default>
              </attributeEnum>
            </leafInt>
            <leafEnum name="Class" minOccurrences="1" maxOccurrences="1">
              <comment><![CDATA[
                                This element specifies the thread scheduling class that will be used by the receiver
                                thread. The user may need the appropriate privileges from the underlying operating
                                system to be able to assign some of the privileged scheduling classes.
                            ]]></comment>
              <value>Timeshare</value>
              <value>Realtime</value>
              <value>Default</value>
              <default>Default</default>
            </leafEnum>
          </element>
          <leafSize name="DefragBufferSize" minOccurrences="0" maxOccurrences="1">
            <comment><![CDATA[
                            The maximum number of Fragment buffers that will be allocated for
                            this channel. These buffers are used to store incoming fragments
                            waiting to be processed, as well as fragments that are being processed.
                        ]]></comment>
            <minimum>500</minimum>
            <default>5000</default>
          </leafSize>
          <element name="SMPOptimization" minOccurrences="0" maxOccurrences="1">
            <comment><![CDATA[
                            This option will distribute the processing done for incoming fragements over
                            multiple threads, which will lead to an improved throughput on SMP nodes.
                        ]]></comment>
            <attributeBoolean name="enabled" required="true">
              <comment><![CDATA[
                                This attribute toggles the Optimization on or off.
                            ]]></comment>
              <default>true</default>
            </attributeBoolean>
          </element>
          <leafInt name="MaxReliabBacklog" minOccurrences="0" maxOccurrences="1">
            <comment><![CDATA[
                            This is a lower limit to the DefragBufferSize that specifies the number of received fragments
                            from a single remote node allocated for the purpose of order preservation because an earlier
                            fragment from that remote node is missing. If this number is exceeded, then that particular
                            remote node that didn't resend the missing fragent in time is considered dead for this channel.
                        ]]></comment>
                        <minimum>100</minimum>
                        <default>1000</default>
                    </leafInt>
                    <leafInt name="PacketRetentionPeriod" minOccurrences="0" maxOccurrences="1">
                        <comment><![CDATA[
                            This element specifies the number of milliseconds received packets are retained by the network
							service for its so-called "reliability-under-publisher-crash" extended reliability
							protocol. This protocol ensures that a consistent or aligned data-set is received by all
							alive (receiving) nodes, even though some nodes might not have received some
							packets at the moment a sending node disappears (for whatever reason). The
							protocol implies that each node retains sufficient received data so that it can be
							(re-)distributed if a publishing node disappears before all receiving nodes are
							"up-to-date". When the PacketRetentionPeriod element is set to 0 (the default
							value), the alignment amongst receiving nodes will not occur. To activate the
							extended realibility protocol, this setting must be configured to a time period that
							exceeds the worst-case death-detection time as configured for the discovery
							protocol of the set of distributed networking services in the system.
                        ]]></comment>
                        <minimum>0</minimum>
                        <default>0</default>
                    </leafInt>
                    <leafInt name="ReliabilityRecoveryPeriod" minOccurrences="0" maxOccurrences="1">
                        <comment><![CDATA[
                            This element specifies a timeout period (in milliseconds) for the alignment phase of the extended
							reliability protocol. It only has an effect when the related
							PacketRetentionperiod is set to a non-zero value. After the specified
							reliabilityRecoveryPeriod timeout, any data retained for the purpose of
							alignment of receiving nodes (following the disappearance or crash of a publishing
							node) will be discarded. The value of this timeout period must be sufficient to allow
							for the worst-case alignment-time of any "missed" data by individual receiving
							nodes following the disappearance of a sending node in the system.
                        ]]></comment>
                        <minimum>0</minimum>
                        <default>1000</default>
                    </leafInt>
                </element>
            </element>
        </element>
    <element name="Discovery" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                This element is used to configure the various parameters of the Discovery Channel,
                which is used to discover all relevant participating entities in the current Domain.
                The purpose of the discovery process is to build-up and maintain a notion of all
                relevant active nodes within the domain.  The relevance of discovered remote nodes
                can be defined statically (by definition of the so-called Global Partition) and/or
                can be dynamically expanded and maintained by the dynamic-discovery process driven
                by the node's Role and Scope.
            ]]></comment>
      <attributeBoolean name="enabled" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element can be used to enable or disable the Discovery Channel. In case the Discovery
                    Channel is disabled, entities will only detect each others presence implicitly once messages
                    are received for the first time.
                ]]></comment>
        <default>true</default>
      </attributeBoolean>
      <attributeString name="Scope" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This attribute controls the dynamic discovery behaviour of this node within the current Domain.
                    If it is not set, dynamic discovery will be disabled and the networking service will only
                    communicate with nodes that can be reached through the predefined Global Partition. If the Scope
                    attribute is specified, dynamic discovery is enabled and the networking service will be able to
                    communicate with all nodes in the system that have a Role that matches the Scope expression.
                    The Scope expression can contain a comma separated list of wild-card role-expressions. If the
                    role of any  discovered node matches any of the wild-card expressions, the remote node is
                    considered a match and will become part of the communication reach (i.e. the Global Partition)
                    of the current domain.
                ]]></comment>
        <maxLength>512</maxLength>
        <default/>
      </attributeString>
      <leafInt name="PortNr" minOccurrences="1" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies the Port number used by the Discovery Channel.
                ]]></comment>
        <minimum>1</minimum>
        <maximum>65536</maximum>
        <default>53450</default>
      </leafInt>
      <leafString name="ProbeList" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element contains the addresses of the nodes that will be contacted to retrieve an initial
                    list of participating nodes in the current domain that match the specified Scope. Multiple
                    ProbeList addresses can be entered by separating them by a colon (,), semicolon (;) or space( ) .
                    The addresses can be entered as dotted decimal notation or as the symbolic hostname, in which
                    case the middleware will try to resolve the corresponding IP address.
                ]]></comment>
        <maxLength>512</maxLength>
        <default/>
      </leafString>
      <element name="Sending" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element describes all properties for the transmitting side
                    of the Discovery Channel.
                ]]></comment>
        <leafBoolean name="CrcCheck" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                       In order to protect OpenSplice network packets from malicious attack the CrcCheck(cyclic redundancy check) configuration item has been added.
                       CRCs are specifically designed to protect against common types of errors on communication channels.
                       When enabled the integrity of delivered network packets from one DDS process to another is assured.
                       There is a small performance cost using this feature due to the addtional overhead of carrying out the crc calculation.

                       When the sending side is enabled the network packet will contain a valid crc field.
                    ]]></comment>
          <default>false</default>
        </leafBoolean>
        <leafInt name="DiffServField" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        This element describes the DiffServ setting the channel will apply to all its
                        networking messages.
                        ]]></comment>
          <minimum>0</minimum>
          <maximum>255</maximum>
          <default>0</default>
        </leafInt>
        <leafBoolean name="DontRoute" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[The IP DONTROUTE
                              socket option is set to the value specified.]]></comment>
          <value>True</value>
          <value>False</value>
          <default>True</default>
        </leafBoolean>
        <leafInt name="TimeToLive" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[For each UDP packet sent out, the IP Time To Live
                              header value is set to the value specified.]]></comment>
          <minimum>0</minimum>
          <maximum>255</maximum>
          <default>0</default>
        </leafInt>
        <element name="Scheduling" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the scheduling policies used to control the transmitter thread
                        of the Discovery Channel.
                    ]]></comment>
          <leafInt name="Priority" minOccurrences="1" maxOccurrences="1">
            <comment><![CDATA[
                            This element specifies the thread priority that will be used by the transmitter thread
                            of the Discovery Channel. Only priorities that are supported by the underlying operating
                            system can be assigned to this element. The user may need special privileges from the
                            underlying operating system to be able to assign some of the privileged priorities.
                        ]]></comment>
            <default>0</default>
            <attributeEnum name="priority_kind" required="false">
              <comment><![CDATA[
                                This attribute specifies whether the specified
                                <i>Priority</i> is a relative or absolute priority.
                            ]]></comment>
              <value>Relative</value>
              <value>Absolute</value>
              <default>Relative</default>
            </attributeEnum>
          </leafInt>
          <leafEnum name="Class" minOccurrences="1" maxOccurrences="1">
            <comment><![CDATA[
                            This element specifies the thread scheduling class that will be used by the transmitter
                            thread of the Discovery Channel. The user may need the appropriate privileges from the
                            underlying operating system to be able to assign some of the privileged scheduling classes.
                        ]]></comment>
            <value>Timeshare</value>
            <value>Realtime</value>
            <value>Default</value>
            <default>Default</default>
          </leafEnum>
        </element>
        <leafInt name="Interval" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        This element describes the interval at which remote nodes will expect heartbeats from this node.
                    ]]></comment>
          <minimum>100</minimum>
          <default>1000</default>
        </leafInt>
        <leafFloat name="SafetyFactor" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        The SafetyFactor is used to set a margin on the discovery sending. This avoids tight timing issues.
                    ]]></comment>
          <minimum>0.2</minimum>
          <maximum>1.0</maximum>
          <default>0.9</default>
        </leafFloat>
        <leafInt name="SalvoSize" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        During starting and stopping, discovery messages are sent at higher frequency. This SalvoSize sets
                        the number of messages to send during these phases.
                    ]]></comment>
          <minimum>1</minimum>
          <default>3</default>
        </leafInt>
      </element>
      <element name="Receiving" minOccurrences="0" maxOccurrences="1">
        <leafBoolean name="CrcCheck" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                       In order to protect OpenSplice network packets from malicious attack the CrcCheck(cyclic redundancy check) configuration item has been added.
                       CRCs are specifically designed to protect against common types of errors on communication channels.
                       When enabled the integrity of delivered network packets from one DDS process to another is assured.
                       There is a small performance cost using this feature due to the addtional overhead of carrying out the crc calculation.

                       When the sending side is enabled the network packet will contain a valid crc field.
                    ]]></comment>
          <default>false</default>
        </leafBoolean>
        <element name="Scheduling" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the scheduling policies used to control the receiver thread
                        of the Discovery Channel.
                    ]]></comment>
          <leafInt name="Priority" minOccurrences="1" maxOccurrences="1">
            <comment><![CDATA[
                            This element specifies the thread priority that will be used by the receiver thread
                            of the Discovery Channel. Only priorities that are supported by the underlying operating
                            system can be assigned to this element. The user may need special privileges from the
                            underlying operating system to be able to assign some of the privileged priorities.
                        ]]></comment>
            <default>0</default>
            <attributeEnum name="priority_kind" required="false">
              <comment><![CDATA[
                                This attribute specifies whether the specified
                                <i>Priority</i> is a relative or absolute priority.
                            ]]></comment>
              <value>Relative</value>
              <value>Absolute</value>
              <default>Relative</default>
            </attributeEnum>
          </leafInt>
          <leafEnum name="Class" minOccurrences="1" maxOccurrences="1">
            <comment><![CDATA[
                            This element specifies the thread scheduling class that will be used by the receiver
                            thread of the Discovery Channel. The user may need the appropriate privileges from the
                            underlying operating system to be able to assign some of the privileged scheduling classes.
                        ]]></comment>
            <value>Timeshare</value>
            <value>Realtime</value>
            <value>Default</value>
            <default>Default</default>
          </leafEnum>
        </element>
        <leafInt name="DeathDetectionCount" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies how often a heartbeat from a remote node must miss its Interval before
                        that remote node is considered dead.
                    ]]></comment>
          <minimum>1</minimum>
          <default>6</default>
        </leafInt>
        <leafSize name="ReceiveBufferSize" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        The UDP receive buffer of the Discovery Channel socket is set to the value given. If
                        many message are lost, the receive buffer size has to be increased.
                    ]]></comment>
          <minimum>1</minimum>
          <default>1000000</default>
        </leafSize>
      </element>
    </element>
    <element name="Tracing" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                This element controls the amount and type of information that is written into the
                tracing log by the Networking Service. This is useful to track the Networking Service
                during application development. In the runtime system it should be turned off.
            ]]></comment>
      <leafString name="OutputFile" minOccurrences="1" maxOccurrences="1">
        <comment><![CDATA[
                    This option specifies where the logging is printed to. Note that “stdout” is considered a
                    legal value that represents “standard out”.  The default value is an empty string,
                    indicating that the tracing log will be written to standard out.
                ]]></comment>
        <maxLength>0</maxLength>
        <default>networking.log</default>
      </leafString>
      <leafBoolean name="Timestamps" minOccurrences="1" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies whether the logging must contain timestamps.
                ]]></comment>
        <attributeBoolean name="absolute" required="false">
          <comment><![CDATA[
                        This attribute specifies whether the timestamps are absolute
                        or relative to the startup time of the service.
                    ]]></comment>
          <default>true</default>
        </attributeBoolean>
        <default>true</default>
      </leafBoolean>
      <element name="Categories" minOccurrences="1" maxOccurrences="1">
        <comment><![CDATA[
                    This element contains the logging properties for various networking categories.
                ]]></comment>
        <leafInt name="Default" minOccurrences="1" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the tracing level used for categories that are not
                        explicitly specified. Level 0 indicates no tracing, level 6 indicates the
                        most detailed level of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Configuration" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Configuration</i> category.
                        This includes the processing of all NetworkService parameters in the config file.
                        Level 0 indicates no tracing, level 6 indicates the most detailed level
                        of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Construction" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Construction</i> category.
                        This includes the creation of all internal processing entities.
                        Level 0 indicates no tracing, level 6 indicates the most detailed level
                        of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Destruction" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Destruction</i> category.
                        This includes the destruction of all internal processing entities when the
                        NetworkService terminates. Level 0 indicates no tracing, level 6 indicates the
                        most detailed level of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Mainloop" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Mainloop</i> category.
                        This includes information about each of the threads spawned by the NetworkService.
                        Level 0 indicates no tracing, level 6 indicates the most detailed level
                        of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Groups" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Groups</i> category.
                        This includes the management of local groups (partition-topic combinations).
                        Level 0 indicates no tracing, level 6 indicates the most detailed level
                        of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Send" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Send</i> category.
                        This includes information about outgoing data.
                        Level 0 indicates no tracing, level 6 indicates the most detailed level
                        of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Receive" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Receive</i> category.
                        This includes information about incoming data.
                        Level 0 indicates no tracing, level 6 indicates the most detailed level
                        of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Test" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Test</i> category.
                        This is a reserved category used for testing purposes.
                        Level 0 indicates no tracing, level 6 indicates the most detailed level
                        of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Discovery" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Discovery</i> category.
                        This includes all activity related to the discovery channel.
                        Level 0 indicates no tracing, level 6 indicates the most detailed level
                        of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
      </element>
    </element>
  </element>
  <element name="DDSI2Service" minOccurrences="0" maxOccurrences="0">
    <comment><![CDATA[
               The DDSI2 Networking configuration expects a root element named
               OpenSplice/DDSI2Service. Within this root element, the networking
               daemon will look for several child-elements.
      ]]></comment>
    <attributeString name="name" required="true">
      <comment><![CDATA[
                 This attribute identifies the configuration for the DDSI2
                 Networking Service. Multiple Networking Service configurations
                 can be specified in one single resource. The actual applicable
                 configuration is determined by the value of the name attribute,
                 which must match the specified under the element
                 OpenSplice/Domain/Service[@name] in the Domain Service configuration.
        ]]></comment>
      <maxLength>0</maxLength>
      <default>ddsi2</default>
    </attributeString>
    <element name="General" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                 The General element describes the networking service as a whole.
        ]]></comment>
      <leafString name="NetworkInterfaceAddress" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                   <p>This element specifies which network interface card should
                   be used.</p>
                   <p>Every DDSI2 Networking Service is bound to only one network
                   interface card (NIC). The card can be uniquely identified by
                   its corresponding IP address. If the value "AUTO" is entered
                   here, the OpenSplice middleware will try to look up an
                   interface that has the required capabilities.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>AUTO</default>
      </leafString>
      <leafBoolean name="AllowMulticast" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                   <p>This element specifies whether the DDSI2 service may use
                   IP multicasting.</p>
                   <p>If set to FALSE, no multicast packets will ever be sent by
                   the service, but it will still listen to multicast packets
                   from other nodes. Generally speaking, the peer nodes will have
                   to be listed as DDSI2Service/Discovery/Peer elements, but
                   the service will automatically discover multicasting peers
                   that advertise a unicast address.</p>
                   <p>If set to TRUE, multicast is used preferentially. If any Peer
                   elements are given, they will explicitly be included in the
                   discovery by means of packets sent to the specified addresses.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>TRUE</default>
      </leafBoolean>
      <leafBoolean name="DontRoute" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                   </p>This element specifies whether the DDSI2 service
                   disable routing of IP packets.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>FALSE</default>
      </leafBoolean>
      <leafBoolean name="EnableMulticastLoopback" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                   <p>This element specifies whether the DDSI2 service will allow
                   IP multicast packets within the node to be visible to all
                   DDSI participants in the node, including itself.</p>
                   <p>It must be TRUE for intra-node multicast communications, but
                   if a node runs only a single OpenSplice DDSI2 service and does
                   not host any other DDSI-capable programs, it may be set to
                   FALSE for improved performance.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>TRUE</default>
      </leafBoolean>
      <leafBoolean name="CoexistWithNativeNetworking" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                   <p>This element specifies whether the OpenSplice DDSI2Service can
                   operate in conjunction with the OpenSplice NetworkService.</p>
                   <p>If FALSE, the DDSI2 service will take care of all
                   communications, including those between OpenSplice nodes.</p>
                   <p>If TRUE, the DDSI2 service will only communicate with DDS
                   implementations other than OpenSplice. In this case the
                   NetworkService must be configured as well.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>FALSE</default>
      </leafBoolean>
      <leafInt name="StartupModeDuration" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                   <p>This element specifies how long the DDSI2 remains in its
                   "startup" mode, in milliseconds.</p>

                   <p>While in "startup" mode all data published on the
                   local node, except volatile best-effort data, is
                   retained as-if it were transient-local data, so
                   that existing readers on remote nodes can get the
                   data even though discovering them takes some time.</p>

                   <p>Once the system is stable, the DDSI2 service keeps
                   track of the existence of remote readers whether or
                   not matching writers exist locally, avoiding this
                   discovery delay, and thereby ensuring this is
                   merely a node startup issue.</p>

                   <p>Setting StartupModeDuration to 0 will disable it.</p>
          ]]></comment>
        <minimum>0</minimum>
        <maximum>60000</maximum>
        <default>2000</default>
      </leafInt>
    </element>
    <element name="Compatibility" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                 The Compatibility elements allows specifying various settings
                 related to compatability with standards and with other DDSI
                 implementations.
        ]]></comment>
      <leafEnum name="StandardsConformance" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                   <p>Selects the level of standards conformance of this
                   instance of the DDSI2 Service. Stricter conformance
                   typically means less interoperability with other
                   implementations.</p>

                   </p>Currently three modes are defined:
                   <ul>
                   <li><b>pedantic</b> very strictly conforms to the
                     specification, ultimately for compliancy testing,
                     but currently of little value because it adheres
                     even to what will most likely turn out to be
                     editing errors in the DDSI standard.  Arguably, as
                     long as no errata have been published it is the
                     current text that is in effect, and that is what
                     pedantic currently does.</li>

                   <li><b>strict</b> takes a slightly less strict view of the
                     standard than pedantic: it follows the established
                     behaviour where the standard is obviously in error.</li>

                   <li><b>lax</b> simply tries to provide the smoothest possible
                     interoperability, anticipating future revisions of
                     elements in the standard in areas that other
                     implementations do not adhere to, even though there
                     is no good reason not to.</li>
                   </ul></p>

                   <p>The default setting is "lax".</p>
          ]]></comment>
        <value>pedantic</value>
        <value>strict</value>
        <value>lax</value>
        <default>lax</default>
      </leafEnum>
      <leafBoolean name="ExplicitlyPublishQosSetToDefault" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                   <p>This option specifies whether QoS settings set to
                   default values are explicitly published in the
                   discovery protocol. Implementations are to use the
                   default value for QoS settings not published, which
                   allows a significant reduction of the amount of
                   data that needs to be exchanged for the discovery
                   protocol, but this requires all implementations to
                   adhere to the default values specified by the
                   specifications.</p>

                   <p>When interoperability is required with an
                   implementation that does not follow the
                   specifications in this regard, setting this option
                   to true will help.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafBoolean name="ManySocketsMode" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                   <p>This option specifies whether a network socket will
                   be created for each domain participant on a
                   host. The specification seems to assume that each
                   participant has a unique address, and setting this
                   option will ensure this to be the case. This is the
                   default.</p>

                   <p>Disabling it slightly improves performance and
                   reduces network traffic somewhat.</p>
          ]]></comment>
        <default>true</default>
      </leafBoolean>
      <leafInt name="AckNackNumbitsEmptySet" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                     <p>This element governs the representation of an
                     acknowledgement message that does not also
                     negatively-acknowledge some samples. If set to 0,
                     the generated acknowledgements have an invalid
                     form and will be reject by strict mode, but
                     several other implementation require this setting
                     for smooth interoperation.</p>

                     <p>If set to 1, all acknowledgements sent by DDSI2
                     adhere the form of acknowledgement messages
                     allowed by the standard, but this causes problems
                     when interoperating with these other
                     implementations.</p>

                     <p>The default is 1 in the strict and pedantic
                     standards conformance modes, 0 in lax mode.</p>
           ]]></comment>
        <minimum>0</minimum>
        <maximum>1</maximum>
        <default>1</default>
      </leafInt>
      <leafBoolean name="RespondToRtiInitZeroAckWithInvalidHeartbeat" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                   <p>This option allows a closer mimicking of the
                   behaviour of some other DDSI implementations,
                   albeit at the cost of generating even more invalid
                   messages. Setting it to true ensures a Heartbeat
                   can be sent at any time when a remote node requests
                   one, setting it to false delays it until a valid
                   one can be sent.</p>

                   <p>The latter is fully compliant with the
                   specification, and no adverse effects have been
                   observed. It is the default.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
    </element>
    <element name="Discovery" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                 The Discovery element allows specifying various parameters related
                 to the discovery of peers.
        ]]></comment>
      <leafInt name="DomainId" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                   This element specifies the DDSI domain id in which this
                   instance of the DDSI2Service participates.
          ]]></comment>
        <minimum>0</minimum>
        <maximum>229</maximum>
        <default>0</default>
      </leafInt>
      <leafString name="ParticipantIndex" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                   <p>This element specifies the DDSI participant id used by this
                   instance of the DDSI2 service for discovery purposes. Only one
                   such participant id is used, independent of the number of
                   actual DomainParticipants on the node.</p>

                   <p>It is either "AUTO" (the default), which will attempt to
                   automatically determine an available participant index, or a
                   non-negative integer less than 120.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>AUTO</default>
      </leafString>
      <leafString name="Peer" minOccurrences="0" maxOccurrences="0">
        <comment><![CDATA[
                   This element specifies an IP address to which discovery
                   packets must be sent, in addition to the default multicast
                   address if multicasting is enabled (see
                   DDSI2Service/General/AllowMulticast). Multiple Peers may be specified.
          ]]></comment>
        <maxLength>0</maxLength>
        <default></default>
      </leafString>
      <element name="Port" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                   The Port element allows specifying various
                   parameters related to the port numbers used for
                   discovery. These all have default values specified
                   by the DDSI 2.1 specification.
          ]]></comment>
        <leafInt name="Base" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                     This element specifies the base port number
                     (refer to the DDSI 2.1 specification, section
                     9.6.1, constant PB).
            ]]></comment>
          <minimum>1</minimum>
          <maximum>65535</maximum>
          <default>7400</default>
        </leafInt>
        <leafInt name="DomainGain" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                     This element specifies the domain gain,
                     relating domain ids to sets of port numbers
                     (refer to the DDSI 2.1 specification, section
                     9.6.1, constant DG).
            ]]></comment>
          <default>250</default>
        </leafInt>
        <leafInt name="ParticipantGain" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                     This element specifies the participant gain,
                     relating participant index to sets of port
                     numbers (refer to the DDSI 2.1 specification,
                     section 9.6.1, constant PG).
            ]]></comment>
          <default>2</default>
        </leafInt>
        <leafInt name="MulticastMetaOffset" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                     This element specifies the port number for
                     multicast meta traffic (refer to the DDSI 2.1
                     specification, section 9.6.1, constant d0).
            ]]></comment>
          <default>0</default>
        </leafInt>
        <leafInt name="UnicastMetaOffset" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                     This element specifies the port number for
                     multicast meta traffic (refer to the DDSI 2.1
                     specification, section 9.6.1, constant d1).
            ]]></comment>
          <default>0</default>
        </leafInt>
        <leafInt name="MulticastDataOffset" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                     This element specifies the port number for
                     multicast meta traffic (refer to the DDSI 2.1
                     specification, section 9.6.1, constant d2).
            ]]></comment>
          <default>1</default>
        </leafInt>
        <leafInt name="UnicastDataOffset" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[
                     This element specifies the port number for
                     multicast meta traffic (refer to the DDSI 2.1
                     specification, section 9.6.1, constant d3).
            ]]></comment>
          <default>11</default>
        </leafInt>
      </element>
    </element>
    <element name="Tracing" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                 This element controls the amount and type of information that is
                 written into the tracing log by the DDSI service. This is useful
                 to track the DDSI service during application development. In the
                 runtime system it should be turned off.
        ]]></comment>
      <leafEnum name="Verbosity" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                   This element specifies the verbosity level of the logging.
          ]]></comment>
        <value>severe</value>
        <value>warning</value>
        <value>info</value>
        <value>config</value>
        <value>fine</value>
        <value>finer</value>
        <value>finest</value>
        <default>warning</default>
      </leafEnum>
      <leafString name="OutputFile" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                   This option specifies where the logging is printed to.
          ]]></comment>
        <maxLength>0</maxLength>
        <default>ddsi-tracing-output.log</default>
      </leafString>
      <leafBoolean name="AppendToFile" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                   This option specifies whether the output is to be appended to
                   an existing log file.
          ]]></comment>
        <default>true</default>
      </leafBoolean>
      <leafBoolean name="Timestamps" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                   This element specifies whether the logging must contain timestamps.
          ]]></comment>
        <attributeBoolean name="absolute" required="false">
          <comment><![CDATA[
                     This attribute specifies whether the timestamps are absolute or
                     relative to the startup time of the service.
            ]]></comment>
          <default>true</default>
        </attributeBoolean>
        <default>true</default>
      </leafBoolean>
    </element>
  </element>
  <element name="TunerService" minOccurrences="0" maxOccurrences="0">
    <comment><![CDATA[
            The purpose of the control & monitoring SOAP service is to provide
            remote access to the node for OpenSplice tooling.
        ]]></comment>
    <attributeString name="name" required="true">
      <comment><![CDATA[
                This attribute identifies a configuration for the Tuner Service by name.
                Multiple Tuner Service configurations can be specified in one single
                resource file. The actual applicable configuration is determined by the
                value of the <i>name</i> attribute, which must match the one specified
                under the <i>OpenSplice/Domain/Service[@name]</i> in the configuration of
                the Domain Service.
            ]]></comment>
      <default>cmsoap</default>
      <maxLength>0</maxLength>
    </attributeString>
    <element name="Watchdog" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                This element controls the characteristics of the Watchdog thread.
            ]]></comment>
      <element name="Scheduling" minOccurrences="1" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies the type of OS scheduling class will be
                    used by the thread that announces its liveliness periodically.
                ]]></comment>
        <leafInt name="Priority" minOccurrences="1" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the thread priority that will be used by the
                        watchdog thread. Only priorities that are supported by the
                        underlying operating system can be assigned to this element.
                        The user may need special privileges from the underlying operating
                        system to be able to assign some of the privileged priorities.
                    ]]></comment>
          <default>0</default>
          <attributeEnum name="priority_kind" required="false">
            <comment><![CDATA[
                            This attribute specifies whether the specified
                            Priority is a relative or absolute priority.
                        ]]></comment>
            <value>Relative</value>
            <value>Absolute</value>
            <default>Relative</default>
          </attributeEnum>
        </leafInt>
        <leafEnum name="Class" minOccurrences="1" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the thread scheduling class that will be used by
                        the watchdog thread. The user may need the appropriate privileges from
                        the underlying operating system to be able to assign some of the
                        privileged scheduling classes.
                    ]]></comment>
          <value>Timeshare</value>
          <value>Realtime</value>
          <value>Default</value>
          <default>Default</default>
        </leafEnum>
      </element>
    </element>
    <element name="Server" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                This element determines the serverside behaviour of the Tuner service.
            ]]></comment>
      <leafInt name="PortNr" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element determines the port number that the TunerService
                    will use to listen for incoming requests. This port number
                    must also be used by the Tuner tool to connect to this service.
                ]]></comment>
        <minimum>1</minimum>
        <maximum>65535</maximum>
        <default>8000</default>
      </leafInt>
      <leafInt name="Backlog" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies the maximum number of client requests
                    that are allowed to be waiting when the maximum number of
                    concurrent requests is reached.
                ]]></comment>
        <minimum>0</minimum>
        <default>5</default>
      </leafInt>
      <leafEnum name="Verbosity" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies the verbosity level of the logging of the service.
                ]]></comment>
        <value>0</value>
        <value>1</value>
        <value>2</value>
        <value>3</value>
        <value>4</value>
        <value>5</value>
        <default>0</default>
      </leafEnum>
    </element>
    <element name="Client" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                This element determines how the Tuner service handles the
                incoming client connections.
            ]]></comment>
      <leafInt name="MaxClients" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element determines the maximum allowed number of clients
                    that are allowed to be concurrently connected to the Tuner
                    service. Clients are identified by IP-address.
                ]]></comment>
        <minimum>1</minimum>
        <default>2</default>
      </leafInt>
      <leafInt name="MaxThreadsPerClient" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies the maximum number of threads that
                    the Tuner service will create for one specific client.
                    The number of threads determines the maximum number of
                    concurrent requests for a client.
                ]]></comment>
        <minimum>1</minimum>
        <default>2</default>
      </leafInt>
      <leafFloat name="LeasePeriod" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element determines the maximum amount of time in which a
                    connected client must update its lease. This can be done
                    implicitly by calling any function or explicitly by calling
                    the update lease function. The Tuner tool will automatically
                    update its lease when it is connected to the Tuner service.
                    This ensures that all resources are cleaned up automatically
                    if the client fails to update its lease within this period.
                ]]></comment>
        <minimum>10.0</minimum>
        <default>15.0</default>
      </leafFloat>
      <element name="Scheduling" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies the scheduling policies used to control the threads
                    that handle the client requests to the Tuner Service.
                ]]></comment>
        <leafInt name="Priority" minOccurrences="1" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the thread priority that will be used by the threads that handle
                        client requests to the Tuner Service. Only priorities that are supported by the underlying
                        operating system can be assigned to this element. The user may need special privileges from
                        the underlying operating system to be able to assign some of the privileged priorities.
                    ]]></comment>
          <default>0</default>
          <attributeEnum name="priority_kind" required="false">
            <comment><![CDATA[
                            This attribute specifies whether the specified <i>Priority</i> is a relative
                            or absolute priority.
                        ]]></comment>
            <value>Relative</value>
            <value>Absolute</value>
            <default>Relative</default>
          </attributeEnum>
        </leafInt>
        <leafEnum name="Class" minOccurrences="1" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the thread scheduling class that will be used by the threads that
                        handle client requests to the Tuner Service. The user may need the appropriate privileges
                        from the underlying operating system to be able to assign some of the privileged scheduling
                        classes.
                    ]]></comment>
          <value>Timeshare</value>
          <value>Realtime</value>
          <value>Default</value>
          <default>Default</default>
        </leafEnum>
      </element>
    </element>
    <element name="GarbageCollector" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                This element specifies the behaviour of the garbage collection
                thread of the service.
            ]]></comment>
      <element name="Scheduling" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies the scheduling policies used to control the garbagage
                    collection thread of the Tuner Service.
                ]]></comment>
        <leafInt name="Priority" minOccurrences="1" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the thread priority that will be used by the garbage collection
                        thread of the Tuner Service. Only priorities that are supported by the underlying
                        operating system can be assigned to this element. The user may need special privileges from
                        the underlying operating system to be able to assign some of the privileged priorities.
                    ]]></comment>
          <default>0</default>
          <attributeEnum name="priority_kind" required="false">
            <comment><![CDATA[
                            This attribute specifies whether the specified <i>Priority</i> is a relative
                            or absolute priority.
                        ]]></comment>
            <value>Relative</value>
            <value>Absolute</value>
            <default>Relative</default>
          </attributeEnum>
        </leafInt>
        <leafEnum name="Class" minOccurrences="1" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the thread scheduling class that will be used by the garbage
                        collection thread of the Tuner Service. The user may need the appropriate privileges
                        from the underlying operating system to be able to assign some of the privileged
                        scheduling classes.
                    ]]></comment>
          <value>Timeshare</value>
          <value>Realtime</value>
          <value>Default</value>
          <default>Default</default>
        </leafEnum>
      </element>
    </element>
    <element name="LeaseManagement" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                This element specifies the behaviour of the lease management
                thread of the Tuner Service.
            ]]></comment>
      <element name="Scheduling" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies the scheduling policies used to control the lease
                    management thread of the Tuner Service.
                ]]></comment>
        <leafInt name="Priority" minOccurrences="1" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the thread priority that will be used by the lease management
                        thread of the Tuner Service. Only priorities that are supported by the underlying
                        operating system can be assigned to this element. The user may need special privileges from
                        the underlying operating system to be able to assign some of the privileged priorities.
                    ]]></comment>
          <default>0</default>
          <attributeEnum name="priority_kind" required="false">
            <comment><![CDATA[
                            This attribute specifies whether the specified <i>Priority</i> is a relative
                            or absolute priority.
                        ]]></comment>
            <value>Relative</value>
            <value>Absolute</value>
            <default>Relative</default>
          </attributeEnum>
        </leafInt>
        <leafEnum name="Class" minOccurrences="1" maxOccurrences="1">
          <comment><![CDATA[
                        This element specifies the thread scheduling class that will be used by the lease
                        management thread of the Tuner Service. The user may need the appropriate privileges
                        from the underlying operating system to be able to assign some of the privileged
                        scheduling classes.
                    ]]></comment>
          <value>Timeshare</value>
          <value>Realtime</value>
          <value>Default</value>
          <default>Default</default>
        </leafEnum>
      </element>
    </element>
  </element>
  <element name="DbmsConnectService" minOccurrences="0" maxOccurrences="0">
    <comment><![CDATA[
               The DbmsConnect Service configuration is responsible for DDS to DBMS bridging
               and expects a root element named <i>OpenSplice/DbmsConnectService</i>. Within
               this root element, the DbmsConnect Service will look for several child-elements.
               Each of these is listed and explained.
           ]]></comment>
    <attributeString name="name" required="true">
      <comment><![CDATA[
                This attribute identifies the configuration for the DBMS connect service by
                name. Multiple DBMS connect service configurations can be specified in one
                single resource file. The actual applicable configuration is determined by
                the value of the name attribute, which must match the one specified under the
                <i>OpenSplice/Domain/Service[@name]</i> in the configuration of
                the DomainService.
            ]]></comment>
      <maxLength>0</maxLength>
      <default>dbmsconnect</default>
    </attributeString>
    <element name="DdsToDbms" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                This element specifies the configuration properties concerning DDS to DBMS bridging.
            ]]></comment>
      <attributeBoolean name="replication_mode" required="false">
        <comment><![CDATA[
                    <p>This attribute specifies the default replication mode for
                    all NameSpaces in the <i>DdsToDbms</i> element.</p>
                    <p>When replicating databases through DDS, the <i>NameSpace</i>
                    elements in the <i>DbmsToDds</i> and <i>DdsToDbms</i> elements
                    map a Table and Topic circularly. To prevent data-modifications
                    from continuously cascading, modifications made by the
                    DBMSConnect service itself should not trigger new updates
                    in the DBMS nor in the DDS.</p>
                    <p>In replication mode, the DBMS-connect service ignores
                    samples that were published by itself. (Currently that means
                    that everything that is published on the same node as the
                    DBMSConnect Service is considered to be of DBMSConnect
                    origin and therefore ignored). That way, replication of
                    changes that were copied from Dbms to DDS back into Dbms
                    is avoided.</p>
                    <p><b>WARNING</b>: This setting does not avoid replication
                    of changes that were copied from DDS to Dbms back into DDS.
                    For that purpose, the <i>replication_user</i> attribute of the
                    <i>DbmsToDds</i> or <i>DbmsToDds/NameSpace</i> elements should
                    be set appropriately as well!</p>
                ]]></comment>
        <default>FALSE</default>
      </attributeBoolean>
      <element name="NameSpace" minOccurrences="1" maxOccurrences="0">
        <comment><![CDATA[
                    This element specifies the responsibilities of the service
                    concerning the bridging of particular data from DDS to DBMS.
                     At least one <i>NameSpace</i> element has to be present in
                     a <i>DdsToDbms</i> element.
                ]]></comment>
        <attributeString name="name" required="false">
          <comment><![CDATA[
                        The name of the namespace. If not specified, the namespace
                        will be named "(nameless)".
                    ]]></comment>
          <maxLength>0</maxLength>
          <default>(nameless)</default>
        </attributeString>
        <attributeString name="odbc" required="false">
          <comment><![CDATA[
                        <p>The service dynamically loads an ODBC library at runtime. This attribute
                        specifies the name of the ODBC library to be loaded. Platform specific
                        pre- and postfixes and extensions are automatically added.</p>
                        <p>If this attribute is not provided, the service will attempt to load the
                        generic ODBC library. The resulting behaviour is dependent on the platform
                        on which the DbmsConnect Service is running.</p>
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <attributeString name="partition" required="false">
          <comment><![CDATA[
                        <p>This attribute specifies an expression that represents one or more DDS
                        partitions. It is allowed to use wildcards in the expression: a '*'
                        represents any sequence of characters and a '?' represents one
                        single character.</p>
                        <p>This expression is used to specify the DDS partition(s) from which
                        DDS samples must be 'bridged' to the DBMS domain.</p>
                    ]]></comment>
          <maxLength>0</maxLength>
          <default>*</default>
        </attributeString>
        <attributeString name="topic" required="false">
          <comment><![CDATA[
                        <p>This attribute specifies an expression that represents one or more DDS
                        topic names. It is allowed to use wildcards in the expression: a '*'
                        represents any sequence of characters and a '?' represents one
                        single character.</p>
                        <p>This expression is used to specify the topics from which DDS
                        samples must be ‘bridged’ to the DBMS domain.  For every matching
                        topic encountered in one or more of the specified partitions, it
                        creates a separate table in the DBMS. The table name will match that
                        of the topic, unless specified otherwise in the <i>table</i> attribute
                        of a <i>Mapping</i> element.</p>
                    ]]></comment>
          <maxLength>0</maxLength>
          <default>*</default>
        </attributeString>
        <attributeFloat name="update_frequency" required="false">
          <comment><![CDATA[
                        This attribute specifies the frequency (in Hz) at which the service
                        will update the DBMS domain with DDS data. By default, it is 0.0Hz
                        which means it is done event based (every time new DDS data arrives).
                    ]]></comment>
          <minimum>0.0</minimum>
          <default>0.0</default>
        </attributeFloat>
        <attributeString name="dsn" required="true">
          <comment><![CDATA[
                        Represents the ODBC Data Source Name, that represents the DBMS where
                        the service must bridge the DDS data to.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <attributeString name="usr" required="true">
          <comment><![CDATA[
                        Represents the user name that is used when connecting to the DBMS.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <attributeString name="pwd" required="true">
          <comment><![CDATA[
                        Represents the password that is used when connecting to the DBMS.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <attributeString name="schema" required="false">
          <comment><![CDATA[
                        Represents the schema that is used when communicating with the DBMS.
                        The exact schema content may be dependent on the DBMS that is being
                        used, so consult your DBMS documentation for more details on this subject.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <attributeString name="catalog" required="false">
          <comment><![CDATA[
                        Represents the catalog that is used when communicating with the DBMS.
                        The exact catalog content may be dependent on the DBMS that is being
                        used, so consult your DBMS documentation for more details on this subject.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <attributeBoolean name="replication_mode" required="false">
          <comment><![CDATA[
                        <p>This attribute specifies the replication mode for the
                        current <i>NameSpace</i> element. If not specified, the value
                        will be inherited from the <i>replication_mode</i> of the parent
                        <i>DdsToDbms</i> element, which if not explicitly specified
                        defaults to false</p>
                        <p>When replicating databases through DDS, the <i>NameSpace</i>
                        elements in the <i>DbmsToDds</i> and <i>DdsToDbms</i> elements
                        map a Table and Topic circularly. To prevent data-modifications
                        from continuously cascading, modifications made by the
                        DBMSConnect service itself should not trigger new updates
                        in the DBMS.</p>
                        <p>In replication mode, the DBMS-connect service ignores
                        samples that were published by itself. (Currently that means
                        that everything that is published on the same node as the
                        DBMSConnect Service is considered to be of DBMSConnect
                        origin and therefore ignored). That way, replication of
                        changes that were copied from Dbms to DDS back into Dbms
                        is avoided.</p>
                        <p><b>WARNING</b>: This setting does not avoid replication
                        of changes that were copied from DDS to Dbms back into DDS.
                        For that purpose, the <i>replication_user</i> attribute of the
                        <i>DbmsToDds</i> or <i>DbmsToDds/NameSpace</i> elements should
                        be set appropriately as well!</p>
                    ]]></comment>
          <default>FALSE</default>
        </attributeBoolean>
        <element name="Mapping" minOccurrences="0" maxOccurrences="0">
          <comment><![CDATA[
                            This element specifies a modification to the way that the service handles
                            a pre-configured set of data within the specified NameSpace. Its attributes
                            are used to configure the responsibilities of the service concerning the
                            bridging of data from DDS to DBMS.
                    ]]></comment>
          <attributeString name="topic" required="true">
            <comment><![CDATA[
                            This attribute specifies the name of the topic where the Mapping applies to.
                        ]]></comment>
            <maxLength>0</maxLength>
            <default/>
          </attributeString>
          <attributeString name="table" required="false">
            <comment><![CDATA[
                            This attribute specifies an alternative name for the table that
                            must be associated with the topic. By default the table name is
                            equal to the topic name.
                        ]]></comment>
            <maxLength>0</maxLength>
            <default/>
          </attributeString>
          <attributeString name="query" required="false">
            <comment><![CDATA[
                            This attribute specifies an SQL query expression. Only DDS data
                            that matches the query will be bridged to the DBMS domain. This
                            is realized by means of a DCPS query condition. The default value
                            is an empty string, representing all available samples of the
                            selected topic.
                        ]]></comment>
            <maxLength>0</maxLength>
            <default/>
          </attributeString>
          <attributeString name="filter" required="false">
            <comment><![CDATA[
                            This attribute specifies an SQL content filter. Only DDS data
                            that matches the filter will be bridged to the DBMS domain. This
                            is realized by means of a DCPS ContentFilteredTopic. The default
                            value is an empty string, representing all available samples of
                            the selected topic.
                        ]]></comment>
            <maxLength>0</maxLength>
            <default/>
          </attributeString>
        </element>
      </element>
    </element>
    <element name="DbmsToDds" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                Holds the configuration of the service concerning DBMS to DDS bridging
            ]]></comment>
      <attributeBoolean name="publish_initial_data" required="false">
        <comment><![CDATA[
                    This attribute specifies the default behaviour with respect to publishing
                    initially available data in the DBMS to the DDS for all NameSpace elements
                    in the current DbmsToDds element. If not specified, it defaults to true.
                    The value of this attribute is ignored when the corresponding
                    event_table_policy is set to NONE.
                   ]]></comment>
        <default>true</default>
      </attributeBoolean>
      <attributeEnum name="event_table_policy" required="false">
        <comment><![CDATA[
                    <p>This attribute specifies the default setting of the event table policy for all <i>NameSpace</i> elements in the current <i>DbmsToDds</i> element.</p>
                    <p>An event table (sometimes referred to as ‘change table’ or ‘shadow table’) is a support-table that is slaved to an application-table, adding some status flags that are under the control of a trigger mechanism that responds to creation/modification/ deletion events in the application-table.</p>
                    <p>The following policies are currently supported:</p>
                    <ul>
                    <li><b>FULL</b>: <i>(default)</i> An 'event table' will always be created when the service connects, and will always be deleted when the service disconnects. In this mode, the service will replace the table if it already exists.</li>
                    <li><b>LAZY</b>: An 'event table' will only be created if it is not available when the service connects, and it will not be deleted when the service disconnects.</ul>
                    <li><b>NONE</b>: An 'event table' will neither be created nor deleted by the service. For each specified <i>NameSpace</i>, the service will poll for the existence of a consistent table with a frequency specified in the coresponding <i>update_frequency</i> attribute. It will start using the table as soon as it is available. With this policy set, no initial data will be published regardless of the value of the applicable <i>publish_initial_data</i> attribute.</ul>
                    </ul>
                ]]></comment>
        <value>FULL</value>
        <value>LAZY</value>
        <value>NONE</value>
        <default>FULL</default>
      </attributeEnum>
      <attributeEnum name="trigger_policy" required="false">
        <comment><![CDATA[
                    <p>This attribute specifies the default trigger policy for all <i>NameSpace</i> elements in the current <i>DbmsToDds</i> element.</p>
                    <p>Triggers are used to to update the event table in case of creation/modification/ deletion events on the application-table. </p>
                    <p>The following policies are currently supported:</p>
                    <ul>
                    <li><b>FULL</b>: <i>(default)</i> Triggers will always be created when the service connects, and will always be deleted when the service disconnects. In this mode, the service will replace the triggers if they already exists.</li>
                    <li><b>LAZY</b>: Triggers will only be created if they are not available when the service connects, and will not be deleted when the service disconnects.</ul>
                    <li><b>NONE</b>: Triggers will neither be created nor deleted by the service. This allows you to build your own custom triggering mechanism.</ul>
                    </ul>
                ]]></comment>
        <value>FULL</value>
        <value>LAZY</value>
        <value>NONE</value>
        <default>FULL</default>
      </attributeEnum>
      <attributeString name="replication_user" required="false">
        <comment><![CDATA[
                    <p>This attribute specifies the default replication user for
                    all <i>NameSpace</i> elements in the current <i>DdsToDbms</i>
                    element.</p>
                    <p>When replicating databases through DDS, the <i>NameSpace</i>
                    elements in the <i>DbmsToDds</i> and <i>DdsToDbms</i> elements
                    map a Table and Topic circularly. To prevent data-modifications
                    from continuously cascading, modifications made by the
                    service itself should not trigger new updates in the
                    DBMS nor in the DDS.</p>
                    <p>To distinguish between DBMS updates coming from an
                    application and DBMS updates coming from DDS, an extra
                    database user (the replication user) has to be introduced
                    that differs from the application users. That way,
                    replication of changes that were copied from DDS to Dbms
                    back into DDS is avoided. The replication_user attribute
                    specifies the user name of that replication user. An empty
                    string (default value) indicates that there is no separate
                    replication user.</p>
                    <p><b>WARNING</b>: This setting does not avoid replication
                    of changes that were copied from Dbms to DDS back into Dbms.
                    For that purpose, the <i>replication_mode</i> attribute of
                    the <i>DssToDbms</i> or <i>DssToDbms/NameSpace</i> elements
                    should be set appropriately as well!</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default/>
      </attributeString>
      <element name="NameSpace" minOccurrences="1" maxOccurrences="0">
        <comment><![CDATA[
                    This element specifies the responsibilities of the service concerning
                    the bridging of data from DBMS to DDS. At least one <i>NameSpace</i>
                    element has to be present in a <i>DbmsToDds</i> element.
                ]]></comment>
        <attributeString name="name" required="false">
          <comment><![CDATA[
                        The name of the namespace. If not specified, the namespace
                        will be named "(nameless)".
                    ]]></comment>
          <maxLength>0</maxLength>
          <default>(nameless)</default>
        </attributeString>
        <attributeString name="odbc" required="false">
          <comment><![CDATA[
                        <p>The service dynamically loads an ODBC library at runtime. This attribute
                        specifies the name of the ODBC library to be loaded. Platform specific
                        pre- and postfixes and extensions are automatically added.</p>
                        <p>If this attribute is not provided, the service will attempt to load the
                        generic ODBC library. The resulting behaviour is dependent on the platform
                        on which the DbmsConnect Service is running.</p>
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <attributeString name="partition" required="false">
          <comment><![CDATA[
                        <p>This attribute specifies an expression represents one or more DDS partitions.
                        It is allowed to use wildcards in the expression: a '*' represents any
                        sequence of characters and a '?' represents one single character.</p>
                        <p>This expression is used to specify the DDS partition(s) where DBMS records
                        will be written to as DDS samples by the service.</p>
                    ]]></comment>
          <maxLength>0</maxLength>
          <default>*</default>
        </attributeString>
        <attributeString name="table" required="false">
          <comment><![CDATA[
                        <p>This attribute specifies an expression that represents one or more DBMS
                        table names.  It is allowed to use wildcards in the expression: a '*'
                        represents any sequence of characters and a '?' represents one single
                        character.</p>
                        <p>This expression is used to specify the tables from which DBMS data must
                        be 'bridged' to the DDS domain.</p>
                    ]]></comment>
          <maxLength>0</maxLength>
          <default>*</default>
        </attributeString>
        <attributeFloat name="update_frequency" required="false">
          <comment><![CDATA[
                        This attribute specifies the frequency (in Hz) at which
                        the service will update the DDS domain with DBMS data.
                        By default, it is 2.0Hz. Event-based updates are not
                        supported. If 0.0Hz is specified, the default of 2.0Hz
                        will be used.
                    ]]></comment>
          <minimum>0.0</minimum>
          <default>2.0</default>
        </attributeFloat>
        <attributeString name="dsn" required="true">
          <comment><![CDATA[
                        Represents the Data Source Name, that represents the DBMS where
                        the service must bridge the DDS data from.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <attributeString name="usr" required="true">
          <comment><![CDATA[
                        Represents the user name that is used when connecting to the DBMS.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <attributeString name="pwd" required="true">
          <comment><![CDATA[
                        Represents the password that is used when connecting to the DBMS.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <attributeBoolean name="publish_initial_data" required="false">
          <default>true</default>
          <comment><![CDATA[
                        This attribute specifies the default behaviour with respect to publishing
                        initially available data in the DBMS to the DDS for all <i>Mapping</i>
                        elements in the current <i>NameSpace</i> element. If not specified, the value
                        will be inherited from the <i>publish_initial_data</i> of the parent
                        <i>DbmsToDds</i> element, which defaults to true. The value of this attribute
                        is ignored when the corresponding <i>event_table_policy</i> is set to NONE.
                       ]]></comment>
        </attributeBoolean>
        <attributeBoolean name="force_key_equality" required="false">
          <default>true</default>
          <comment><![CDATA[
                        This attribute specifies the default setting for <i>Mapping</i> elements
                        in the current <i>NameSpace</i> element with regard to the enforcement of
                        key equality between table and topic definitions. If true, key definitions
                        from the table and topic must match, otherwise key definitions may differ.
                       ]]></comment>
        </attributeBoolean>
        <attributeEnum name="event_table_policy" required="false">
          <comment><![CDATA[
                        <p>This attribute specifies the default setting of the event table policy for all <i>Mapping</i> elements in the current <i>NameSpace</i> element. If not specified, the value will be inherited from the <i>event_table_policy</i> of the parent <i>DbmsToDds</i> element, which if not explicitly specified defaults to FULL.</p>
                        <p>An event table (sometimes referred to as ‘change table’ or ‘shadow table’) is a support-table that is slaved to an application-table, adding some status flags that are under the control of a trigger mechanism that responds to creation/modification/ deletion events in the application-table.</p>
                        <p>The following policies are currently supported:</p>
                        <ul>
                        <li><b>FULL</b>: An 'event table' will always be created when the service connects, and will always be deleted when the service disconnects. In this mode, the service will replace the table if it already exists.</li>
                        <li><b>LAZY</b>: An 'event table' will only be created if it is not available when the service connects, and it will not be deleted when the service disconnects.</ul>
                        <li><b>NONE</b>: An 'event table' will neither be created nor deleted by the service. For each specified <i>NameSpace</i>, the service will poll for the existence of a consistent table with a frequency specified in the coresponding <i>update_frequency</i> attribute. It will start using the table as soon as it is available. With this policy set, no initial data will be published regardless of the value of the applicable <i>publish_initial_data</i> attribute.</ul>
                        </ul>
                    ]]></comment>
          <value>FULL</value>
          <value>LAZY</value>
          <value>NONE</value>
          <default>FULL</default>
        </attributeEnum>
        <attributeEnum name="trigger_policy" required="false">
          <comment><![CDATA[
                        <p>This attribute specifies the default trigger policy for all <i>Mapping</i> elements in the current <i>NameSpace</i> element. If not specified, the value will be inherited from the <i>trigger_policy</i> of the parent <i>DbmsToDds</i> element, which if not explicitly specified defaults to FULL.</p>
                        <p>Triggers are used to to update the event table in case of creation/modification/ deletion events on the application-table.</p>
                        <p>The following policies are currently supported:</p>
                        <ul>
                        <li><b>FULL</b>: <i>(default)</i> Triggers will always be created when the service connects, and will always be deleted when the service disconnects. In this mode, the service will replace the triggers if they already exists.</li>
                        <li><b>LAZY</b>: Triggers will only be created if they are not available when the service connects, and will not be deleted when the service disconnects.</ul>
                        <li><b>NONE</b>: Triggers will neither be created nor deleted by the service. This allows you to build your own custom triggering mechanism.</ul>
                        </ul>
                   ]]></comment>
          <value>FULL</value>
          <value>LAZY</value>
          <value>NONE</value>
          <default>FULL</default>
        </attributeEnum>
        <attributeString name="schema" required="false">
          <comment><![CDATA[
                        Represents the schema that is used when communicating with the DBMS.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <attributeString name="catalog" required="false">
          <comment><![CDATA[
                        Represents the catalog that is used when communicating with the DBMS.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <attributeString name="replication_user" required="false">
          <comment><![CDATA[
                        <p>This attribute specifies the default replication user for
                        all <i>Mapping</i> elements in the current <i>NameSpace</i>
                        element. If not specified, the value will be inherited from
                        the <i>replication_user</i> of the parent <i>DbmsToDds</i> element,
                        which by default has no separate replication user specified.</p>
                        <p>When replicating databases through DDS, the <i>NameSpace</i>
                        elements in the <i>DbmsToDds</i> and <i>DdsToDbms</i> elements
                        map a Table and Topic circularly. To prevent data-modifications
                        from continuously cascading, modifications made by the
                        service itself should not trigger new updates in the
                        DBMS nor in the DDS.</p>
                        <p>To distinguish between DBMS updates coming from an
                        application and DBMS updates coming from DDS, an extra
                        database user (the replication user) has to be introduced
                        that differs from the application users. That way,
                        replication of changes that were copied from DDS to Dbms
                        back into DDS is avoided. The replication_user attribute
                        specifies the user name of that replication user. An empty
                        string (default value) indicates that there is no separate
                        replication user.</p>
                        <p><b>WARNING</b>: This setting does not avoid replication
                        of changes that were copied from Dbms to DDS back into Dbms.
                        For that purpose, the <i>replication_mode</i> attribute of
                        the <i>DssToDbms</i> or <i>DssToDbms/NameSpace</i> elements
                        should be set appropriately as well!</p>
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <element name="Mapping" minOccurrences="0" maxOccurrences="0">
          <comment><![CDATA[
                           This element specifies a modification to the way that the service handles
                           a pre-configured set of data within the specified NameSpace. Its attributes
                           are used to configure the responsibilities of the service concerning the
                           bridging of data from DBMS to DDS
                    ]]></comment>
          <attributeString name="table" required="true">
            <comment><![CDATA[
                            This attribute specifies the name of the table where the Mapping applies to.
                        ]]></comment>
            <maxLength>0</maxLength>
            <default/>
          </attributeString>
          <attributeString name="topic" required="false">
            <comment><![CDATA[
                            This attribute specifies an alternative name for the topic that
                            must be associated with the table. By default the topic name is
                            equal to the table name.
                        ]]></comment>
            <maxLength>0</maxLength>
            <default/>
          </attributeString>
          <attributeString name="query" required="false">
            <comment><![CDATA[
                            Optional DBMS query expression. Only DBMS data that matches the
                            query will be bridged to the DDS domain. This is realized by
                            means of a SQL query. The default value is an empty string,
                            representing all available data in the selected table.
                        ]]></comment>
            <maxLength>0</maxLength>
            <default/>
          </attributeString>
          <attributeBoolean name="publish_initial_data" required="false">
            <default>true</default>
            <comment><![CDATA[
                        This attribute specifies the behaviour with respect to publishing the
                        initially available data specified in the current <i>Mapping</i> element
                        from DBMS to DDS. If not specified, the value will be inherited from
                        the <i>publish_initial_data</i> of the parent <i>NameSpace</i> element,
                        which if not explicitly specified inherits from the <i>publish_initial_data</i>
                        of the parent <i>DbmsToDds</i> element, which defaults to true.
                        The value of this attribute is ignored when the corresponding
                        <i>event_table_policy</i> is set to NONE.
                       ]]></comment>
          </attributeBoolean>
          <attributeBoolean name="force_key_equality" required="false">
            <default>true</default>
            <comment><![CDATA[
                           This attribute specifies the enforcement of key equality between table
                           and topic definitions. If true, key definitions from the table and
                           topic must match, otherwise key definitions may differ. If not specified,
                           the value will be inherited from the <i>force_key_equality</i> of the parent
                           <i>NameSpace</i> element, which if not explicitly specified defaults to true.
                    ]]></comment>
          </attributeBoolean>
          <attributeEnum name="event_table_policy" required="false">
            <comment><![CDATA[
                        <p>This attribute specifies the event table policy in the current <i>Mapping</i> element. If not specified, the value will be inherited from the <i>event_table_policy</i> of the parent <i>NameSpace</i> element, which if not explicitly specified inherits from the <i>event_table_policy</i> of the parent <i>DbmsToDds</i> element, which defaults to FULL.</p>
                        <p>An event table (sometimes referred to as ‘change table’ or ‘shadow table’) is a support-table that is slaved to an application-table, adding some status flags that are under the control of a trigger mechanism that responds to creation/modification/ deletion events in the application-table.</p>
                        <p>The following policies are currently supported:</p>
                        <ul>
                        <li><b>FULL</b>: An 'event table' will always be created when the service connects, and will always be deleted when the service disconnects. In this mode, the service will replace the table if it already exists.</li>
                        <li><b>LAZY</b>: An 'event table' will only be created if it is not available when the service connects, and it will not be deleted when the service disconnects.</ul>
                        <li><b>NONE</b>: An 'event table' will neither be created nor deleted by the service. For the specified table, the service will poll with a frequency specified in the coresponding <i>update_frequency</i> attribute of the parent <i>NameSpace</i>. It will start using the table as soon as it is available. With this policy set, no initial data will be published regardless of the value of the applicable <i>publish_initial_data</i> attribute.</ul>
                        </ul>
                    ]]></comment>
            <value>FULL</value>
            <value>LAZY</value>
            <value>NONE</value>
            <default>FULL</default>
          </attributeEnum>
          <attributeEnum name="trigger_policy" required="false">
            <comment><![CDATA[
                        <p>This attribute specifies the trigger policy for the current <i>Mapping</i> element. If not specified, the value will be inherited from the <i>trigger_policy</i> of the parent <i>DbmsToDds</i> element, which if not explicitly specified inherits from the <i>trigger_policy</i> of the parent <i>DbmsToDds</i> element, which defaults to FULL.</p>
                        <p>Triggers are used to to update the event table in case of creation/modification/ deletion events on the application-table.</p>
                        <p>The following policies are currently supported:</p>
                        <ul>
                        <li><b>FULL</b>: <i>(default)</i> Triggers will always be created when the service connects, and will always be deleted when the service disconnects. In this mode, the service will replace the triggers if they already exists.</li>
                        <li><b>LAZY</b>: Triggers will only be created if they are not available when the service connects, and will not be deleted when the service disconnects.</ul>
                        <li><b>NONE</b>: Triggers will neither be created nor deleted by the service. This allows you to build your own custom triggering mechanism.</ul>
                        </ul>
                   ]]></comment>
            <value>FULL</value>
            <value>LAZY</value>
            <value>NONE</value>
            <default>FULL</default>
          </attributeEnum>
        </element>
      </element>
    </element>
    <element name="Tracing" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[
                This element controls the amount and type of information that is
                written into the tracing log file by the DbmsConnect Service.
                This is useful to track the DbmsConnect Service during application
                development. In the runtime system it should be turned off.
            ]]></comment>
      <leafString name="OutputFile" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies where the logging is printed to. Note that
                    "stdout" and "stderr" are considered legal values that represent
                    "standard out" and "standard error" respectively. The default
                    value is an empty string, indicating that all tracing is disabled.
                ]]></comment>
        <maxLength>0</maxLength>
        <default>dbmsconnect.log</default>
      </leafString>
      <leafBoolean name="Timestamps" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies whether the logging must contain timestamps.
                ]]></comment>
        <attributeBoolean name="absolute" required="false">
          <comment><![CDATA[
                        This attribute specifies whether the timestamps are absolute or
                        relative to the startup time of the service.
                    ]]></comment>
          <default>true</default>
        </attributeBoolean>
        <default>true</default>
      </leafBoolean>
      <leafEnum name="Verbosity" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[
                    This element specifies the verbosity level of the logging.
                ]]></comment>
        <value>SEVERE</value>
        <value>WARNING</value>
        <value>INFO</value>
        <value>CONFIG</value>
        <value>FINE</value>
        <value>FINER</value>
        <value>FINEST</value>
        <default>INFO</default>
      </leafEnum>
    </element>
  </element>
  <element name="UserClockService" minOccurrences="0" maxOccurrences="1">
    <comment><![CDATA[
            The UserClock Service allows you to plug in a custom clock library, allowing
            OpenSplice to read the time from an external clock source. It expects a root
            element named <i>OpenSplice/UserClockService</i>. Within this root element,
            the userclock will look for several child-elements. Each of these is listed
            and explained.
        ]]></comment>
    <attributeString name="name" required="true">
      <comment><![CDATA[
                This attribute identifies the configuration for the UserClock Service.
                The value of the <i>name</i> attribute must match the one specified under the
                <i>OpenSplice/Domain/Service[@name]</i> in the configuration of the
                Domain Service.
            ]]></comment>
      <default>userclock</default>
      <maxLength>0</maxLength>
    </attributeString>
    <leafString name="UserClockModule" minOccurrences="1" maxOccurrences="1">
      <comment><![CDATA[
                This element specifies the User Clock Service library file. On UNIX
                like and Windows platforms this will be a shared library. On VxWorks
                this will be a reallocatable object file. On VxWorks this tag may
                be empty or discarded if the functions are pre-loaded on the target.
            ]]></comment>
      <default/>
      <maxLength>0</maxLength>
    </leafString>
    <element name="UserClockStart" minOccurrences="1" maxOccurrences="1">
      <comment><![CDATA[
                This element specifies if the user clock requires a start function to
                be called  when the process first creates a participant.
            ]]></comment>
      <attributeString name="name" required="true">
        <comment><![CDATA[
                    This attribute specifies the name of the start function.
                    This start function should not have any parameters, and needs
                    to return an int that represents 0 if there are no problems,
                    and any other value if a problem is encountered.
                ]]></comment>
        <maxLength>0</maxLength>
        <default>clockStart</default>
      </attributeString>
    </element>
    <element name="UserClockStop" minOccurrences="1" maxOccurrences="1">
      <comment><![CDATA[
                This element specifies if the user clock requires a stop function to
                be called when the process deletes the last participant.
            ]]></comment>
      <attributeString name="name" required="true">
        <comment><![CDATA[
                    This attribute specifies the name of the stop function. This stop
                    function should not have any parameters, and needs to return an
                    int that represents 0 if there are no problems, and any other
                    value if a problem is encountered.
                ]]></comment>
        <maxLength>0</maxLength>
        <default>clockStop</default>
      </attributeString>
    </element>
    <element name="UserClockQuery" minOccurrences="1" maxOccurrences="1">
      <comment><![CDATA[
                This element specifies the clock query function.
            ]]></comment>
      <attributeString name="name" required="true">
        <comment><![CDATA[
                    <p>This attribute specifies the name of the function that gets the
                    current time. This <i>clockGet</i> function should not have any parameters,
                    and needs to return the current time as an <i>os_time</i> type.</p>
                    <p>The definition of the <i>os_time</i> type can be found in <i>os_time.h</i>.</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default>clockGet</default>
      </attributeString>
    </element>
  </element>
</splice_meta_config>
