<?xml version='1.0' encoding='UTF-8'?>
<splice_meta_config version="1.0">
  <!--xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.splice-dds.org/splice_metaconfig.xsd"-->
  <rootElement name="OpenSplice" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
    <comment><![CDATA[
            <p>Vortex OpenSplice is highly configurable, even allowing the architecture of the
            DDS middleware to be chosen by the user at deployment time. Vortex OpenSplice can
            be configured to run using a <b>shared memory</b> architecture, where both the
            DDS related administration (including the optional pluggable services) and DDS
            applications interface directly with shared memory. Alternatively, Vortex OpenSplice
            also supports a <b>single process</b> architecture, where one or more DDS
            applications, together with the Vortex OpenSplice administration and services, can all be
            grouped into a single operating system process. Both deployment modes support a
            configurable and extensible set of services, providing functionality such as:</p>
            <p>networking - providing QoS-driven real-time networking based on multiple
                reliable multicast 'channels'</p>
            <p>durability - providing fault-tolerant storage for both real-time state data as well as
              persistent settings</p>
            <p>remote control and monitoring SOAP service - providing remote web-based
              access using the SOAP protocol from the Vortex OpenSplice Tuner tool</p>
            <p>dbms service - providing a connection between the real-time and the enterprise
              domain by bridging data from DDS to DBMS and vice versa</p>
            <p>Because of the pluggable architecture, the Vortex OpenSplice middleware
            can be easily configured on the fly by specifying which services to
            be used as well as specifying their optimal configuration for the
            application domain (networking parameters, durability levels, etc.).
            Typically, there are many nodes within a system.</p>
            <p>The Vortex OpenSplice middleware including its services can be configured
            by means of easy maintainable XML-file(s).</p>
        ]]></comment>
        <attributeString hidden="true" name="version" required="false" version="COMMUNITY">
            <comment><![CDATA[
                     This attribute specifies the version of the Vortex OpenSplice configuration
                     syntax definition.
                ]]></comment>
            <maxLength>0</maxLength>
            <default>6.1</default>
        </attributeString>
  <leafString name="Description" hidden="true"/>
  </rootElement>
  <serviceMapping>
    <element name="DurabilityService" command="durability"/>
    <element name="NetworkService" command="networking"/>
    <element name="SNetworkService" command="snetworking"/>
    <element name="DDSI2Service" command="ddsi2"/>
    <element name="DDSI2EService" command="ddsi2e"/>
    <element name="TunerService" command="cmsoap"/>
    <element name="DbmsConnectService" command="dbmsconnect"/>
    <element name="RnRService" command="rnr"/>
    <element name="NetworkingBridgeService" command="nwbridge"/>
    <element name="Agent" command="cmagent"/>
  </serviceMapping>
  <element name="Domain" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
    <comment><![CDATA[
            <p>The Domain service is responsible for creating and initialising the DDS database which is used by the
            administration to manage a specific DDS Domain on a computing node. Without this administration, no other
            service or application is able to participate in a DDS Domain.</p>
            <p>Once the administration has been initialised, the Domain service starts the set of pluggable services. The
            lifecycle of the started services is under control of the Domain service, which means it will monitor the health
            of all started services, take corrective actions if needed and stop the services when it is terminated.</p>

            <p>When a shutdown of the Vortex OpenSplice Domain service is requested, it will react by announcing the shutdown using the
            DDS administration. Applications will not be able to use DDS functionality anymore and services are requested
            to terminate elegantly. Once this has succeeded, the Domain service will destroy the administration and
            finally terminate itself.</p>
        ]]></comment>
    <leafString name="Name" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
                    This element specifies the name of the instantiated DDS domain. In general, it is recommended to change
                    this name to a name that identifies the domain. If several different DDS domains are required to run
                    simultaneously, then they all need to have their own domain name.
            ]]></comment>
      <maxLength>0</maxLength>
      <default>OpenSpliceV6</default>
    </leafString>
    <leafInt name="Id" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
                    This element specifies the domain Id of the instantiated DDS domain. If several different DDS domains are required to run
                    simultaneously, then they all need to have their own unique domain Id.
                    Note - for maximum interoperability it is recommended that you only select a domain Id from the range 0 < n < 230. The domain Id
                    value is used by the DDSI2 service to derive values for the required network communiction endpoints and service reconfiguration is
                    required to use domain id values outside of this range.
                    Please see section 9.6.1 of the Real-time Publish-Subscribe Wire Protocol DDS Interoperability Wire Protocol specification (DDSI), v2.1, formal/2009-01-05
                    or v2.2, formal/2014-09-01, at http://www.omg.org/spec/DDSI for further information.
                    ]]></comment>
      <minimum>0</minimum>
      <maximum>2147483646</maximum>
      <default>0</default>
    </leafInt>
    <leafString name="Role" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
                    Within a system and depending on the hosted application a Domain Service can
                    have a specific role and interaction with other Domain Services may depend on this
                    role.
                    The Role element is a user-defined string value that is communicated through the
                    system, the behavior of other Domain Services i.e. how they interact with a Domain
                    Service can be configured depend of the role by means of string matching
                    expressions. For example, a Domain Service could limit its communication with
                    other Domain Services by only accepting specific roles. (See also
                    OpenSplice/NetworkService/Discovery[@Scope] )
            ]]></comment>
      <maxLength>0</maxLength>
      <default>DefaultRole</default>
    </leafString>
    <element name="Lease" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
                    The Lease parameter specifies the death detection time of the Domain Service. All
                    internal tasks performed by the Domain Service will periodically update their
                    liveliness; when one or more tasks fail to update its liveliness the Domain will take
                    action to either repair the failing functionality, continue in a degraded mode, or halt,
                    depending on the configured desired behaviour.
      ]]></comment>
      <leafFloat name="ExpiryTime" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    <p>This element specifies the interval(in seconds) in which services have to announce their liveliness.</p>
                    <p>Every Vortex OpenSplice service including the Domain service itself has to announce its liveliness regularly.
                    This allows corrective actions to be taken when one of the services becomes non-responsive. This
                    element specifies the required interval. Decreasing the interval decreases the time in which
                    non-responsiveness of a service is detected, but leads to more processing. Increasing it has
                    the opposite effect.</p>
                ]]></comment>
        <format>float</format>
        <dimension>seconds</dimension>
        <default>10.0</default>
        <minimum>0.2</minimum>
        <attributeFloat name="update_factor" required="true" version="COMMUNITY">
          <comment><![CDATA[
                        In case of a (temporary) high CPU load, the scheduling behaviour of the operating system might
                        affect the capability of a service to assert its liveliness 'on time'. The <i>update_factor</i> attribute
                        introduces some elasticity in this mechanism by making the services assert their liveliness more
                        often than required by the <i>ExpiryTime</i>. Services will report their liveliness every
                        <i>ExpiryTime</i> multiplied by this <i>update_factor</i>.
                    ]]></comment>
          <format>float</format>
          <minimum>0.01</minimum>
          <maximum>1.0</maximum>
          <default>0.2</default>
        </attributeFloat>
      </leafFloat>
    </element>
    <element name="GeneralWatchdog" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
                This element controls the default characteristics of the Watchdog thread for all services.
                Individual services may overrule this default in their service specific settings.
                Every service has its own Watchdog thread, that is responsible for automatically renewing the lease for that service.
                Services that do not renew their lease in time will loose the liveliness of all their writers
            ]]></comment>
      <element name="Scheduling" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    This element specifies the type of OS scheduling class will be
                    used by the thread that announces its liveliness periodically.
                ]]></comment>
        <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the thread priority that will be used by the
                        watchdog thread. Only priorities that are supported by the
                        underlying operating system can be assigned to this element.
                        The user may need special privileges from the underlying operating
                        system to be able to assign some of the privileged priorities.
                    ]]></comment>
          <default>0</default>
          <attributeEnum name="priority_kind" required="false" version="COMMUNITY">
            <comment><![CDATA[
                                This attribute specifies whether the specified
                                Priority is a relative or absolute priority.
                            ]]></comment>
            <value>Relative</value>
            <value>Absolute</value>
            <default>Relative</default>
          </attributeEnum>
        </leafInt>
        <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the thread scheduling class that will be used by
                        the watchdog thread. The user may need the appropriate privileges from
                        the underlying operating system to be able to assign some of the
                        privileged scheduling classes.
                    ]]></comment>
          <value>Timeshare</value>
          <value>Realtime</value>
          <value>Default</value>
          <default>Default</default>
        </leafEnum>
      </element>
    </element>
    <leafFloat name="ServiceTerminatePeriod" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
                This element specifies the amount of time the Domain Service,
                when instructed to terminate, should wait for the other configured
                Services to terminate. When this element is configured to '0' the
                Domain service will terminate without any wait time at all. Be
                aware that without any wait time the deamon will use a hard kill
                on any lingering service that can not terminate fast enough.
                This may prevent graceful termination and thus leave applications
                that are still attached to the DDS domain in an undefined state.
                Consequently the '0' value should only be used when there is
                some form of process management on top of Vortex OpenSplice.
            ]]></comment>
      <format>float</format>
      <dimension>seconds</dimension>
      <minimum>0.0</minimum>
      <maximum>60.0</maximum>
      <default>10.0</default>
    </leafFloat>
    <leafBoolean name="SingleProcess" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
                    <p>The SingleProcess element specifies whether the Vortex OpenSplice Domain and other
                      Vortex OpenSplice services and applications are intended to be all deployed within the
                      same process, known in Vortex OpenSplice as a single process.</p>
                    <p>Please note that the choice to use the single process deployment also implies
                      the use of heap memory for the Vortex OpenSplice database management instead of shared
                      memory that would be used otherwise. If no database size or size 0 is configured
                      the heap memory is limited by the Operating System, so the Database element under
                      Domain does not take effect when SingleProcess has a value of True.
                      If the database size is configured with a value, a database will be allocated on
                      heap with that size and the domain service will use it's own memory manager to
                      manage that memory</p>
                    <p>There are two ways in which to deploy an Vortex OpenSplice application as a
                      single process:</p>
                    <p><b>Single Process Application</b> : The user starts an application as a
                      new process. In this case, the DDS create_participant operation will
                      implicitly start the Vortex OpenSplice Domain Service as a thread in the existing
                      application process. The Vortex OpenSplice Domain Service will then also implicitly
                      start all services specified in the configuration as threads within the same
                      process.
                    <p><b>Single Process Application Cluster</b> : This provides the option to
                      co-locate multiple DDS applications into a single process. This can be done
                      by creating application libraries rather than application executables that
                      can be linked into the single process in a similar way to how the DDS
                      middleware services are linked into the single process. The applications
                      that are created as libraries must be described using the Application
                      configuration attribute. These are started as threads within the existing
                      process by the Domain Service after all the DDS services that are specified
                      have been started as threads.</p>
                    <p>Please note that the Application elements specified under Domain will only
                      take effect when this SingleProcess attribute has a value
                      of true.</p>
                ]]></comment>
      <default>false</default>
    </leafBoolean>
    <leafString name="Description" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
          <p>The content of this (optional) element is visualised by the Launcher tool and is meant
          to describe the configuration in a human-readable form.</p> ]]></comment>
      <maxLength>0</maxLength>
      <default/>
    </leafString>
    <leafString name="CPUAffinity" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
          <p>This (optional) element specifies a comma separated list of CPU numbers for the CPUs which opensplice, and its services should be restricted to use. (Supported on VxWorks kernel mode only)</p>]]></comment>
      <maxLength>0</maxLength>
      <default/>
    </leafString>
    <leafBoolean name="InProcessExceptionHandling" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
           <p>The InProcessExceptionHandling element determines whether a process that uses Vortex OpenSplice will
            handle exceptions by itself and try to clean up shared resources or not. If the process itself
            refrains from cleaning up its resources, the splice-daemon will attempt to clean up the application
            shared resources asynchronously. If the splice-daemon during clean-up determines that shared
            resources have been left in an inconsistent state by the application, it will
            terminate the middleware.</p>
           <p>Setting this option to false will make the middleware fail-safe. However, the downside of
            this approach is that there are cases in which the splice-daemon will decide to shut down the
            middleware, because it cannot determine with 100% certainty that shared resources are
            consistent (even if they are consistent in some cases). A potential approach could be to set this
            option to 'true' during development-phase and 'false' when application(s) have been deployed.</p>
           <p>By default this configuration item is set to true.</p>
       ]]></comment>
      <default>true</default>
    </leafBoolean>
    <element name="Daemon" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
            Every domain is controlled by exactly one daemon: the Splice Daemon.
            The Splice Daemon configuration expects a root element named
            <i>OpenSplice/Daemon</i>. Within this root element, the Splice Daemon will
            look for several child-elements. Each of these child elements is
            listed and explained.
        ]]></comment>
      <leafBoolean name="Locking" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                <p>This element specifies the locking policy for the Splice Deamon
                process, indicating whether its pages should be locked in physical
                memory or not.</p>
                On platforms with a virtual memory architecture, the operating
                system decides when to swap memory pages from internal memory to disk.
                This results in execution delays for the corresponding code because it
                has to be paged back into main memory. The element <i>Locking</i> can be
                used to avoid such swapping for the Splice Deamon. The user needs the
                appropriate privileges from the underlying operating system to be able
                to use this option.
            ]]></comment>
        <default>false</default>
      </leafBoolean>
      <element name="Watchdog" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                 This element controls the scheduling characteristics of the Watchdog thread. This
                 thread is responsible for sending domain service heartbeats, updating liveliness of
                 the service builtin DataWriters and monitoring the health of internal services and
                 heartbeats of remote domain services.
               ]]></comment>
        <element name="Scheduling" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                    This element specifies the type of OS scheduling class will be
                    used by the thread that announces its liveliness periodically.
                ]]></comment>
          <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
            <comment><![CDATA[
                        This element specifies the thread priority that will be used by the
                        watchdog thread. Only priorities that are supported by the
                        underlying operating system can be assigned to this element.
                        The user may need special privileges from the underlying operating
                        system to be able to assign some of the privileged priorities.
                    ]]></comment>
            <default>0</default>
            <attributeEnum name="priority_kind" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
              <comment><![CDATA[
                            This attribute specifies whether the specified Priority is a relative or absolute priority
                       ]]></comment>
              <value>Relative</value>
              <value>Absolute</value>
              <default>Relative</default>
            </attributeEnum>
          </leafInt>
          <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
            <comment><![CDATA[
                        This element specifies the thread scheduling class that will be used by
                        the watchdog thread. The user may need the appropriate privileges from
                        the underlying operating system to be able to assign some of the
                        privileged scheduling classes.
                    ]]></comment>
            <value>Timeshare</value>
            <value>Realtime</value>
            <value>Default</value>
            <default>Default</default>
          </leafEnum>
        </element>
        <leafInt name="StackSize" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                    This element specifies the thread stacksize that will be used by the
                    Watchdog thread. By default this is 512 Kb.
                ]]></comment>
          <default>524288</default>
          <dimension>bytes</dimension>
        </leafInt>
      </element>
      <element name="shmMonitor" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                 This element controls the scheduling characteristics of the shmMonitor thread. This
                 thread is responsible cleaning up resources that are left behind by unexpected termination of other
                 dds services and applications.
               ]]></comment>
        <element name="Scheduling" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                    This element specifies the type of OS scheduling class will be
                    used by the thread that announces its liveliness periodically.
                ]]></comment>
          <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
            <comment><![CDATA[
                        This element specifies the thread priority that will be used by the
                        shmMonitor thread. Only priorities that are supported by the
                        underlying operating system can be assigned to this element.
                        The user may need special privileges from the underlying operating
                        system to be able to assign some of the privileged priorities.
                    ]]></comment>
            <default>0</default>
            <attributeEnum name="priority_kind" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
              <comment><![CDATA[
                            This attribute specifies whether the specified Priority is a relative or absolute priority
                       ]]></comment>
              <value>Relative</value>
              <value>Absolute</value>
              <default>Relative</default>
            </attributeEnum>
          </leafInt>
          <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
            <comment><![CDATA[
                        This element specifies the thread scheduling class that will be used by
                        the shmMonitor thread. The user may need the appropriate privileges from
                        the underlying operating system to be able to assign some of the
                        privileged scheduling classes.
                    ]]></comment>
            <value>Timeshare</value>
            <value>Realtime</value>
            <value>Default</value>
            <default>Default</default>
          </leafEnum>
        </element>
        <leafInt name="StackSize" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                    This element specifies the thread stacksize that will be used by the
                    shmMonitor thread. By default this is 512 Kb.
                ]]></comment>
          <default>524288</default>
          <dimension>bytes</dimension>
        </leafInt>
      </element>
      <element name="KernelManager" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                 The Kernel Manager monitors Builtin Topic on status changes of DataWriters and
                 inconsistencies between Topics and QoS policies, and it will notify all participants
                 interested in any of these events, i.e. it updates status fields and wakeup blocking
                 waitset and listener threads.
                 Controlling the scheduling behaviour of the Kernel Manager will therefore infuence
                 the reactivity on detecting events, but it will not infuence the event handling itself as
                 this is the responsibility of the participants waitset or listener thread.
                 Note that the Kernel Manager has no or limited value when Builtin Topics are
                 disabled.
      ]]></comment>
        <element name="Scheduling" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                    This element specifies the scheduling policies used to control
                    the KernelManager thread.
                ]]></comment>
          <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
            <comment><![CDATA[
                        This element specifies the thread priority that will be used by the
                        KernelManager thread. Only priorities that are supported by the
                        underlying operating system can be assigned to this element.
                        The user may need special privileges from the underlying operating
                        system to be able to assign some of the privileged priorities.
                    ]]></comment>
            <default>0</default>
            <attributeEnum name="priority_kind" required="false" version="COMMUNITY">
              <comment><![CDATA[
                            This attribute specifies whether the specified
                            Priority is a relative or absolute priority.
                        ]]></comment>
              <value>Relative</value>
              <value>Absolute</value>
              <default>Relative</default>
            </attributeEnum>
          </leafInt>
          <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
            <comment><![CDATA[
                        This element specifies the thread scheduling class that will be
                        used by the KernelManager thread. The user may need the appropriate
                        privileges from the underlying operating system to be able to
                        assign some of the privileged scheduling classes.
                    ]]></comment>
            <value>Timeshare</value>
            <value>Realtime</value>
            <value>Default</value>
            <default>Default</default>
          </leafEnum>
        </element>
        <leafInt name="StackSize" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
              This element specifies the thread stacksize that will be used by the
              KernelManager thread. By default this is 512 Kb.
          ]]></comment>
          <default>524288</default>
          <dimension>bytes</dimension>
        </leafInt>
      </element>
      <element name="GarbageCollector" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                <p>This element specifies the behaviour of the GarbageCollector.</p>
                <p>The garbage collector is a safety mechanism and is responsible for
                reclaiming resources in case an application or remote node does not
                terminate properly.</p>
            ]]></comment>
        <element name="Scheduling" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                    This element specifies the scheduling policies used to control the
                    GarbageCollector thread.
                ]]></comment>
          <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
            <comment><![CDATA[
                        This element specifies the thread priority that will be used by
                        the GarbageCollector thread. Only priorities that are supported
                        by the underlying operating system can be assigned to this element.
                        The user may need special privileges from the underlying operating
                        system to be able to assign some of the privileged priorities.
                    ]]></comment>
            <default>0</default>
            <attributeEnum name="priority_kind" required="false" version="COMMUNITY">
              <comment><![CDATA[
                            This attribute specifies whether the specified
                            Priority is a relative or absolute priority.
                        ]]></comment>
              <value>Relative</value>
              <value>Absolute</value>
              <default>Relative</default>
            </attributeEnum>
          </leafInt>
          <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
            <comment><![CDATA[
                        This element specifies the thread scheduling class that will be
                        used by the GarbageCollector thread. The user may need the
                        appropriate privileges from the underlying operating system to
                        be able to assign some of the privileged scheduling classes.
                    ]]></comment>
            <value>Timeshare</value>
            <value>Realtime</value>
            <value>Default</value>
            <default>Default</default>
          </leafEnum>
        </element>
        <leafInt name="StackSize" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
              This element specifies the thread stacksize that will be used by the
              GarbageCollector thread. By default this is 512 Kb.
          ]]></comment>
          <default>524288</default>
          <dimension>bytes</dimension>
        </leafInt>
      </element>
      <element name="ResendManager" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                Every service has its own ResendManager thread, that is responsible for attempting to resend samples in the history queue of its writers.
                A writer that cannot successfully deliver a sample to a local service or application in the
                first attempt (for example because the application or service ran out of queue space) will store that sample in its own history queue,
                from which the Resend manager will periodically try to re-transmit it.
            ]]></comment>
        <element name="Scheduling" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                    This element specifies the type of OS scheduling class used by
                    the thread that does local resends for the builtin participant.
                ]]></comment>
          <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
            <comment><![CDATA[
                        This element specifies the thread priority that will be used by the
                        ResendManager thread. Only priorities that are supported by the
                        underlying operating system can be assigned to this element.
                        The user may need special privileges from the underlying operating
                        system to be able to assign some of the privileged priorities.
                    ]]></comment>
            <default>0</default>
            <attributeEnum name="priority_kind" required="false" version="COMMUNITY">
              <comment><![CDATA[
                            This attribute specifies whether the specified
                            Priority is a relative or absolute priority.
                        ]]></comment>
              <value>Relative</value>
              <value>Absolute</value>
              <default>Relative</default>
            </attributeEnum>
          </leafInt>
          <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
            <comment><![CDATA[
                        This element specifies the thread scheduling class that will be used by
                        the ResendManager thread. The user may need the appropriate privileges from
                        the underlying operating system to be able to assign some of the
                        privileged scheduling classes.
                    ]]></comment>
            <value>Timeshare</value>
            <value>Realtime</value>
            <value>Default</value>
            <default>Default</default>
          </leafEnum>
        </element>
        <leafInt name="StackSize" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
              This element specifies the thread stacksize that will be used by the
              ResendManager thread. By default this is 512 Kb.
          ]]></comment>
          <default>524288</default>
          <dimension>bytes</dimension>
        </leafInt>
      </element>
      <element name="Heartbeat" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    <p>The Splice Daemon uses an heartbeat mechanism to monitor the
                    health of the remote domain services. This element allows
                    fine-tuning of this heartbeat mechanism.</p>
                    <p>Please note this heartbeat mechanism is similar to but not the
                    same as the service liveliness assertion.</p>
                ]]></comment>
        <attributeInt name="transport_priority" required="false" version="COMMUNITY">
          <comment><![CDATA[
                        This attribute controls the transport priority QoS setting (in seconds) that
                        is only used by the Splice Daemom for for sending its heartbeats.
                    ]]></comment>
          <minimum>0</minimum>
          <default>0</default>
        </attributeInt>
        <element name="Scheduling" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the scheduling parameters used by the
                        thread that periodically sends the heartbeats.
                    ]]></comment>
          <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
            <comment><![CDATA[
                            This element specifies the thread priority that will be used
                            by the thread that periodically sends the heartbeats. Only
                            priorities that are supported by the underlying operating
                            system can be assigned to this element. The user may need
                            special privileges from the underlying operating system to
                            be able to assign some of the privileged priorities.
                        ]]></comment>
            <default>0</default>
            <attributeEnum name="priority_kind" required="false" version="COMMUNITY">
              <comment><![CDATA[
                                This attribute specifies whether the specified
                                Priority is a relative or absolute priority.
                            ]]></comment>
              <value>Relative</value>
              <value>Absolute</value>
              <default>Relative</default>
            </attributeEnum>
          </leafInt>
          <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
            <comment><![CDATA[
                            This element specifies the thread scheduling class that will
                            be used by the thread that periodically sends the heartbeats.
                            The user may need the appropriate privileges from the underlying
                            operating system to be able to assign some of the privileged
                            scheduling classes.
                        ]]></comment>
            <value>Timeshare</value>
            <value>Realtime</value>
            <value>Default</value>
            <default>Default</default>
          </leafEnum>
        </element>
        <leafFloat name="ExpiryTime" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        <p>This element specifies the maximum amount of time(in seconds) in
                        which the Splice Daemon expects a new heartbeat of
                        remote domain services. This is obviously also the
                        same amount of time in which the Splice Daemon must
                        send a heartbeat itself.</p>
                        <p>Increasing this value will lead to less networking
                        traffic and overhead but also to less responsiveness with
                        respect to the liveliness of the Splice Daemon. Change
                        this value according to the need of your system with respect
                        to these aspects.</p>
                    ]]></comment>
          <default>4.0</default>
          <minimum>0.2</minimum>
          <attributeFloat name="update_factor" required="true" version="COMMUNITY">
            <comment><![CDATA[
                            <p>In case of a (temporary) high CPU load, the scheduling
                            behaviour of the operating system might affect the
                            capability of the Splice Daemon to send its
                            heartbeat 'on time'. This attribute introduces some
                            elasticity in this mechanism by making the service
                            send its heartbeat more often then required by the
                            ExpiryTime.</p>
                            <p>The Splice Daemon will report its liveliness
                            every <i>ExpiryTime</i> multiplied by this
                            <i>update_factor</i>.</p>
                        ]]></comment>
            <minimum>0.1</minimum>
            <maximum>0.9</maximum>
            <default>0.25</default>
          </attributeFloat>
        </leafFloat>
        <leafInt name="StackSize" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                  This element specifies the thread stacksize that will be used by the
                  Heartbeat thread. By default this is 512 Kb.
              ]]></comment>
          <default>524288</default>
          <dimension>bytes</dimension>
        </leafInt>
      </element>
      <element name="Tracing" minOccurrences="0" maxOccurrences="1">
            <comment><![CDATA[
                    This element controls the amount and type of information that is
                    written into the tracing log by the Splice Daemon. This is
                    useful to track the Durability Service during application
                    development. In the runtime system it should be turned off.
            ]]></comment>
            <attributeBoolean name="synchronous" required="false">
                <default>FALSE</default>
            </attributeBoolean>
            <leafString name="OutputFile" minOccurrences="0" maxOccurrences="1">
                <comment><![CDATA[
                    This option specifies where the logging is printed to. Note that
                    "stdout" is considered a legal value that represents "standard out"
                    and "stderr" is a legal value representing "standard error".
                    The default value is an empty string, indicating that all tracing
                    is disabled.
                ]]></comment>
                <maxLength>0</maxLength>
                <default>durability.log</default>
            </leafString>
            <leafBoolean name="Timestamps" minOccurrences="0" maxOccurrences="1">
                <comment><![CDATA[
                    This element specifies whether the logging must contain timestamps.
                ]]></comment>
                <attributeBoolean name="absolute" required="false">
                    <comment><![CDATA[
                        This attribute specifies whether the timestamps are absolute or
                        relative to the startup time of the service.
                    ]]></comment>
                    <default>true</default>
                </attributeBoolean>
                <default>true</default>
            </leafBoolean>
            <leafEnum name="Verbosity" minOccurrences="0" maxOccurrences="1">
                <comment><![CDATA[
                    This element specifies the verbosity level of the loggin
                    information. The higher the level, the more (detailed)
                    information will be logged.
                ]]></comment>
                <value>SEVERE</value>
                <value>WARNING</value>
                <value>INFO</value>
                <value>CONFIG</value>
                <value>FINE</value>
                <value>FINER</value>
                <value>FINEST</value>
                <default>INFO</default>
            </leafEnum>
        </element>
    </element>
    <element name="Database" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
                    The Database element drives how the administration within the federation is managed.
                    In federated deployment this administration is managed in a shared memory segment
                    and in single-process deployment it is managed on heap.
            ]]></comment>
      <leafSize name="Size" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element specifies the maximum size of the memory segment for maintaining
                    the nodal administration. The memory management behaviour depends on the deployment mode
                    (federated vs single-process, driven by the //OpenSplice/Domain/SingleProcess element)
                    and the size configured within this element:
                    <ul>
                    <li> <b>Single process mode</b> In this mode the database is managed on heap.
                                If the size is set to zero, the heap is managed by the operating system memory
                                manager and limited to the operating system limit. If a non-zero size is
                                configured, the database is still allocated on heap, but the domain service
                                pre-allocates the entire size at once and will use its own memory manager
                                to manage this memory segment. The default value in this mode is 0 bytes.</li>
                    <li> <b>Federated mode</b> In this mode, the database is managed in shared memory segment
                                and the domain service will use its own memory manager to manage the
                                shared memory segment. The default value in this mode is 10 Mbytes.</li></ul>
                    Change this value if your system requires more memory than the default. Please note
                    that the operating system should be configured support the requested size.
                    On most platforms you need 'root' privileges to set large sizes.
                    The human-readable option lets the user postfix the value with
                    K(ilobyte), M(egabyte) or G(igabtye). For example, 10M results in 10485760 bytes.
                ]]></comment>
        <dimension>bytes</dimension>
        <minimum>0</minimum>
        <default>10485760</default>
      </leafSize>
      <leafSize name="Threshold" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                        This element specifies the threshold size used by Vortex OpenSplice. Whenever there is less
                        free shared memory then indicated by the threshold then no new allocations will be allowed
                        within shared memory. Services are allowed to continue allocating shared memory until less then
                        50% of the threshold value is available. It is strongly discouraged to configure a threshold
                        value of less then the default value, but for some embedded systems it might be needed as
                        only limited memory is available.
                        The human-readable option lets the user postfix the value with K(ilobyte),
                        M(egabyte) or G(igabtye). For example, 10M results in 10485760 bytes.
                ]]></comment>
        <dimension>bytes</dimension>
        <minimum>0</minimum>
        <default>1048576</default>
      </leafSize>
      <leafString name="Address" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    <p>This element specifies the start address where the
                    nodal shared administration is mapped into the virtual
                    memory for each process that attaches to the current Domain.
                    The possible values are platform dependent.</p>
                    <p>Change this value if the default address is already in
                    use, for example by another Domain Service or another
                    product.</p>
                    <p>default values per platform:</p>
                    <ul>
                    <li>00x20000000 (Linux)</li>
                    <li>00x140000000 (Linux 64-bit)</li>
                    <li>00x40000000 (Windows)</li>
                    <li>00x140000000 (Windows 64-bit)</li>
                    <li>00xA0000000 (Solaris)</li>
                    <li>00xA0000000 (AIX5.3)</li>
                    <li>00x0 (VxWorks 5.5.1)</li>
                    <li>00x60000000 (VxWorks 6.x)</li>
                    <li>00x20000000 (Integrity)</li>
                    <li>00x20000000 (LynxOS)</li>
                    <li>00x140000000 (LynxOS 64-bit)</li>
                    <li>00x0 (PikeOS)</li>
                    <li>00x60000000 (QXN)</li>
                    <li>00x0 (RTEMS)</li>
                    <li>00x00220000 (Windows CE)</li>
                    </ul>
                ]]></comment>
        <maxLength>0</maxLength>
        <minimum>0x0</minimum>
        <default>0x40000000 </default>
      </leafString>
      <leafEnum name="Locking" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    <p>This element specifies the locking policy of the Database, indicating
                    whether to lock pages in physical memory or not.</p>
                    <p>With the virtual memory architecture, the operating system decides when
                    to swap memory pages from internal memory to disc. This results in execution
                    delays for the corresponding code because it has to be paged back into main
                    memory. The element <i>Locking</i> can be used to avoid such swapping for the
                    shared memory where the database resides. The user needs the appropriate
                    privileges from the underlying operating system to be able to use this option.</p>
                    <p>The possible values are:</p>
                    <ul>
                    <li><b>True</b>: lock the pages in memory.</li>
                    <li><b>False</b>: don't lock the pages in memory.</li>
                    <li><b>Default</b>: use the platform-dependent default value.</li>
                    </ul>
                ]]></comment>
        <value>True</value>
        <value>False</value>
        <value>Default</value>
        <default>Default</default>
      </leafEnum>
    </element>
    <element name="Listeners" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
                    This element specifies policies for the thread that services the listeners that
                    the application specifies on the API-level.
            ]]></comment>
      <leafSize name="StackSize" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                        This element specifies the stack size of the listener thread.
                ]]></comment>
        <minimum>64000</minimum>
        <default>128000</default>
      </leafSize>
    </element>
    <element name="Service" minOccurrences="0" maxOccurrences="0" version="COMMUNITY">
      <comment><![CDATA[
                The Domain service is responsible for starting, monitoring and stopping the pluggable services.
                One Service element must be specified for every service that needs to be started by the Domain service.
                When run in shared memory mode, the Domain Service will start each service as a
                new process that will interface directly with the shared memory for DDS
                communication.
                When run in single process mode, the Domain Service will start each service as a
                new thread within the existing process that will have access to the heap memory
                for the DDS communication.
            ]]></comment>
      <attributeString name="name" required="true" version="COMMUNITY">
        <comment><![CDATA[
                    <p>This attribute specifies the name by which the corresponding service is
                    identified in the rest of the configuration file.</p>
                    <p>In the Vortex OpenSplice configuration file, services and their settings
                    are identified by a name. When the Domain Service starts a particular
                    service, its corresponding name is passed. The service in question uses
                    this name in order to find its own configuration settings in the rest of
                    the configuration file. The name specified here must match the name
                    attribute of the main element of the corresponding service.</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default>durability</default>
      </attributeString>
      <attributeBoolean name="enabled" required="false" version="COMMUNITY">
        <comment><![CDATA[
                    <p>This attribute indicates whether the service is actually started or not.</p>
                    <p>Toggling a service between enabled and disabled is a quick alternative for
                    commenting out the corresponding lines in the configuration file.</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default>true</default>
      </attributeBoolean>
      <leafString name="Command" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    <p>This element specifies the command to be executed in order to start the service.</p>
                    <p>In shared memory mode, Command element specifies the name of the actual service
                    executable or a script to launch this service (possibly including its path, but always
                    including its extension, e.g. .exe on the Windows platform). When no path is
                    included, the Domain Service will search the PATH environment variable for the
                    corresponding executable. Once located, it will be started as a separate process.</p>
                    <p>In single process mode, Command is the name of the entry point function to be
                    invoked and the name of the shared library to be dynamically loaded into the
                    process. The signature of the entry point function is the same as argc/argv usually
                    seen with main. The Vortex OpenSplice services are implemented in such a way that the
                    entry point name matches that of the shared library, so (for example) specifying
                    durability is all that is required.</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default>durability</default>
      </leafString>
      <leafString name="MemoryPoolSize" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
            <p><b>CAUTION</b>: This element should only be used on the GHS Integrity platform!!</p>
                    <p>This element maps directly into the integrate file
                    for the address space for this service. Consult the GHS Integrate documentation for
                    further information on this setting. Valid values are decimal or hexadecimal numbers and
                    they express the number of bytes.</p>
                    <p>The default setting for this element is dependent on the service for which it is configured.
                    0xa00000 for spliced,
                    0x280000 for durability,
                    0x280000 for networking,
                    0x100000 for cmsoap </p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default>0</default>
      </leafString>
      <leafString name="HeapSize" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    <p><b>CAUTION</b>: This element should only be used on the GHS Integrity platform!!</p>
                    <p>This element maps directly into the integrate file
                    for the address space for this service. Consult the GHS Integrate documentation for
                    further information on this setting. Valid values are decimal or hexadecimal numbers and
                    they express the number of bytes.</p>
                    <p>The default setting for this element is dependent on the service for which it is configured.
                    0x800000 for spliced,
                    0x240000 for durability,
                    0x240000 for networking,
                    0x200000 for cmsoap</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default>0</default>
      </leafString>
      <leafString name="StackSize" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
            <p><b>CAUTION</b>: This element should only be used on the GHS Integrity platform!!</p>
                    <p>This element maps directly into the integrate file
                    for the address space for this service. Consult the GHS Integrate documentation for
                    further information on this setting. Valid values are decimal or hexadecimal numbers and
                    they express the number of bytes.</p>
                    <p>The default setting for this element is dependent on the service for which it is configured
                    0x10000 for spliced
                    0x10000 for durability
                    0x10000 for networking
                    0x10000 for cmsoap</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default>0</default>
      </leafString>
      <leafString name="Configuration" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    <p>This element allows overriding of the default URI (specified in the
                    <i>OSPL_URI</i> environment variable, or passed explicitly as command-
                    line parameter to the <i>ospl</i> executable) with the configuration
                    resource specified here.</p>
                    <p>When the Domain Service is started by the <i>ospl</i> executbale,
                    by default it passes on its own URI to the services that it starts.
                    This is valid when the configuration of the service is located in the
                    same resource file as the configuration of the Domain Service itself.
                    (This is a convenient situation in most cases).</p>
                    <p>If the configuration of the current service is located in a separate
                    resource file, a separate URI identifying that particular resource file
                    must be specified in this element.</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default>${OSPL_URI}</default>
      </leafString>
      <element name="Scheduling" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    This element specifies the type of OS scheduling class will be
                    used by the Domain service to create the service process. Services
                    can only be started within the scheduling classes that are
                    supported by the underlying operating system.
                ]]></comment>
        <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the thread priority that the Domain Service will
                        assign to the current Service when it is started. Only priorities that
                        are supported by the underlying operating system can be assigned to this
                        element. The user may need special privileges from the underlying
                        operating system to be able to assign some of the privileged priorities.
                    ]]></comment>
          <default>0</default>
          <attributeEnum name="priority_kind" required="false" version="COMMUNITY">
            <comment><![CDATA[
                            This attribute specifies whether the specified Priority is a relative
                            or absolute priority.
                        ]]></comment>
            <value>Relative</value>
            <value>Absolute</value>
            <default>Relative</default>
          </attributeEnum>
        </leafInt>
        <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the thread scheduling class that the Domain
                        Service will assign to the current Service when it is started.
                        The user may need the appropriate privileges from the underlying
                        operating system to be able to assign some of the privileged
                        scheduling classes.
                    ]]></comment>
          <value>Timeshare</value>
          <value>Realtime</value>
          <value>Default</value>
          <default>Default</default>
        </leafEnum>
      </element>
      <leafBoolean name="Locking" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    <p>This element specifies the locking policy of the current Service
                    process, indicating whether pages should be locked in physical memory
                    or not.</p>
                    <p>On platforms with a virtual memory architecture, the operating
                    system decides when to swap memory pages from internal memory to disk.
                    This results in execution delays for the corresponding code because it
                    has to be paged back into main memory. The element <i>Locking</i> can be
                    used to avoid such swapping for the current Service. The user needs the
                    appropriate privileges from the underlying operating system to be able
                    to use this option.</p>
                ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafEnum name="FailureAction" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    <p>This element specifies what action to take at the moment that the service seems
                    to have become non-responsive.</p>
                    <p>Each service reports its liveliness regularly using the DDS administration.
                    If the service fails to do so, the Domain service will assume the service has
                    become non-responsive. This element determines what action is taken
                    by the DomainService in case this happens.</p>
                    <p>The following actions are available:</p>
                    <ul>
                        <li><b>skip</b>: Ignore the non-responsiveness and continue.</li>
                        <li><b>kill</b>: End the service process by force.</li>
                        <li><b>restart</b>: End the service process by force and restart it.</li>
                        <li><b>systemhalt</b>:  End all Vortex OpenSplice services including the Domain service (for the current DDS Domain on this computing node).</li>
                    </ul>
                ]]></comment>
        <value>kill</value>
        <value>restart</value>
        <value>skip</value>
        <value>systemhalt</value>
        <default>skip</default>
      </leafEnum>
    </element>
    <element name="GIDKey" minOccurrences="0" maxOccurrences="0" version="COMMUNITY">
      <attributeString name="groups" required="true" version="COMMUNITY">
        <comment><![CDATA[
                    <p>This attribute specifies the namespace by which the corresponding groups
                    will use the writer instance gid as key so that data from different writers
                    don merge as historical data for late joiners.</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default></default>
      </attributeString>
    </element>
    <element name="Application" minOccurrences="0" maxOccurrences="0" version="COMMUNITY">
      <comment><![CDATA[
                <p>When in the single process deployment mode, the Domain service can deploy
                DDS applications by dynamically loading application shared libraries and
                starting threads within the existing process.
                A user can add a multiple Application elements to the configuration when they want
                to 'cluster' multiple DDS applications within an Vortex OpenSplice single process.
                The entry point and shared library for each Application can be specified by using the
                Command and Library elements that are described below.>/p>
                <p><b>Note that Applications only take effect when the single process configuration is enabled by way of the SingleProcess element.</b></p>
            ]]></comment>
      <attributeString name="name" required="true" version="COMMUNITY">
        <comment><![CDATA[
                    <p>This attribute assigns a configuration label to the application, but it is of no further
                    use; it can have any valid string value</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default/>
      </attributeString>
      <attributeBoolean name="enabled" required="false" version="COMMUNITY">
        <comment><![CDATA[
                    <p>This attribute indicates whether the application is actually started or not.</p>
                    <p>Toggling an applicatione between enabled and disabled is a quick alternative for
                    commenting out the corresponding lines in the configuration file.</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default>true</default>
      </attributeBoolean>
      <leafString name="Command" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    <p>Command is the name of both the entry point function to invoked and the name of the
                    shared library to be dynamically loaded into the process.  The signature of the entry
                    point function is the same as argc/argv usually seen with main.</p>
                    <p>For example, if Command is "HelloWorld", Vortex OpenSplice will attempt to load
                    "libHelloWorld.so" on Unix (or "HelloWorld.dll" on Windows) into the existing process
                    and then  invoke the "HelloWorld" entry point to start that DDS application.</p>
                    <p>If the name of the shared library does not have the same name as the entry point the
                    user is able to override the name of the library by using the Application's Library attribute</p>
                    <p>The shared library is located by way of the current working directory, or LD_LIBRARY_PATH
                    for Unix systems, and PATH for Windows systems.</p>
                    <p>Note that this has the same meaning as the Service/Command element when in the
                    single process mode of operation.</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default>application1</default>
      </leafString>
      <leafString name="Arguments" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    <p>This optional attribute allows the user to specify arguments to be passed to the
                    DDS application's entry point when it is invoked.</p>
                    <p>For example, if Command is "HelloWorld" and Arguments is "arg1 arg2", Vortex OpenSplice will
                    invoke the HelloWorld function with the argc = 3 and argv = {"HelloWorld", "arg1", "arg2"}</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default/>
      </leafString>
      <leafString name="Library" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    <p>This optional attribute allows the user to override the name of the shared
                    library if it is different to the name of the entry point specified by Command.</p>
                    <p>The shared library is located by way of the current working directory, or LD_LIBRARY_PATH
                    for Unix systems, and PATH for Windows systems.</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default/>
      </leafString>
    </element>
    <element name="BuiltinTopics" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
            This element specifies the granularity of the builtin topics.
            ]]></comment>
      <attributeBoolean name="enabled" required="true" version="COMMERCIAL">
        <comment><![CDATA[
                This attribute enables or disables the publication of builtin topics
                for the existence of individual Participants/DataWriters/DataReaders.
                The existence of Topics will always be communicated by means of builtin
                topics, regardless of the value specified here.
                ]]></comment>
        <default>true</default>
      </attributeBoolean>
      <attributeString name="logfile" required="false" version="COMMUNITY">
        <comment><![CDATA[
                  This attribute specifies the log file for entity lifecycle messages.
                  When a logfile is specified the service will open the logfile and
                  write a corresponding log line for each update of discovered entities.
              ]]></comment>
        <default>builtin.log</default>
        <maxLength>0</maxLength>
      </attributeString>
    </element>
    <element name="PriorityInheritance" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
            This element specifies the usage on Priority Inheritance on Muexes in this domain.
            ]]></comment>
      <attributeBoolean name="enabled" required="true" version="COMMUNITY">
        <comment><![CDATA[
                This attribute enables or disables priority inheritance for mutexes,
                if that is supported by the underlying Operating System.
                If the parent Element PriorityInheritance is not specified (does not exist), then the
                'default' value of this attribute is false.
                ]]></comment>
        <default>true</default>
      </attributeBoolean>
    </element>
    <element name="Report" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
            The Report element controls some aspects of the Vortex OpenSplice domain logging
            functionality.
        ]]></comment>
      <attributeBoolean name="append" required="false" version="COMMUNITY">
        <comment><![CDATA[
            This attribute determines whether logging for this domain should continue to
            append to the previous error and info log files when the domain is (re)started or
            whether the previous file should be deleted and fresh ones created.
        ]]></comment>
        <default>true</default>
      </attributeBoolean>
      <attributeEnum name="verbosity" required="false" version="COMMUNITY">
        <comment><![CDATA[
               This attribute determines what level of logging should be in effect for this domain.
               The levels or logging verbosity are:
               <ul>
                <li>0 DEBUG</li>
                <li>1 INFO</li>
                <li>2 WARNING</li>
                <li>3 API_INFO</li>
                <li>4 ERROR</li>
                <li>5 CRITICAL</li>
                <li>6 FATAL</li>
                <li>7 REPAIRED</li>
                <li>8 NONE</li>
               </ul>
               The level specified as this attribute is the lowest level that will be emitted to the
               logs. All logging can be suppressed by specifying the value 8 or NONE.
           ]]></comment>
        <value>DEBUG</value>
        <value>INFO</value>
        <value>WARNING</value>
        <value>API_INFO</value>
        <value>ERROR</value>
        <value>CRITICAL</value>
        <value>FATAL</value>
        <value>REPAIRED</value>
        <value>NONE</value>
        <default>INFO</default>
      </attributeEnum>
    </element>
    <element name="Statistics" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
            This element specifies the policies regarding statistics. Various statistics
            can be generated by Vortex OpenSplice to help you analyze and tune application
            behaviour during application development.  Since this introduces extra overhead,
            it is generally turned off in a runtime system.
            ]]></comment>
      <element name="Category" minOccurrences="0" maxOccurrences="0" version="COMMUNITY">
        <comment><![CDATA[
                    This element specifies the properties for a particular category of statistics.
                ]]></comment>
        <attributeBoolean name="enabled" required="false" version="COMMUNITY">
          <comment><![CDATA[
                        This attribute enables or disables the generation of statistics for the
                        specified category.
                    ]]></comment>
          <default>true</default>
        </attributeBoolean>
        <attributeEnum name="name" required="true" version="COMMUNITY">
          <comment><![CDATA[
                        This attribute specifies the name of a particular category of statistics.
                    ]]></comment>
          <value>durability</value>
          <value>reader</value>
          <value>writer</value>
          <value>networking</value>
          <default>reader</default>
        </attributeEnum>
      </element>
    </element>
    <leafInt name="RetentionPeriod" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
                    <p>This element specifies how long the administration for unregistered instances is retained in both readers and the durability service before it is definitively removed.
                    (For the durability service this time is added to the service_cleanup_delay configured for each TopicQos.) By default unregistered instances are retained for 500 ms prior to removal,
                    to avoid the revival of 'forgotten' instances when receiving delayed samples written prior to the instance's unregistration.
                    This value should only be decreased when the expected lifetime of an instance is extremely short while the instance generation frequency is extremely high, to avoid running out of resources.
                    The value should be increased when you know you can expect out-of-order deliveries with a maximum delay higher than the currently configured RetentionPeriod.</p>
                ]]></comment>
      <default>500</default>
      <minimum>1</minimum>
    </leafInt>
    <element name="ReportPlugin" minOccurrences="0" maxOccurrences="0" version="COMMUNITY">
      <comment><![CDATA[
            This Tag specifies user defined report functionality to be used by
            the domain. All services and applications will load a user provides
            report library that will implement the report plugin interface.
            The report interface consists of three operations;
            initialize, report and finalize.
        ]]></comment>
      <element name="Library" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                This tag specifies the library to be loaded.
            ]]></comment>
        <attributeString name="file_name" required="true" version="COMMUNITY">
          <comment><![CDATA[
                    This attribute specifies the library to be loaded.
                ]]></comment>
          <default/>
          <maxLength>0</maxLength>
        </attributeString>
      </element>
      <element name="Initialize" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                This tag specifies the library symbol that will be assigned to the
                report Initialize operation. This operation will be invoked
                initially after loading the library to perform initialization of
                the report facility if needed.
            ]]></comment>
        <attributeString name="symbol_name" required="true" version="COMMUNITY">
          <comment><![CDATA[
                This attribute specifies the name of the function to be called to initialize the report
                plugin. The symbol_name is required, if it is not specified or cannot be resolved, an
                error message will be generated and the service will not attempt to resolve other
                symbol_names for the report plugin.
                The implementation of this function must have the following signature:
                <p>int symbol_name (const char *argument, void **context)</p>
                The result value is used to return the status of the call. If it is 0 then the operation
                was successful. If it is not 0 then there was an error and details of the error and the
                result value are reported to the Vortex OpenSplice default report service.
                The context parameter is an out reference that can be set to plugin-specific data that
                will subsequently be passed to any of the other plugin functions. The value of the
                parameter is meaningless to the service
                ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <attributeString name="argument" required="false" version="COMMUNITY">
          <comment><![CDATA[
                The argument attribute is a string value that is passed to the function specified by the
                symbol_name. The string value has no meaning to the service and is used to pass
                any context-specific information that may be required. The argument is optional; if
                it is not provided then a NULL pointer is passed to the initalize function.
                ]]></comment>
          <default/>
          <maxLength>0</maxLength>
        </attributeString>
      </element>
      <element name="Report" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                This tag specifies the library symbol that will be assigned to
                the report Report operation. This operation will be invoked
                on all reports performed by the DDS service.
            ]]></comment>
        <attributeString name="symbol_name" required="true" version="COMMUNITY">
          <comment><![CDATA[
          This attribute specifies the name of the function to be called to pass report data to
          the report plugin. The symbol_name is required; if it is not specified or cannot be
          resolved, an error message will be generated and the service will not attempt to
          resolve other symbol_names for the report plugin.
          The function is invoked slightly differently for applications using the DDS API and
          Vortex OpenSplice services. Vortex OpenSplice services invoke the function once for every report.
          For applications using the DDS API the function is invoked once per API call, in
          which case the XML is extended by one or more DETAIL elements.
          The implementation of this function must have the following signature:
          <p>int symbol_name (void *context, const char *report)</p>
          The result value is used to return the status of the call. If it is 0 then the operation
          was successful. If it is not 0 then there was an error and details of the error and the
          result value are reported to the Vortex OpenSplice default report service.
          The context parameter is a reference to the plugin-specific data retrieved from the
          initialize operation.
          The report parameter is an XML string representation of the report data.
          <p>Below is an example of the mapping that the XML string representation will use
          when invoked by a service:
          <ul>
          <br><ERROR>
          <br><DESCRIPTION>The object "my_topic" not found</DESCRIPTION>
          <br><CONTEXT>c_base::resolve</CONTEXT>
          <br><FILE>c_base.c</FILE>
          <br><LINE>1234</LINE>
          <br><CODE>0</CODE>
          <br><PROCESS>
          <br><ID>1234</ID>
          <br><NAME>ProcessName</NAME>
          <br></PROCESS>
          <br><THREAD>
          <br><ID>1234</ID>
          <br><NAME>ThreadName</NAME>
          <br></THREAD>
          <br><VERSION>6.5</VERSION>
          <br><REVISION>...</REVISION>
          <br></ERROR></ul></p>
          <p>Below is an example of the mapping that the XML string representation will use for
          applications:
          <ul>
          <br><ERROR>
          <br><DESCRIPTION>Operation failed.</DESCRIPTION>
          <br><CONTEXT>c_base::resolve</CONTEXT>
          <br><FILE>c_base.c</FILE>
          <br><LINE>1234</LINE>
          <br><CODE>0</CODE>
          <br><PROCESS>
          <br><ID>1234</ID>
          <br><NAME>ProcessName</NAME>
          <br></PROCESS>
          <br><THREAD>
          <br><ID>1234</ID>
          <br><NAME>ThreadName</NAME>
          <br></THREAD>
          <br><VERSION>6.5</VERSION>
          <br><REVISION>...</REVISION>
          <br><DETAIL>
          <br><REPORT>The object "my_topic" not found.</REPORT>
          <br><INTERNALS>...</INTERNALS>
          <br></DETAIL>
          <br><!-- optionally more DETAIL elements -->
          <br></ERROR></ul></p>
          ]]></comment>
          <default/>
          <maxLength>0</maxLength>
        </attributeString>
      </element>
      <element name="TypedReport" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                This tag specifies the library symbol that will be assigned to
                the report TypedReport operation. This operation will be invoked
                on all reports performed by the DDS service.
            ]]></comment>
        <attributeString name="symbol_name" required="true" version="COMMUNITY">
          <comment><![CDATA[
                This attribute specifies the name of the function to be called to finalize the report
                plugin, when the domain unregisters any registered plugin. The symbol_name is
                required. If it is not specified or cannot be resolved, an error message will be
                generated and the service will not attempt to resolve other symbol_names for the
                report plugin.
                The implementation of this function must have the following signature:
                <p>int symbol_name (void *context)</p>
                The result value is used to return the status of the call. If it is 0 then the operation
                was successful. If it is not 0 then there was an error and details of the error and the
                result value are reported to the Vortex OpenSplice default report service.
          ]]></comment>
          <default/>
          <maxLength>0</maxLength>
        </attributeString>
      </element>
      <element name="Finalize" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                This tag specifies the library symbol that will be assigned
                to the report Finalize operation. This operation will be
                invoked upon process termination to perform de-initialization
                of the report facility if needed.
            ]]></comment>
        <attributeString name="symbol_name" required="true" version="COMMUNITY">
          <comment><![CDATA[
                This attribute specifies the name of the function to be called to finalize the report
                plugin, when the domain unregisters any registered plugin. The symbol_name is
                required. If it is not specified or cannot be resolved, an error message will be
                generated and the service will not attempt to resolve other symbol_names for the
                report plugin.
                The implementation of this function must have the following signature:
                int symbol_name (void *context)
                The result value is used to return the status of the call. If it is 0 then the operation
                was successful. If it is not 0 then there was an error and details of the error and the
                result value are reported to the Vortex OpenSplice default report service.
                The context parameter is a reference to the plugin-specific data retrieved from the
                initialize operation.
          ]]></comment>
          <default/>
          <maxLength>0</maxLength>
        </attributeString>
      </element>
      <leafBoolean name="SuppressDefaultLogs" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
            This attribute specifies whether the default error and info
            report logs are to be produced when a user Report Plugin has
            been defined.  If registration of the Report Plugin fails the
            default error and info logs will not be suppressed regardless of
            the value of this attribute
            ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafBoolean name="ServicesOnly" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
            This attribute specifies whether the log plug-in is to be effective only for processes
            that are exclusively Vortex OpenSplice services. If this value is true then the plug-in will
            not be used for user applications and/or Vortex OpenSplice services collocated with user
            applications in single process mode.
            ]]></comment>
        <default>false</default>
      </leafBoolean>
    </element>
    <element name="ResourceLimits" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
            This configuration tag allows for the specification of certain
            characteristics of resource limits that will be applied throughout
            the domain
        ]]></comment>
      <element name="MaxSamples" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                This configuration tag allows for the specification of certain
                characteristics of the max samples resource limit that will
                be applied throughout the domain
            ]]></comment>
        <leafLong name="WarnAt" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the number of samples that, once
                        reached, will result in a warning message printed in
                        the info log. This is to allow the detection of excessive
                        use of resources within the domain more easily.
                ]]></comment>
          <minimum>1</minimum>
          <default>5000</default>
        </leafLong>
      </element>
      <element name="MaxInstances" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                This configuration tag allows for the specification of certain
                characteristics of the max instances resource limit that will
                be applied throughout the domain
            ]]></comment>
        <leafLong name="WarnAt" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the number of instances that, once
                        reached, will result in a warning message printed in
                        the info log. This is to allow the detection of excessive
                        use of resources within the domain more easily.
                ]]></comment>
          <minimum>1</minimum>
          <default>5000</default>
        </leafLong>
      </element>
      <element name="MaxSamplesPerInstance" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                This configuration tag allows for the specification of certain
                characteristics of the max samples per instance resource limit
                that will be applied throughout the domain
            ]]></comment>
        <leafLong name="WarnAt" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the number of samples per
                        instance that, once reached, will result in a warning
                        message printed in the info log. This is to allow the
                        detection of excessive use of resources within the
                        domain more easily.
                ]]></comment>
          <minimum>1</minimum>
          <default>5000</default>
        </leafLong>
      </element>
    </element>
    <element name="PartitionAccess" minOccurrences="0" maxOccurrences="0" version="COMMUNITY">
      <comment><![CDATA[
                This element is used to configure the partition access rights. By default all partitions
                have read and write access, which means that subscribers and publishers may be
                created for all partitions. However by changing the access level of specific partitions
                it is possible to prevent publishers and/or subscribers from attaching to these
                partitions. The access rights is Domain Service specific, each Domain Service can
                have its own policy.
                The PartitionAccess element facilitates the configuration of such behavior. This
                is done by allowing the definition of a partition expression along with a specific
                access mode for the matched partitions. The PartitionAccess element resides as
                a child element within the Domain element. The exact definition of the
                PartitionAccess element is as follows:
         ]]></comment>
      <attributeString name="partition_expression" required="true" version="COMMUNITY">
        <comment><![CDATA[
                This attribute specifies the partitions by name.
                The wildcards '*' and '?' are allowed and the specified
                access rights will be applied to all matching partitions.
                In case partitions match multiple rules the rules will be
                applied in sequence of declaration.
            ]]></comment>
        <default>*</default>
        <maxLength>0</maxLength>
      </attributeString>
      <attributeEnum name="access_mode" required="true" version="COMMUNITY">
        <comment><![CDATA[
               This attribute identifies the access level for partitions specified by the
               partition_expression attribute. The following values are allowed:
               <ul>
                 <li>read Indicates domain participants can only read from this partition</li>
                 <li>write Indicates domain participants can only write to this partition</li>
                 <li>readwrite Indicates domain participants can read from and write to this partition</li>
                 <li>none Indicates that domain participants have no access on partitions matching the partition_expression.</li>
               </ul>
               <p>When multiple expressions overlap each other, the following rules are applied:
               <ul>
                  Access mode 1 Access mode 2 Resulting access mode
                  read write readwrite
                  read readwrite readwrite
                  read none none
                  write readwrite readwrite
                  write none none
                  readwrite none none</p>
               </ul><p>
            ]]></comment>
        <value>none</value>
        <value>read</value>
        <value>write</value>
        <value>readwrite</value>
        <default>readwrite</default>
      </attributeEnum>
    </element>
    <element name="SystemId" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[This configures the generation of the unique System IDs]]></comment>
      <element name="Range" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[This configures the range of the generated System IDs]]></comment>
        <attributeInt name="min" required="false" version="COMMUNITY">
          <comment><![CDATA[This attribute specifies the minimum allowed System ID. In addition to being within range, it must be less than or equal to the "max" attribute.]]></comment>
          <default>1</default>
          <minimum>1</minimum>
          <maximum>2147483647</maximum>
        </attributeInt>
        <attributeInt name="max" required="false" version="COMMUNITY">
          <comment><![CDATA[This attribute specifies the maximum allowed System ID. In addition to being within range, it must be greater than or equal to the "min" attribute.]]></comment>
          <default>2147483647</default>
          <minimum>1</minimum>
          <maximum>2147483647</maximum>
        </attributeInt>
      </element>
      <leafString name="UserEntropy" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[This attribute specifies a string that is used as an additional source of entropy in the System ID generation. The string is not interpreted.]]></comment>
        <maxLength>0</maxLength>
        <default/>
      </leafString>
    </element>
    <element name="TopicAccess" minOccurrences="0" maxOccurrences="0" version="COMMUNITY">
      <comment><![CDATA[
             This element is used to configure the topic access rights. By default all topics have
             read and write access (built-in topics have a default access mode of read), which
             means that datareaders and datawriters may be created for all topics. However by
             changing the access level of specific topics it is possible to prevent datawriters
             and/or datareaders from being created for these topics. The access rights is Domain
             Service specific, each Domain Service can have its own policy.
             The TopicAccess element facilitates the configuration of such behavior. This is
             done by allowing the definition of a topic expression along with a specific access
             mode for the matched topics.
             The TopicAccess element resides as a child element within the Domain element
      ]]></comment>
      <attributeString name="topic_expression" required="true" version="COMMUNITY">
        <comment><![CDATA[
                This attribute specifies the topics by name.
                The wildcards '*' and '?' are allowed and the specified
                access rights will be applied to all matching topics.
                In case topics match multiple rules the rules will be
                applied in sequence of declaration.
            ]]></comment>
        <default>*</default>
        <maxLength>0</maxLength>
      </attributeString>
      <attributeEnum name="access_mode" required="true" version="COMMUNITY">
        <comment><![CDATA[
                This attribute specifies the access rights that will be
                applied to the specified topics. The following values
                are applicable:
                <ul>
                    <li>none</li>
                    <li>read</li>
                    <li>write</li>
                    <li>readwrite</li>
                </ul>
            ]]></comment>
        <value>none</value>
        <value>read</value>
        <value>write</value>
        <value>readwrite</value>
        <default>readwrite</default>
      </attributeEnum>
    </element>

    <element name="UserClock" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
            The UserClock Service allows you to plug in a custom clock library, allowing
            Vortex OpenSplice to read the time from an external clock source. It expects a root
            element named <i>OpenSplice/Domain/UserClock</i>. Within this root element,
            the userclock will look for several child-elements. Each of these is listed
            and explained.
        ]]></comment>
      <attributeBoolean name="y2038Ready" required="false" version="COMMUNITY">
         <comment><![CDATA[
                   <p>This element specifies whether or not the registered user
                   clock is returning a 64-bit seconds field.</p>
                   <p>Default this setting is following the y2038Ready setting on
                   domain level. (default /domain/y2038Ready is FALSE)
                   The user is able to make some mixed environments by using this
                   configuration option. For example a 64-bit user clock can already
                   be implemented (by setting this option to true) while the node
                   must be compatible with older versions,
                   so domain/y2038Ready can not be set. A warning is printed when
                   the Domain/y2038Ready element is true and the
                   Domain/UserClock/y2038Ready attribute is false.
                   The 64-bit layout returned by the userclock must be:
                   <br/>struct dds_userclock_t {
                   <br/>  os_int64 seconds;
                   <br/>  os_int32 nanoseconds;
                   <br/>};
                   <br/>See 'Time stamps and year 2038 limit' for more background information.
                   </p>
                 ]]></comment>
        <default>False</default>
      </attributeBoolean>
      <leafString name="UserClockModule" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                This element specifies the User Clock Service library file. On UNIX
                like and Windows platforms this will be a shared library. On VxWorks
                this will be a reallocatable object file. On VxWorks this tag may
                be empty or discarded if the functions are pre-loaded on the target.
            ]]></comment>
        <default/>
        <maxLength>0</maxLength>
      </leafString>
      <leafString name="UserClockStart" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                This element specifies if the user clock requires a start function to
                be called  when the process first creates a participant.
                <p>This element specifies the name of the start function.
                This start function should not have any parameters, and needs
                to return an int that represents 0 if there are no problems,
                and any other value if a problem is encountered.<p>
            ]]></comment>
        <attributeBoolean name="enabled" required="true" version="COMMUNITY">
          <comment><![CDATA[
                  This attribute specifies if the start function is enabled and should be used.
              ]]></comment>
          <default>true</default>
        </attributeBoolean>
        <maxLength>0</maxLength>
        <default>clockStart</default>
      </leafString>
      <leafString name="UserClockStop" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                This element specifies if the user clock requires a stop function to
                be called when the process deletes the last participant.
                <p>This attribute specifies the name of the stop function. This stop
                function should not have any parameters, and needs to return an
                int that represents 0 if there are no problems, and any other
                value if a problem is encountered.</p>
            ]]></comment>
        <attributeBoolean name="enabled" required="true" version="COMMUNITY">
          <comment><![CDATA[
                  This attribute specifies if the stop function is enabled and should be used.
              ]]></comment>
          <default>true</default>
        </attributeBoolean>
        <maxLength>0</maxLength>
        <default>clockStop</default>
      </leafString>
      <leafString name="UserClockQuery" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                This element specifies the clock query function.
                <p>This attribute specifies the name of the function that gets the
                current time. This <i>clockGet</i> function should not have any parameters,
                and needs to return the current time as an <i>os_time</i> type.</p>
                <p>The definition of the <i>os_time</i> type can be found in <i>os_time.h</i>.</p>
            ]]></comment>
        <attributeBoolean name="enabled" required="true" version="COMMUNITY">
          <comment><![CDATA[
                  This attribute specifies if the query function is enabled and should be used.
                ]]></comment>
          <default>true</default>
        </attributeBoolean>
        <maxLength>0</maxLength>
        <default>clockGet</default>
      </leafString>
    </element>

    <element name="UserClockService" hidden="true" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
            The UserClock Service allows you to plug in a custom clock library, allowing
            Vortex OpenSplice to read the time from an external clock source. It expects a root
            element named <i>OpenSplice/Domain/UserClock</i>. Within this root element,
            the userclock will look for several child-elements. Each of these is listed
            and explained.
        ]]></comment>
      <attributeBoolean name="y2038Ready" required="false" version="COMMUNITY">
         <comment><![CDATA[
                   <p>This element specifies whether or not the registered user
                   clock is returning a 64-bit seconds field.</p>
                   <p>Default this setting is following the y2038Ready setting on
                   domain level. (default /domain/y2038Ready is FALSE)
                   The user is able to make some mixed environments by using this
                   configuration option. For example a 64-bit user clock can already
                   be implemented (by setting this option to true) while the node
                   must be compatible with older versions,
                   so domain/y2038Ready can not be set. A warning is printed when
                   the Domain/y2038Ready element is true and the
                   Domain/UserClock/y2038Ready attribute is false.
                   The 64-bit layout returned by the userclock must be:
                   <br/>struct dds_userclock_t {
                   <br/>  os_int64 seconds;
                   <br/>  os_int32 nanoseconds;
                   <br/>};
                   <br/>See 'Time stamps and year 2038 limit' for more background information.
                   </p>
                 ]]></comment>
        <default>False</default>
      </attributeBoolean>
      <attributeBoolean name="reporting" required="false" version="COMMUNITY">
        <comment><![CDATA[
                  This attribute identifies if the ospl info/error messages will use the userclock or use
                  the system clock for time reporting. When set to true which is default the userclock will be used.
                  When set to false the system clock will be used for time reporting in the log files.
              ]]></comment>
        <default>true</default>
      </attributeBoolean>
      <leafString name="UserClockModule" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
                This element specifies the User Clock Service library file. On UNIX
                like and Windows platforms this will be a shared library. On VxWorks
                this will be a reallocatable object file. On VxWorks this tag may
                be empty or discarded if the functions are pre-loaded on the target.
            ]]></comment>
        <default/>
        <maxLength>0</maxLength>
      </leafString>
      <leafString name="UserClockStart" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                This element specifies if the user clock requires a start function to
                be called  when the process first creates a participant.
                <p>This element specifies the name of the start function.
                This start function should not have any parameters, and needs
                to return an int that represents 0 if there are no problems,
                and any other value if a problem is encountered.<p>
            ]]></comment>
        <attributeBoolean name="enabled" required="true" version="COMMUNITY">
          <comment><![CDATA[
                  This attribute specifies if the start function is enabled and should be used.
              ]]></comment>
          <default>true</default>
        </attributeBoolean>
        <maxLength>0</maxLength>
        <default>clockStart</default>
      </leafString>
      <leafString name="UserClockStop" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                This element specifies if the user clock requires a stop function to
                be called when the process deletes the last participant.
                <p>This attribute specifies the name of the stop function. This stop
                function should not have any parameters, and needs to return an
                int that represents 0 if there are no problems, and any other
                value if a problem is encountered.</p>
            ]]></comment>
        <attributeBoolean name="enabled" required="true" version="COMMUNITY">
          <comment><![CDATA[
                  This attribute specifies if the stop function is enabled and should be used.
              ]]></comment>
          <default>true</default>
        </attributeBoolean>
        <maxLength>0</maxLength>
        <default>clockStop</default>
      </leafString>
      <leafString name="UserClockQuery" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                This element specifies the clock query function.
                <p>This attribute specifies the name of the function that gets the
                current time. This <i>clockGet</i> function should not have any parameters,
                and needs to return the current time as an <i>os_time</i> type.</p>
                <p>The definition of the <i>os_time</i> type can be found in <i>os_time.h</i>.</p>
            ]]></comment>
        <attributeBoolean name="enabled" required="true" version="COMMUNITY">
          <comment><![CDATA[
                  This attribute specifies if the query function is enabled and should be used.
                ]]></comment>
          <default>true</default>
        </attributeBoolean>
        <maxLength>0</maxLength>
        <default>clockGet</default>
      </leafString>
    </element>

    <element name="DurablePolicies" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
              <p>There are two ways for a late joining reader to retrieve historical
              data as a result of calling <tt>wait_for_historical_data()</tt> or
              <tt>DDS_wait_for_historical_data()</tt>.
              <ul>
                <li>The first way is to configure a local durability service
                    that is responsible for the alignment of historical data (see
                    //OpenSplice/DurabilityService). In this case the local durability
                    service will provide historical data to interested readers
                    on the local federations.</li>
                <li>The second way is NOT to run a local durability service, but
                    to request data from a durability service on a remote federation
                    using the client-durability feature. This makes sense in environments
                    where running a full-fledged durability service is not possible or
                    unwanted, e.g., due to resource limitations.</li>
              </ul>
              </p>
              <p>The element //OpenSplice/Domain/DurablePolicies specifies how
              historical data that is retrieved from a remote durability federation
              using the client-durability feature is handled locally. More specifically,
              this element allows the user to indicate whether historical data that
              is requested by a late joining reader using the client-durability feature
              will be made available to the requesting reader only, or to all readers in the
              federation. The behaviour can be specified per partition/topic combination
              in the //OpenSplice/Domain/DurablePolicies/Policy elements.</p>
              <p>In most situations it is sufficient to either configure a local durability
              service to acquire historical data, or to use the client-durability feature,
              but not both. However, it is not forbidden to use both methods concurrently.
              In that case it is advised to configure the system in such a way that historical
              data for a particular partition/topic combination is either provided using
              method 1 or 2. In the event that historical data for the same partition/topic
              combination can be requested via both methods, methods 1 will be used.</p>
          ]]></comment>
      <element name="Policy" minOccurrences="0" maxOccurrences="0" version="COMMUNITY">
        <comment><![CDATA[
                    <p>The policy specifies whether historical data that matches the pattern
                    specified in the //OpenSplice/Domain/DurablePolicies/Policy[@obtain]
                    attribute is cached or not. Caching means that the same data is available
                    for late joining readers on the local federation.</p>
                    <p>Multiple policies can be specified. The order of these policies is
                    important: the first policy that matches (from top to bottom) will
                    be applied.</p>
                    <p>If no policy is specified then the default policy is applied. The
                    default policy is to deliver requested historical data to all readers.</p>
                ]]></comment>
        <attributeString name="obtain" required="true" version="COMMUNITY">
          <comment><![CDATA[
                    <p>This element specifies the pattern of the partition/topic for
                    which the policy must be applied. The default is *.*.</p>
                  ]]></comment>
          <maxLength>0</maxLength>
          <default>*.*</default>
        </attributeString>
        <attributeBoolean name="cache" required="false" version="COMMUNITY">
          <comment><![CDATA[
                    <p>This element specifies whether or not to cache historical data.
                    If set to TRUE historical data is cached in the local federation
                    for potential other late joiners in the same federation. In this
                    case historical data will only be aligned once for the
                    federation, no matter how many readers are interested. This
                    saves bandwidth and CPU when more than one readers are expected
                    with (partly) the same interest. The downside is that caching
                    historical data will require additional memory even after the
                    reader has taken all its data. If set to FALSE data is not cached.</p>
                    <p>The recommended setting is TRUE when more than one readers
                    for the data are expected and the cost of extra memory can be afforded.
                    In all other circumstances FALSE should be used. The default is TRUE.</p>
                  ]]></comment>
          <default>True</default>
        </attributeBoolean>
      </element>
    </element>
    <leafBoolean name="y2038Ready" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
            <p>The y2038Ready element determines that Vortex OpenSplice will send timestamps to other nodes
            in a 64-bit format which is capable to contain time stamps beyond the year 2038.</p>
            <p>Setting this option to true will force the middleware to communicate with time stamps able to go
            beyond 2038.
            Other nodes before version 6.7 are not able to handle these new time stamps and will no longer
            interact correctly with the node configured with this option.</p>
            From version 6.7 the middleware is internally prepared and calculating with time stamps capable with
            timestamps beyond 2038.
            From version 6.7 nodes are able to detect the timestamps containing time beyond 2038 and
            the older time format. So these nodes will interact correctly with all other nodes.
            In a mixed environment containing versions before 6.7, communication must be in the old timestamp format,
            so this configuration option can not be set.
            In a mixed environment with only versions 6.7 and higher, this configuration option may be set. The
            nodes with this configuration will send timestamps capable beyond 2038. All other nodes will be able
            to interpret these values correctly.
            <br/>See ' time stamps and year 2038 limit' for more background information.
            </p>
           <p>By default this configuration item is set to false.</p>
       ]]></comment>
      <default>false</default>
    </leafBoolean>
  <element name="Filters" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
    <comment><![CDATA[
          Domain Filters are expressions that are applied on the local Domain Service meaning that it affects all local readers
          including services, i.e. filtered out data will not exist on the node.
          By using filters the amount of data that is being send or received can be reduced.<br/><br/>
          Different filters can be specified for different partition-topic
          combinations using the &lt;Filter&gt;-elements.<br/><br/>
          Note: that when a filter is set on a partition topic combination the Durability Service can no longer be master for
          the namespace that contains the given partition-topic combination as it is incomplete by definition.
    ]]></comment>
    <maxLength>0</maxLength>
    <element name="Filter" minOccurrences="0" maxOccurrences="0" version="COMMUNITY">
      <comment><![CDATA[
            This element specifies the filter that is used. The &lt;PartitionTopic&gt;-child
            elements specify the partition-topic combinations to which the
            filter expression is applied.<br/><br/>
            If no filter is defined for a particular partition-topic then all data will be
            send for this partition-topic combination.
            If multiple filters are defined then the first one that matches will be applied.
      ]]></comment>
      <attributeString name="content" required="true" version="COMMUNITY">
        <comment><![CDATA[
              This attribute specifies the expression that is used for filtering.
              The expression is a string that is used as-is without any parameters.
              The filter expression is essentially the where-clauses of an sql expression.
              When data is requested for matching partition-topics only the data
              that matches the filter expression will be aligned. The
              content attribute defaults to the empty string, which means that
              no filter is applied at all.<br/><br/>
              The following escape sequence can be used in expressions: &amp;lt;
              (less than), &amp;gt; (greater than), &amp;quot; (double quote)
              &amp;apos; (apostrophe) and &amp;amp; (ampersand).<br/><br/>
              Examples of expressions are:
              <ul>
                <li>x=1 or x=2</li>
                <li>(id&amp;lt;10) and (name=&quot;test&quot;)</li>
              </ul>
              If an invalid filter expression is provided an error will be logged
              in ospl-error.log.
        ]]></comment>
        <maxLength>0</maxLength>
        <default></default>
      </attributeString>
      <leafString name="PartitionTopic" minOccurrences="0" maxOccurrences="0" version="COMMUNITY">
        <comment><![CDATA[
              This element specifies the partition-topics to which
              the filter expression is applied. A partition-topic
              expression may contain the wildcards '*' to match any number of
              characters and '?' to match one single character.
        ]]></comment>
        <maxLength>0</maxLength>
        <default>*.*</default>
      </leafString>
    </element>
  </element>
  </element>
  <element name="DurabilityService" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
    <comment><![CDATA[
                The responsibilities of the durability service are to realize the durable properties of
                data in an Vortex OpenSplice system. The Durability Service looks for its configuration
                within the 'OpenSplice/DurabilityService' element. The configuration parameters
                that the Durability Service will look for within this element are listed and explained
                in the following subsections.
        ]]></comment>
    <attributeString name="name" required="true" version="COMMUNITY">
      <comment><![CDATA[
                This attribute identifies the configuration for the Durability service.
                Multiple Durability service configurations can be specified in one single
                resource. The actual applicable configuration is determined by the value
                of the name attribute, which must match the one specified under the
                <i>OpenSplice/Domain/Service[@name]</i> in the configuration of
                the DomainService.
            ]]></comment>
      <maxLength>0</maxLength>
      <default>durability</default>
    </attributeString>
    <element name="ClientDurability" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
                Client-durability is a feature that allows clients of this durability
                service to acquire historical data from a remote durability service
                without having to run their own durability service. This element
                controls the characteristics of the client-durability feature. When
                enabled, this durability server will be able to responds to requests
                for historical data from such clients.
                If the <i>OpenSplice/DurabilityService/ClientDurability</i> element is not
                provided, then the durability service will not respond to historical
                data requests from clients.
            ]]></comment>
      <attributeBoolean name="enabled" required="false" version="COMMUNITY">
        <comment><![CDATA[
                    This attribute enables or disables the ability of the durability service
                    to respond to requests for historical data from clients. When the
                    <i>OpenSplice/DurabilityService/ClientDurability[@enabled]</i> attribute
                    is not provided then it is assumed to be TRUE.
                ]]></comment>
        <default>TRUE</default>
      </attributeBoolean>
      <element name="EntityNames" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    This element specifies the names of the various entities used by the
                    client-durability feature of this DurabilityService. The names specified
                    here will be displayed in the Vortex OpenSplice Tuner when viewing the
                    DurabilityService.
                ]]></comment>
        <leafString name="Publisher" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the name of the client-durability publisher.
                    ]]></comment>
          <maxLength>64</maxLength>
          <default>durabilityPublisher</default>
        </leafString>
        <leafString name="Subscriber" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the name of the client-durability subscriber.
                    ]]></comment>
          <maxLength>64</maxLength>
          <default>durabilitySubscriber</default>
        </leafString>
        <leafString name="Partition" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the name of the partition used for
                        client-durability. The default is the same partition as
                        the partition specified for durability (see
                        Opensplice/DurabilityService/EntityNames/Partition)
                    ]]></comment>
          <maxLength>64</maxLength>
          <default>durabilityPartition</default>
        </leafString>
      </element>
    </element>
    <element name="Watchdog" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
                This element controls the characteristics of the Watchdog thread.
            ]]></comment>
      <attributeBoolean name="deadlockDetection" required="false" version="COMMUNITY">
        <comment><![CDATA[
                This attribute drives whether the Watchdog will check for deadlocks and refrain
                from updating its lease and heartbeat in case one or more of its threads do not
                assert their liveliness. Typically this should not be enabled, but it can be
                helpful to ensure certain responsiveness of the durability service and the
                detection of potential deadlocks.
            ]]></comment>
        <default>False</default>
      </attributeBoolean>
      <element name="Scheduling" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    This element specifies the type of OS scheduling class will be
                    used by the thread that announces its liveliness periodically.
                ]]></comment>
        <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the thread priority that will be used by the
                        watchdog thread. Only priorities that are supported by the
                        underlying operating system can be assigned to this element.
                        The user may need special privileges from the underlying operating
                        system to be able to assign some of the privileged priorities.
                    ]]></comment>
          <default>0</default>
          <attributeEnum name="priority_kind" required="false" version="COMMUNITY">
            <comment><![CDATA[
                            This attribute specifies whether the specified
                            Priority is a relative or absolute priority.
                        ]]></comment>
            <value>Relative</value>
            <value>Absolute</value>
            <default>Relative</default>
          </attributeEnum>
        </leafInt>
        <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the thread scheduling class that will be used by
                        the watchdog thread. The user may need the appropriate privileges from
                        the underlying operating system to be able to assign some of the
                        privileged scheduling classes.
                    ]]></comment>
          <value>Timeshare</value>
          <value>Realtime</value>
          <value>Default</value>
          <default>Default</default>
        </leafEnum>
      </element>
    </element>
    <element name="Network" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
                    <p>Applications need to be able to gain access to historical data in a system.
                    When the local DDS service gets connected to a remote DDS service by means
                    of the Networking service, (parts of) the historical data might not be
                    consistent between the local and remote Durability services. The Durability
                    service needs to be able to detect the other available Durability services
                    and exchange historical data with them to keep and/or restore consistency
                    in historical data between them.</p>

                    <p>The Network element provides handles to fine-tune the behavior of the
                    communication between Durability services on different computing nodes on
                    network level. These settings only apply when the Networking service is active.</p>
            ]]></comment>
      <attributeFloat name="latency_budget" required="false" version="COMMUNITY">
        <comment><![CDATA[
                    <p>This attribute controls the latency_budget QoS setting
                    that is used by the Durability service for its communication
                    with other Durability services.</p>
                    <p>It specfies the maximum acceptable delay (in seconds) from
                    the time the data is written until the data is insterted in the
                    cache of the receiving Durability service(s) and the receiver is
                    notified of the fact. The default value is zero, indicating the
                    delay should be minimized.</p>
                ]]></comment>
        <minimum>0.0</minimum>
        <default>0.0</default>
        <dimension>seconds</dimension>
      </attributeFloat>
      <attributeInt name="transport_priority" required="false" version="COMMUNITY">
        <comment><![CDATA[
                    <p>This attribute controls the transport priority QoS
                    setting that is used by the Durability service for its
                    communication with other Durability services.</p>
                    <p>It indicates the importance of the communication of the
                    Durability service with other Durability services in the
                    system. The transport priority specified here will be
                    interpreted by the Networking service and should be
                    used to differentiate the priority between communication
                    of user applications and communication of the Durability
                    service.</p>
                    <p>For example, if the latency of timing-critical application data should not be
                    disturbed by alignment activities between durability services, then this transport
                    priority should be configured lower than the application policy.</p>
                    ]]></comment>
        <minimum>0</minimum>
        <default>0</default>
      </attributeInt>
      <element name="Heartbeat" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    <p>During startup and at runtime, the network topology can change
                    dynamically. This happens when Vortex OpenSplice services are started/stopped
                    or when a network cable is plugged in/out. The Durability services
                    need to keep data consistency in that environment. To detect newly
                    joining services as well as detecting nodes that are leaving, the
                    Durability service uses a hearbeat mechanism. This element allows
                    fine-tuning of this mechanism.</p>

                    <p>Please note this heartbeat mechanism is similar to but not the
                    same as the service liveliness assertion.</p>
                ]]></comment>
        <attributeFloat name="latency_budget" required="false" version="COMMUNITY">
          <comment><![CDATA[
                        This attribute controls the latency budget QoS setting that
                        is only used by the Durability service for sending its heartbeats.
                        It overrules the value of the <i>DurabilityService/Network[@latency_budget]</i>.
                    ]]></comment>
          <minimum>0.0</minimum>
          <default>0.0</default>
        </attributeFloat>
        <attributeInt name="transport_priority" required="false" version="COMMUNITY">
          <comment><![CDATA[
                        This attribute controls the transport priority QoS setting (in seconds) that
                        is only used by the Durability service for for sending its heartbeats.
                        It overrules the value of the <i>DurabilityService/Network[@transport_priorrity]</i>.
                    ]]></comment>
          <minimum>0</minimum>
          <default>0</default>
        </attributeInt>
        <element name="Scheduling" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the scheduling parameters used by the
                        thread that periodically sends the heartbeats.
                    ]]></comment>
          <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
            <comment><![CDATA[
                            This element specifies the thread priority that will be used
                            by the thread that periodically sends the heartbeats. Only
                            priorities that are supported by the underlying operating
                            system can be assigned to this element. The user may need
                            special privileges from the underlying operating system to
                            be able to assign some of the privileged priorities.
                        ]]></comment>
            <default>0</default>
            <attributeEnum name="priority_kind" required="false" version="COMMUNITY">
              <comment><![CDATA[
                                This attribute specifies whether the specified
                                Priority is a relative or absolute priority.
                            ]]></comment>
              <value>Relative</value>
              <value>Absolute</value>
              <default>Relative</default>
            </attributeEnum>
          </leafInt>
          <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
            <comment><![CDATA[
                            This element specifies the thread scheduling class that will
                            be used by the thread that periodically sends the heartbeats.
                            The user may need the appropriate privileges from the underlying
                            operating system to be able to assign some of the privileged
                            scheduling classes.
                        ]]></comment>
            <value>Timeshare</value>
            <value>Realtime</value>
            <value>Default</value>
            <default>Default</default>
          </leafEnum>
        </element>
        <leafFloat name="ExpiryTime" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        <p>This element specifies the maximum amount of time(in seconds) in
                        which the Durability service expects a new heartbeat of
                        other Durability services. This is obviously also the
                        same amount of time in which the Durability service must
                        send a heartbeat itself.</p>
                        <p>Increasing this value will lead to less networking
                        traffic and overhead but also to less responsiveness with
                        respect to the liveliness of a Durability service. Change
                        this value according to the need of your system with respect
                        to these aspects.</p>
                    ]]></comment>
          <default>10.0</default>
          <minimum>0.2</minimum>
          <attributeFloat name="update_factor" required="true" version="COMMUNITY">
            <comment><![CDATA[
                            <p>In case of a (temporary) high CPU load, the scheduling
                            behaviour of the operating system might affect the
                            capability of the Durability service to send its
                            heartbeat 'on time'. This attribute introduces some
                            elasticity in this mechanism by making the service
                            send its heartbeat more often then required by the
                            ExpiryTime.</p>
                            <p>The Durability service will report its liveliness
                            every <i>ExpiryTime</i> multiplied by this
                            <i>update_factor</i>.</p>
                        ]]></comment>
            <minimum>0.1</minimum>
            <maximum>0.9</maximum>
            <default>0.2</default>
          </attributeFloat>
        </leafFloat>
      </element>
      <leafFloat name="InitialDiscoveryPeriod" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                On startup the Durability Service needs to determine, for each namespace, if it has
                to align with other Durability Services in the system or if it has to load the initial
                state from disk (load persistent data). For this the Durability Service will publish a
                request for information and wait for the specified initial discovery period for all
                Durability services to respond. The Durability Service will load the persistent data
                from disk if no response is received within the specified initial discovery period.
                This initial discovery period should be configured greater than the worst case
                expected discovery time which is related to underlying hardware, type of network,
                network configuration, and expected load. If the initial discovery period is too short
                the Durability Service may conclude that there is no running system and load the
                data from disk, which will result in conflicting states ('split-brain syndrome') i.e.
                two separate systems.
                The Durabiltiy Service will wait for at least the full initial discovery period before it
                can continue and become operational, so for fast startup times it is important to keep
                the initial discovery period as small as possible.
                <p>.The metaphoric term 'split-brain syndrome' is sometimes used to highlight the results of
                a temporary outage of communications between two parts of a system. In such a
                situation, the states of the disconnected parts evolve separately and become
                incompatible, so that by the time communication is restored the system has become
                'schizophrenic'.</p>
                 ]]></comment>
        <default>3.0</default>
        <minimum>0.1</minimum>
        <maximum>10.0</maximum>
        <dimension>seconds</dimension>
      </leafFloat>
      <element name="Alignment" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    The Durability service is responsible for keeping its local cache
                    consistent with the other available Durability caches in the
                    system. To do this, it needs to exchange data to recover from
                    inconsistencies. The exchange of durable data to restore
                    consistency is called alignment. This element allows fine-tuning
                    alignment behaviour of the Durability service.
                ]]></comment>
        <attributeFloat name="latency_budget" required="false" version="COMMUNITY">
          <comment><![CDATA[
                        This attribute specifies the latency budget QoS setting (in seconds)
                        that is only used by the Durability service for the alignment of data.
                        It overrules the value of the
                        OpenSplice/DurabilityService/Network[@latency_budget].
                    ]]></comment>
          <minimum>0.0</minimum>
          <default>0.0</default>
        </attributeFloat>
        <attributeInt name="transport_priority" required="false" version="COMMUNITY">
          <comment><![CDATA[
                        This attribute specifies the transport priority QoS setting
                        that is used by the Durability service for the alignment of data.
                        It overrules the value of the
                        <i>DurabilityService/Network[@transport_priorrity]</i> for the
                        alignment of data only.
                    ]]></comment>
          <minimum>0</minimum>
          <default>0</default>
        </attributeInt>
        <leafBoolean name="TimeAlignment" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        <p>This attribute specifies whether time on all nodes in
                        the domain can be considered aligned or not. This setting
                        needs to be consistent for all durability services in the
                        domain. In case there is no time alignment, the durability
                        service needs to align more data to compensate for possible
                        timing gaps between different nodes in the domain.</p>
                        <p>When using DDSI2(e) networking service it is strongly recommended
                        to set this value to 'false'. The asynchronous nature of the DDSI2
                        discovery protocol in combination with TimeAlignment could lead to a
                        gap in transient/persistent data when Durability alignment and DDSI2
                        discovery coincide, which is normal behavior.</p>
                    ]]></comment>
          <default>true</default>
        </leafBoolean>
        <element name="AlignerScheduling" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the scheduling parameters used to
                        control the thread that aligns other durability services.
                    ]]></comment>
          <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
            <comment><![CDATA[
                            This element specifies the thread priority that will be
                            used by the aligner thread. Only priorities that are
                            supported by the underlying operating system can be
                            assigned to this element. The user may need special
                            privileges from the underlying operating system to be
                            able to assign some of the privileged priorities.
                        ]]></comment>
            <default>0</default>
            <attributeEnum name="priority_kind" required="false" version="COMMUNITY">
              <comment><![CDATA[
                                This attribute specifies whether the specified
                                Priority is a relative or absolute priority.
                            ]]></comment>
              <value>Relative</value>
              <value>Absolute</value>
              <default>Relative</default>
            </attributeEnum>
          </leafInt>
          <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
            <comment><![CDATA[
                            This element specifies the thread scheduling class that
                            will be used by the aligner thread. The user may need the
                            appropriate privileges from the underlying operating
                            system to be able to assign some of the privileged
                            scheduling classes.
                        ]]></comment>
            <value>Timeshare</value>
            <value>Realtime</value>
            <value>Default</value>
            <default>Default</default>
          </leafEnum>
        </element>
        <element name="AligneeScheduling" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the scheduling parameters used to
                        control the thread that makes sure the local node becomes
                        and stays aligned.
                    ]]></comment>
          <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
            <comment><![CDATA[
                            This element specifies the thread priority that will be
                            used by the alignee thread. Only priorities that are
                            supported by the underlying operating system can be
                            assigned to this element. The user may need special
                            privileges from the underlying operating system to be
                            able to assign some of the privileged priorities.
                        ]]></comment>
            <default>0</default>
            <attributeEnum name="priority_kind" required="false" version="COMMUNITY">
              <comment><![CDATA[
                                This attribute specifies whether the specified
                                Priority is a relative or absolute priority.
                            ]]></comment>
              <value>Relative</value>
              <value>Absolute</value>
              <default>Relative</default>
            </attributeEnum>
          </leafInt>
          <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
            <comment><![CDATA[
                            This element specifies the thread scheduling class that
                            will be used by the alignee thread. The user may need the
                            appropriate privileges from the underlying operating
                            system to be able to assign some of the privileged
                            scheduling classes
                        ]]></comment>
            <value>Timeshare</value>
            <value>Realtime</value>
            <value>Default</value>
            <default>Default</default>
          </leafEnum>
        </element>
        <element name="RequestCombinePeriod" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        <p>When the Durability service detects an inconsistency with
                        another Durability service, it requests that service to align
                        it. The service that receives this request will restore
                        consistency by sending the requested information. In some
                        cases, the Durability service may receive alignment requests
                        from multiple Durability services for the same information
                        around the same moment in time. To reduce the processing and
                        networking load in that case, the Durability service is
                        capable of aligning multiple Durability services concurrently.</p>
                        <p>The RequestCombinePeriod has 2 child-elements: a setting
                        that is used when the current Durability Service is not yet
                        aligned with all others (<i>Initial</i>) and one for the period
                        after that (<i>Operational</i>). These values specify the maximum
                        amount of time the Durability service is allowed to wait with
                        alignment after an alignment request has been received.</p>
                        <p>Increasing the value will increase the amount of time in
                        which the Durability service restores from inconsistencies,
                        but will decrease the processing and network load in
                        case multiple Durability services need to resolve the
                        same data around the same time. Increasing the value
                        is useful in case Vortex OpenSplice is started at the same time
                        with more than two computing nodes.</p>
                    ]]></comment>
          <leafFloat name="Initial" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
            <comment><![CDATA[
                        This element specifies the maximum amount of time the Durability
                        Service is allowed to wait with alignment after an alignment
                        request has been received and the service itself is not yet
                        considered operational because it has not yet aligned itself
                        with all other Durability Services.
                        ]]></comment>
            <default>0.5</default>
            <minimum>0.01</minimum>
            <maximum>5.0</maximum>
          </leafFloat>
          <leafFloat name="Operational" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
            <comment><![CDATA[
                            This element specifies the maximum amount of time the Durability
                            Service is allowed to wait with alignment after an alignment
                            request has been received and the service itself is already
                            considered operational.
                        ]]></comment>
            <default>0.01</default>
            <minimum>0.01</minimum>
            <maximum>5.0</maximum>
          </leafFloat>
        </element>
        <element name="Partition" minOccurrences="0" maxOccurrences="0" version="COMMUNITY">
          <comment><![CDATA[
                        This tag specified an inter durability communication
                        partition with specific qos settings. Alignment between
                        durability services managed through this partition.
                        In case multiple partitions are defined the partition
                        with the highest alignment_priority that can provide
                        the requested data will be used as data source.
                        By default (no Partition specified) the
                        durability services will use an internal partition
                        that inherits the default qos policies and has the
                        default alignment_priority.
                    ]]></comment>
          <attributeString name="Name" required="true" version="COMMUNITY">
            <comment><![CDATA[
                            The name of the partition to use for alignment.
                        ]]></comment>
            <maxLength>0</maxLength>
            <default>partition</default>
          </attributeString>
          <attributeInt name="alignment_priority" required="false" version="COMMUNITY">
            <comment><![CDATA[
                            This attribute specifies the alignment priority of
                            the partition used by the durability service to
                            select the preferred partition to align from. If
                            no alignment_priority is configured, the service
                            uses 0 as default.
                        ]]></comment>
            <default>0</default>
            <minimum>0</minimum>
          </attributeInt>
          <attributeFloat name="latency_budget" required="false" version="COMMUNITY">
            <comment><![CDATA[
                            This attribute overrules the latency budget for
                            this partition specified at this point.
                        ]]></comment>
            <default>0.0</default>
            <minimum>0.0</minimum>
          </attributeFloat>
          <attributeInt name="transport_priority" required="false" version="COMMUNITY">
            <comment><![CDATA[
                            This attribute overrules the transport priority for
                            this partition specified at this point.
                        ]]></comment>
            <default>0</default>
            <minimum>0</minimum>
          </attributeInt>
        </element>
        <leafFloat name="TimeToWaitForAligner" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                 When all Durability Services in the domain have configured their aligner element
                 as false , none of them is able
                 to act as an aligner for newly-started Durability Services. Therefore late-joining
                 Durability Services will not be able to obtain historical data that is available in the
                 domain.
                 This element specifies the period (in seconds) to wait until an aligner becomes
                 available in the domain. If an aligner does not become available within the period
                 specified by this element, the entire federation will terminate and return with error
                 code 1 (recoverable error).
                 Currently only values between 0.0 and 1.0 are supported, and all non-zero values
                 are interpreted as infinite (so basically the time-out is currently either zero or
                 infinite). The default is 1.0. Note that when the element aligner
                 is set to true the current Durability Service is able to act as aligner for
                 other Durability Services with respect to the specified namespace and the federation
                 will not terminate.
            ]]></comment>
          <minimum>0.0</minimum>
          <maximum>1.0</maximum>
          <default>1.0</default>
        </leafFloat>
      </element>
      <element name="WaitForAttachment" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    The Durability service depends on the Networking service for its
                    communication with other Durability services. Before it starts
                    communicating, it must make sure the Networking service is ready to
                    send the data. This element specifies what services must
                    be available and how long the Durability service must wait for them
                    to become available before sending any data.
                ]]></comment>
        <attributeInt name="maxWaitCount" required="false" version="COMMUNITY">
          <comment><![CDATA[
                        This attribute specifies the number of times the Durability
                        service checks if the services specified in the
                        <i>DurabilityService/Network/WaitForAttachment/ServiceName</i>
                        elements are available before sending any data. The time between
                        two checks is 100ms, so a maxWaitCount of 100 represents 10 seconds.
                        An error is logged if one of the services still is unavailable
                        afterwards. The service will continue after that, but this indicates
                        a problem in the configuration and the service might not function
                        correctly anymore.
                    ]]></comment>
          <minimum>1</minimum>
          <maximum>1000</maximum>
          <default>200</default>
        </attributeInt>
        <leafString name="ServiceName" minOccurrences="1" maxOccurrences="0" version="COMMUNITY">
          <comment><![CDATA[
                   This element specifies the name of the service(s) that the Durability Service waits
                   for, before starting alignment activities for a specific topic-partition combination. If
                   (for example) the communication between Durability Services is dependent on the
                   availability of certain local Network Services, then the Durability Service must wait
                   until these are operational.
                    ]]></comment>
          <default>networking</default>
          <maxLength>0</maxLength>
        </leafString>
      </element>
      <!-- ResendTimeRange not supported yet.
            <leafFloat name="ResendTimeRange" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
                <comment><![CDATA[
                    The period (in seconds) ending with the time of the request, over
                    which the service wants samples produced by a node that has stopped.
                ]]></comment>
                <minimum>0.2</minimum>
                <maximum>2.0</maximum>
                <default>0.7</default>
            </leafFloat>
            -->
    </element>
    <element name="MasterElection" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
                <p>For every namespace and role a single node is elected master, the one to
                provide historical data. This optional element can be used to fine-fune the
                characteristics of the master election algorithm.</p>
                <p>This element is optional, and when used only applies to master election for
                namespaces with non-legacy masterPriority (see
                //OpenSplice/DurabilityService/NameSpaces/Policy[@masterPriority]).</p>
            ]]></comment>
      <leafFloat name="WaitTime" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    Before the durability service elects a master it can waits some time to
                    detect other nodes in the system. Waiting might increase the possibility
                    to elect a better candidate, but slows down the master election process.
                    Electing a master too early may lead to additional alignment actions when
                    a better candidate appears later, because a handover of mastership is needed.
                    When the chance that a better master candicate appears within the WaitTime
                    is small it is advised to set this value to 0.0 (the default).
                ]]></comment>
        <minimum>0.0</minimum>
        <default>0.0</default>
        <maximum>10.0</maximum>
        <dimension>seconds</dimension>
      </leafFloat>
    </element>
    <element name="Persistent" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
                <p>Durable data is divided in transient and persistent data. Transient
                data must stay available for as long as at least one Durability
                service is available in the system. For persistent data it is
                the same, but that type of data must also outlive the downtime
                of the system. The Durability service stores the persistent data
                on permanent storage to realize this. This element can be used
                to fine-tune the behaviour of the Durability service concerning
                the persistent properties of the data.</p>
                <p>Note these elements are only available as part of the DDS
                persistence profile of Vortex OpenSplice.</p>
            ]]></comment>
      <leafString name="StoreDirectory" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    This element determines the location where the persistent data will
                    be stored on disk. If this parameter is not configured,
                    the Durability service will not manage persistent data.
                ]]></comment>
        <maxLength>0</maxLength>
        <default>/tmp/pstore</default>
      </leafString>
      <leafFloat name="StoreSessionTime" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                   The Durability Service has a persistency thread that periodically (in sessions) writes
                   persistent data to disk, this element together with the Element StoreSleepTime can be
                   used to optimize disk access. This element specifies the maximum session time (in
                   seconds) for the persistency thread. After this period of time, it makes sure data is
                   flushed to disk
                ]]></comment>
        <maximum>60.0</maximum>
        <minimum>0.001</minimum>
        <default>20.0</default>
        <dimension>seconds</dimension>
      </leafFloat>
      <leafFloat name="StoreSleepTime" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    <p>This element specifies the period of time (in seconds) the
                    persistency thread sleeps between two sessions. This allows
                    influencing the CPU load of the persistency thread.</p>
                    <p>In most use cases there is no need to change the default value.
                    Only in case the persistency thread takes up too much CPU time
                    so that it prevents other threads from progressing a non-zero value
                    should be used.</p>
                ]]></comment>
        <maximum>10.0</maximum>
        <minimum>0.0</minimum>
        <default>0.0</default>
      </leafFloat>
      <leafEnum name="StoreMode" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    This element specifies the plug-in that is used to store the
                    persistent data on disk. With "XML" mode, the service will store
                    persistent data in XML files. With "KV" mode the service will store
                    persistent data in a key-value store using either sqlite of leveldb
                    to store the data on disk.
                    <p>!!! For "KV" stores, SQLite is supported on linux, Windows, and Solaris; LevelDB is only
                    supported on linux.<p>
                ]]></comment>
        <value>XML</value>
        <value>KV</value>
        <default>XML</default>
      </leafEnum>
      <element name="KeyValueStore" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    This element specifies the key-value store mode parameters. The Storage element specifies
                    the which storage type is used to implement the key-value store. The storage type defaults
                    to Sqlite3 when the storage type is not specified. Using the optional StorageParameters
                    element parameters specific to the used storage implementation can be defined which are
                    passed to the selected storage implementation.
                    This element is only valid when the Persistent/StoreMode element is set to "KV".
                    <p>The "KV" store is currenly only supported on linux (SQLite and LevelDB), Windows (SQLite), and Solaris (SQLite).</p>
                ]]></comment>
        <attributeEnum name="type" required="true" version="COMMUNITY">
          <comment><![CDATA[
                        This attribute specifies the third-party product that is used to implement the KV store.
                        Products currently supported are SQLite and LevelDB.
                        <p>The following types can be selected:
                        <ul>
                          <li>sqlite3 -use sqlite3 as the key value store. Data in the store is stored efficiently
                              as binary blobs. This is the default.</li>
                          <li>sqlite - same as sqlite3. This option is present for backward compatibility.</li>
                          <li>sqlitemt - use sqlite3 as the key value store implementation, but
                             stores the information as readable data. This mode allows a user to inspect the
                             contents of the store, but the store performance will be lower compared to sqlite3
                             because each piece of data must be  translated to readable format. This option is
                             typically used for testing purposes to inspect the contents of the store.<br/>
                             (Note: the abbreviation 'mt' stands for 'multi-table').</li>
                          <li>leveldb - use leveldb as the key value store</li>
                        </ul></p>
                    ]]></comment>
          <value>sqlite3</value>
          <value>sqlite</value>
          <value>sqlitemt</value>
          <value>leveldb</value>
          <default>sqlite3</default>
        </attributeEnum>
        <leafString name="StorageParameters" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                       This element is used to set parameters that are specific to the third-party product
                       used to implement the KV store. The element consists of a list of parameters which
                       are separated by semicolons (';'). Each parameter is either a single name or a
                       key-value pair where the key and the value are separated by a '=' character.
                       Invalid or 'not recognized' values are ignored.
                       <p>* When SQLite is selected as KV store implementation, refer to the Sqlite
                       documentation for full details of the available parameters (see
                       http://www.sqlite.org/pragma.html). The only exceptions are the parameters that
                       the KV store uses itself, which are: locking_mode, journal_mode,
                       wal_autocheckpoint and synchronous.</p>
                       <p>* When LevelDB is selected as the KV store the following parameters are available
                       (the information below has been taken from the current LevelDB
                       documentation the project home page is at http://code.google.com/p/leveldb/)</p>
                       <p>paranoid_checks - boolean
                       <br>If true, the implementation will do aggressive checking of the data it is
                       processing and it will stop early if it detects any errors. This may have
                       unforeseen ramifications: for example, a corruption of one database entry may
                       cause a large number of entries to become unreadable or for the entire database
                       to become unopenable.
                       Default: false</p>
                       <p>write_buffer_size - integer
                       <br>Amount of data to build up in memory (backed by an unsorted log on disk)
                       before converting to a sorted on-disk file. Larger values improve performance,
                       especially during bulk loads. Up to two write buffers may be held in memory at
                       the same time, so you may wish to adjust this parameter to control memory
                       usage. Also, a larger write buffer will result in a longer recovery time the next
                       time the database is opened.
                       Default: 4MB</p>
                       <p>max_open_files - integer
                       <br>Number of open files that can be used by the database. You may need to
                       increase this if your database has a large working set (budget one open file per
                       2MB of working set).
                       Default: 1000</p>
                       <p>block_size - integer
                       <br>Approximate size of user data packed per block. Note that the block size
                       specified here corresponds to uncompressed data. The actual size of the unit
                       read from disk may be smaller if compression is enabled. This parameter can be
                       changed dynamically.
                       Set by the KV store to 1M.</p>
                       <p>verify_checksums - boolean
                       <br>If true, all data read from underlying storage will be verified against
                       corresponding checksums.
                       Default: false</p>
                       <p>fill_cache - boolean
                       <br>Should the data read for this iteration be cached in memory? Callers may wish
                       to set this field to false for bulk scans.
                       Default: true</p>
                    ]]></comment>
          <maxLength>0</maxLength>
          <default>0</default>
        </leafString>
        <element name="Compression" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        <p>This element specifies compression settings for the key-value store.</p>
                        <p>Compression for the persistent store can be used to reduce disk I/O and lower disk
                        space usage at the cost of processing power required to compress and uncompress
                        the persistent data.</p>
                        <p>Compression is set at store creation time. Changing these settings after the store is
                        created will result in an error.</p>
                ]]></comment>
          <attributeEnum name="algorithm" required="true" version="COMMUNITY">
            <comment><![CDATA[
                            <p>This attribute specifies the compression algorithm that is used to store the persistent
                            data in the key-value store.</p>
                            <p>The lzf and snappy compression algorithms are built into the Vortex OpenSplice
                            installation. To use the zlib algorithm a shared library needs to be available on the
                            system, and it must be locatable by way of the current working directory, or via
                            LD_LIBRARY_PATH (on Unix systems) or PATH (on Windows systems).</p>
                        ]]></comment>
            <value>lzf</value>
            <value>snappy</value>
            <value>zlib</value>
            <default>lzf</default>
          </attributeEnum>
          <attributeBoolean name="enabled" required="false" version="COMMUNITY">
            <comment><![CDATA[
                            This attribute specifies whether the key-value store will apply compression for
                            storing persistent data to limit disk usage.
                        ]]></comment>
            <default>true</default>
          </attributeBoolean>
        </element>
      </element>
      <leafInt name="StoreOptimizeInterval" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
               This element determines after how many write actions the persistent set for a
               specific partition-topic combination is optimized on disk. Persistent data is
               sequentially written to disk without removing data that according to key values and
               history policies can be removed. During a store optimize action the Durability
               Service will rewrite the file and thereby remove all disposable data. Note that a long
               interval will minimize the induced mean load but instead increases burst load.
               ]]></comment>
        <maximum>1000000000</maximum>
        <minimum>0</minimum>
        <default>0</default>
      </leafInt>
      <element name="Scheduling" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    This element specifies the scheduling parameters used to
                    control the thread that stores persistent data on permanent
                    storage.
                ]]></comment>
        <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the thread priority that will be used by the
                        persistent thread. Only priorities that are supported by the
                        underlying operating system can be assigned to this element.
                        The user may need special privileges from the underlying operating
                        system to be able to assign some of the privileged priorities.
                    ]]></comment>
          <default>0</default>
          <attributeEnum name="priority_kind" required="false" version="COMMUNITY">
            <comment><![CDATA[
                            This attribute specifies whether the specified
                            Priority is a relative or absolute priority.
                        ]]></comment>
            <value>Relative</value>
            <value>Absolute</value>
            <default>Relative</default>
          </attributeEnum>
        </leafInt>
        <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the thread scheduling class that will be
                        used by the persistent thread. The user may need the appropriate
                        privileges from the underlying operating system to be able to
                        assign some of the privileged scheduling classes.
                    ]]></comment>
          <value>Timeshare</value>
          <value>Realtime</value>
          <value>Default</value>
          <default>Default</default>
        </leafEnum>
      </element>
      <!-- Deprecated parameter-->
      <leafInt name="QueueSize" hidden="true" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
            Maximum number of samples in the persistent queue. The available
            resources determine the maximum value of this setting. Specify
            0 for unlimited resources.
        ]]></comment>
        <minimum>0</minimum>
        <maximum>10000</maximum>
        <default>0</default>
      </leafInt>
    </element>
    <element name="NameSpaces" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
             When a durability service wants to fulfill a particular role for some of the
             namespaces in a domain, it must have some way of deducing the desired behavior
             for those when encountered. For static, small-scale systems this can easily be solved
             by statically configurating this role-behavior for all relevant namespaces for each
             durability service in the domain.
             In dynamic, large scale environments, the updating and maintaining of
             configurations for each durability service when new namespaces enter the domain
             can become quite cumbersome. Dynamic namespaces offer a solution for this
             problem.
             Instead of specifying each namespace seperately, dynamic namespaces introduce
             the concept of namespace policies. A policy defines a generic role for the durability
             service, together with a namespace expression. This expression can contain
             wildcards, and is used to match against each namespace the durability service
             encounters in a domain. The first policy with a matching expression is then applied
             to the new namespace.
             Specifying policies
             Policies are specified in a fall-through manner, which means that the first (top)
             policy to match a namespace is applied. Policies specify a range of options for
             namespaces, which tell the durability service how to handle the data.
             The following items can be configured:
             * Durability
             * Alignee
             * Aligner
             In the dynamic namespace configuration, the NameSpace element (a child of the
             NameSpaces element) only supports a name attribute, which is mandatory. This
             name will be used to match against policies.
            ]]></comment>
      <element name="NameSpace" minOccurrences="1" maxOccurrences="0" version="COMMUNITY">
        <comment><![CDATA[
                    A namespace describes a dependency between data in two or
                    more partitions by means of a partition expression. The
                    dependency specifies that the data within one of the
                    partitions has no right to exist separately from the data in
                    the other partition(s). Namespaces determine which data must
                    be managed by the Durability service. Data that does not
                    match any of the namespaces, is ignored by the Durability service.
                ]]></comment>
        <attributeString name="name" required="false" version="COMMUNITY">
          <comment><![CDATA[
                    This element specifies the name for a namespace. A name is used
                    to match a namespace with a policy.
                  ]]></comment>
          <maxLength>0</maxLength>
          <default>defaultNameSpace</default>
        </attributeString>

        <!-- The durabilityKind attribute is deprecated-->
        <attributeEnum hidden="true" name="durabilityKind" required="false" version="COMMUNITY">
            <comment><![CDATA[
                <p>This element specifies how the durability service
                manages the data within the NameSpace. The original
                durability of the data (determined by the DataWriter
                that wrote it) can be 'weakened' (Persistent > Transient
                > Transient_local). This is useful to improve
                resource usage of the durability service in the
                situation where resource usage is more important
                then fault-tolerance. This parameter cannot be used
                to increase the original durability of samples.</p>
                <p>In case the value of this parameter is larger then
                the value a sample was published with, the sample will
                be handled as specified in the DataWriter durability
                QoS.</p>
                <ul>
                 <li><b>Persistent</b>: Data is maximally handled as persistent.
                                       In practice this means a sample is
                                       handled exactly as specified in the
                                        DataWriter durability QoS that wrote
                                       it.</li>
                 <li><b>Transient</b>: A sample is maximally handled as if it
                                      were published with a transient
                                      durability QoS.</li>
                 <li><b>Transient_Local</b>: Data is maximally handled as if it
                                      were published with a
                                      transient_local durability QoS.</li>
                 <li><b>Durable</b>: Convenience value that behaves equal to
                                    Persistent.</li>
                 </ul>
            ]]></comment>
            <default>Durable</default>
            <value>Durable</value>
            <value>Persistent</value>
            <value>Transient</value>
            <value>Transient_Local</value>
        </attributeEnum>

        <!-- The alignmentKind attribute is deprecated-->
        <attributeEnum hidden="true" name="alignmentKind" required="false" version="COMMUNITY">
            <comment><![CDATA[
                <p>This element determines how the durability service manages
                the data that matches the namespace. Scalability of durable
                data is an issue in large systems. Keeping all historical data
                on each node may not be feasible. Often nodes are interested
                in a small part of the total system data. They are driven
                by both performance (boot time, memory usage, network load,
                CPU load) and fault tolerance (the need for replicates).</p>
                <p>The durability service provides the following
                mechanisms to request and provide historical data:
                <ul>
                <li><b>Initial_And_Aligner</b>: The durability service requests
                historical data at startup and caches it locally. Historical
                data will be available relatively fast for new local data
                readers and the system is more fault-tolerant. However,
                caching of historical data requires a relatively large
                amount of resources and a long boot time. The Durability
                service will also provide historical data to other
                Durability services on a request basis.</li>
                <li><b>Initial</b>: The same as Initial_And_Aligner, except the
                Durability service will not provide other Durability services
                with historical data. This is useful when applications
                on the current node need all the processing and network
                bandwidth and dynamic interference is not allowed.</li>
                <li><b>Lazy</b>: The Durability service caches historical data
                after local application interest arises for the first
                time and a remote Durability service aligns the first
                data reader. Historical data is available relatively slow
                for the first data reader, but for every new data reader
                it is relatively fast. The caching resources are only used
                when local interest in the data arises, so it only requires
                resources if there is actual local interest. However,
                this method provides no fault-tolerance for the domain,
                because the local Durability service is only partly a replica
                and is not able to provide historical data to remote
                Durability service and/or remote data readers.</li>
                <li><b>On_Request</b>: The Durability service will not cache
                historical data, but will align each separate DataReader
                on a request basis (in the situation where it calls
                wait_for_historical_data). Each new DataReader that
                wants historical data therefore leads to a new alignment
                action. This is a good setting to limit the amount of
                resources used on the node, but will potentially lead to
                more network traffic. This method provides no
                fault-tolerance for the domain.</li>
                </ul></p>
            ]]></comment>
            <default>Initial_And_Aligner</default>
            <value>Initial</value>
            <value>Initial_And_Aligner</value>
            <value>Lazy</value>
            <value>On_Request</value>
        </attributeEnum>

        <!-- The mergePolicy attribute is deprecated-->
        <attributeEnum hidden="true" name="mergePolicy" required="false" version="COMMUNITY">
            <comment><![CDATA[
            This tag specifies the merge policy applicable for a
            specific namespace. The following merge policy values are:
            applicable:
            <ul>
            <li>ignore - No alignment will take place. This is also
            the default value if not specified.</li>
            <li>merge - Existing data will remain and data from others
            will be aligned.</li>
            <li>reset - Existing data is removed.</li>
            <li>replace - Existing data is removed and data from
            others will be aligned.</li>
            ]]></comment>
            <default>ignore</default>
            <value>merge</value>
            <value>reset</value>
            <value>replace</value>
            <value>ignore</value>
        </attributeEnum>

        <leafString name="Partition" minOccurrences="0" maxOccurrences="0" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies a partition expression that
                        matches the namespace. A namespace consists of a set of
                        partition expressions. Together they determine the
                        partitions that belong to the namespace. Make sure the
                        different namespaces do not have an overlap in partitions.
                        The default configuration has one namespace containing all
                        partitions. A partition may contain the
                        wildcards '*' to match any number of characters and '?'
                        to match one single character.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default>*</default>
        </leafString>
        <leafString name="PartitionTopic" minOccurrences="0" maxOccurrences="0" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies a partition-topic expression that
                        matches the namespace. A group expression is a
                        combination of a partition- and a topic expression. The
                        notation is 'partition.topic'. A namespace consists of
                        a set of partition-topic expressions. Together they
                        determine the partition-topic combinations that belong
                        to the namespace. Make sure the different namespaces do
                        not have an overlap in expressions. The default
                        configuration has one namespace containing all
                        combinations (*.*). A partition-topic expression may
                        contain the wildcards '*' to match any number of
                        characters and '?' to match one single character.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default>*.*</default>
        </leafString>
      </element>
      <element name="Policy" minOccurrences="0" maxOccurrences="0" version="COMMUNITY">
        <comment><![CDATA[
                    A namespace describes a dependency between data in two or
                    more partitions by means of a partition expression. The
                    dependency specifies that the data within one of the
                    partitions has no right to exist separately from the data in
                    the other partition(s). Namespaces determine which data must
                    be managed by the Durability service. Data that does not
                    match any of the namespaces, is ignored by the Durability service.

                    A template specifies behaviour for a namespace. It
                    matches a namespace name with an expression that may contain
                    wildcards, thereby allowing dynamic configuration for
                    namespaces. The order in which templates are specified is
                    important, as the first matching template
                    will be the one that is selected for a namespace.
                ]]></comment>
        <element name="Merge" minOccurrences="0" maxOccurrences="0" version="COMMUNITY">
          <comment><![CDATA[
            This tag specifies the merge policy applicable for a
            specific namespace. The following merge policy values are
            applicable:
            <ul>
            <li>Ignore - No alignment will take place. This is also the default value if not specified.</li>
            <li>Merge - Existing data will remain and data from others will be aligned.</li>
            <li>Delete - Existing data is removed.</li>
            <li>Replace - Existing data is removed and data from others will be aligned.</li>
            <li>Catchup - Existing data that is not available from others is removed, and data
                          that is added or changed by others will made available.</li>
            </ul>
            Note that the Replace and Catchup merge policies result in the same data set, but their
            instance states may differ after the merge policy has completed. In the Replace merge policy
            all instances present both before and after the merge transitioned through NOT_ALIVE_DISPOSED
            and end up as NEW instances with changes to the instance generation counters. In the Catchup
            merge policy the instance state of the instances that are not changed will remain untouched.

            <p>The scope attribute specifies for which role(s) the mergepolicy will be applied.
            A scope may contain the wildcards '*' to match any number of characters and '?' to match one
            single character.</p>
            ]]></comment>
          <attributeEnum name="type" required="true" version="COMMUNITY">
            <comment><![CDATA[
               The type attribute describes the kind of action required on a namespace state mismatch.
               <ul>
               <li>Ignore: Do nothing in case of a state mismatch. No samples are aligned, and
                 namespace states will not be updated.</li>
               <li>Merge: Merge historical data from other namespace state. This will result in a
                 new namespace state for the durability service that specifies this value.</li>
               <li>Delete: Dispose and delete historical data in case of a state mismatch.
                 Immediately after successful completion of the Delete merge action no transient
                 or persistent data will be available for late-joining readers, and all data in the
                 reader queue of existing readers will be disposed.</li>
               <li>Replace: Dispose and delete historical data in case of a state mismatch, and merge
                 data from another namespace state. This will result in a new namespace state for
                 the durability service that specifies this value. Immediately after successful
                 completion of the Replace merge action the replacement data will be available to
                 late-joining readers, the data in the reader queue of existing readers will be
                 disposed and replaced with the replacement data, and the generation count of the
                 replacement data is increased.</li>
               <li>Catchup: When a state mismatch occurs, instances that do not exist any more are
                 disposed, and instances that have been added or changed are updated. Instances
                 for which no state mismatch occurs are left untouched. Immediately after
                 successful completion of the Catchup merge action the data will be available to
                 existing readers and late-joining readers.</li>
               </ul>
            ]]></comment>
            <default>Ignore</default>
            <value>Ignore</value>
            <value>Merge</value>
            <value>Delete</value>
            <value>Replace</value>
            <value>Catchup</value>
          </attributeEnum>
          <attributeString name="scope" required="true" version="COMMUNITY">
            <comment><![CDATA[
               The scope attribute describes for which scope the merge policy is valid. The scope
               is a role-expression in which wildcards ('*' and '?') are allowed. Roles are matched
               at runtime against this expression to determine which policy applies for that role.
               When a role doesn't match any policy, 'Ignore' is assumed. The order of
               specifying policies is important: the first scope expression that matches a role is
               selected for that role.
            ]]></comment>
            <maxLength>0</maxLength>
            <default>*</default>
          </attributeString>
        </element>
        <attributeString name="nameSpace" required="true" version="COMMUNITY">
          <comment><![CDATA[
                          The element specifies an expression that matches a namespace name.
                          A namespace may contain the wildcards '*' to match any number of
                          characters and '?' to match one single character.
                      ]]></comment>
          <maxLength>0</maxLength>
          <default>*</default>
        </attributeString>
        <attributeEnum name="durability" required="true" version="COMMUNITY">
          <comment><![CDATA[
                        <p>This element specifies how the durability service
                        manages the data within the NameSpace. The original
                        durability of the data (determined by the DataWriter
                        that wrote it) can be 'weakened' (Persistent > Transient
                        > Transient_local). This is useful to improve
                        resource usage of the durability service in the
                        situation where resource usage is more important
                        then fault-tolerance. This parameter cannot be used
                        to increase the original durability of samples.</p>
                        <p>In case the value of this parameter is larger then
                        the value a sample was published with, the sample will
                        be handled as specified in the DataWriter durability
                        QoS.</p>
                        <ul>
                         <li><b>Persistent</b>: Data is maximally handled as persistent. In practice this means a sample is handled exactly as specified in the DataWriter durability QoS that wrote it.</li>
                         <li><b>Transient</b>: A sample is maximally handled as if it were published with a transient durability QoS.</li>
                         <li><b>Transient_Local</b>: Data is maximally handled as if it were published with a transient_local durability QoS.</li>
                         <li><b>Durable</b>: Convenience value that behaves equal to Persistent.</li>
                         </ul>
                    ]]></comment>
          <default>Durable</default>
          <value>Durable</value>
          <value>Persistent</value>
          <value>Transient</value>
          <value>Transient_Local</value>
        </attributeEnum>
        <attributeBoolean name="aligner" required="true" version="COMMUNITY">
          <comment><![CDATA[
This mandatory attribute determines whether the durability service can act as aligner
(provide historical data) for other durability services.
          ]]></comment>
          <default>True</default>
        </attributeBoolean>
        <attributeEnum name="alignee" required="true" version="COMMUNITY">
          <comment><![CDATA[
                        <p>This element determines how the durability service manages
                        the data that matches the namespace. Scalability of durable
                        data is an issue in large systems. Keeping all historical data
                        on each node may not be feasible. Often nodes are interested
                        in a small part of the total system data. They are driven
                        by both performance (boot time, memory usage, network load,
                        CPU load) and fault tolerance (the need for replicates).</p>
                        <p>The durability service provides the following
                        mechanisms to request and provide historical data:
                        <ul>
                        <li><b>Initial</b>: The durability service requests historical data at startup and caches it locally. Historical data will be available relatively fast for new local data readers and the system is more fault-tolerant. However, caching of historical data requires a relatively large amount of resources and a long boot time.</li>
                        <li><b>Lazy</b>: The Durability service caches historical data after local application interest arises for the first time and a remote Durability service aligns the first data reader. Historical data is available relatively slow for the first data reader, but for every new data reader it is relatively fast. The caching resources are only used when local interest in the data arises, so it only requires resources if there is actual local interest. However, this method provides no fault-tolerance for the domain, because the local Durability service is only partly a replica and is not able to provide historical data to remote Durability service and/or remote data readers.</li>
                        <li><b>On_Request</b>: The Durability service will not cache historical data, but will align each separate DataReader on a request basis (in the situation where it calls wait_for_historical_data). Each new DataReader that wants historical data therefore leads to a new alignment action. This is a good setting to limit the amount of resources used on the node, but will potentially lead to more network traffic. This method provides no fault-tolerance for the domain.</li>
                        </ul></p>
                    ]]></comment>
          <default>Initial</default>
          <value>Initial</value>
          <value>Lazy</value>
          <value>On_Request</value>
        </attributeEnum>
        <attributeBoolean name="delayedAlignment" required="false" version="COMMUNITY">
          <comment><![CDATA[
                This element determines if the durability allows delayed alignment of initial data.
                This can be usefull for systems where there can be late-joining nodes with a persistent
                dataset, which by default are then not inserted.
                When this option is enabled, durability will only insert a persistent set from a late joining
                node when no writers have been created in the partitions matched by the namespace!
            ]]></comment>
          <default>False</default>
        </attributeBoolean>
        <attributeBoolean name="equalityCheck" required="false" version="COMMUNITY">
          <comment><![CDATA[
                This element specifies whether or not the durability service should compare its
                current data set with the data set of its aligner before applying the merge policy.
                If this option is enabled the aligner will align its data sets only in case there is
                a difference between his data sets and the data sets of this durability service.
                By default this option is NOT enabled, so data is always aligned even if there is no
                difference between data sets.<br/><br/>
                This option applies to all merge policies except for the IGNORE and DELETE merge
                policy.<br/><br/>
                <b>NOTE</b> Enabling this option may lead to less alignment data at the expense of
                processing power required to calculate hashes to compare the data sets. It is recommended
                to enable this option only for large data sets that do not change often. If this option is
                enabled for data sets that change often then chances of set equality are small, while the
                penalty to calculate hashes still exists.
            ]]></comment>
          <default>False</default>
        </attributeBoolean>
        <attributeInt name="masterPriority" required="false" version="COMMUNITY">
          <comment><![CDATA[
                This attribute sets the master selection priority of the namespace.
                The default value is 255, this allows to modify a single durability service in
                an existing system to become both preferred master as well as non-preferred master
                without having to change the configuration of all durability services.
                The Durability Service will never become master for a namespace when the
                masterPriority is set to zero.
                When set to 255 the durability Service will not use priorities at all, and falls back
                to the legacy master selection algorithm.
                If the masterPriority is set other than 0 and 255 the Durability Service will become master if
                it has the highest masterPriority of all discovered Durability Services for the namespace.
                If multiple Durability Services exist having equally highest masterPriority
                a further selection will be made based on the highest namespace quality of each
                Durability Service (but only if persistent data has not been injected before).
                Then if there are still multiple equally suitable Durability Services the
                Durability Service with the highest system id will be selected.
            ]]></comment>
          <minimum>0</minimum>
          <maximum>255</maximum>
          <default>255</default>
        </attributeInt>
      </element>
    </element>
    <element name="EntityNames" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
                This element specifies the names of the various entities used by the
                DurabilityService. The names specified here will be displayed in the
                Vortex OpenSplice Tuner when viewing the DurabilityService.
            ]]></comment>
      <leafString name="Publisher" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    This element specifies the name of the durability publisher.
                ]]></comment>
        <maxLength>64</maxLength>
        <default>durabilityPublisher</default>
      </leafString>
      <leafString name="Subscriber" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    This element specifies the name of the durability subscriber.
                ]]></comment>
        <maxLength>64</maxLength>
        <default>durabilitySubscriber</default>
      </leafString>
      <leafString name="Partition" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    This element specifies the name of the durability partition.
                ]]></comment>
        <maxLength>64</maxLength>
        <default>durabilityPartition</default>
      </leafString>
    </element>
    <element name="Tracing" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
                    This element controls the amount and type of information that is
                    written into the tracing log by the Durability Service. This is
                    useful to track the Durability Service during application
                    development. In the runtime system it should be turned off.
            ]]></comment>
      <attributeBoolean name="synchronous" required="false" version="COMMUNITY">
        <comment><![CDATA[
                    This attribute specifies whether tracing log updates are synchronous
                    or not. A synchronous update is immediately flushed to disk: there is
                    no buffering and therefore some performance overhead. Only use this
                    option if you are debugging and you want to make sure all Tracing info
                    is on disk when the service crashes.
                ]]></comment>
        <default>FALSE</default>
      </attributeBoolean>
      <leafString name="OutputFile" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    This option specifies where the logging is printed to. Note that
                    "stdout" is considered a legal value that represents "standard out"
                    and "stderr" is a legal value representing "standard error".
                    The default value is an empty string, indicating that all tracing
                    is disabled.
                ]]></comment>
        <maxLength>0</maxLength>
        <default>durability.log</default>
      </leafString>
      <leafBoolean name="Timestamps" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    This element specifies whether the logging must contain timestamps.
                ]]></comment>
        <attributeBoolean name="absolute" required="false" version="COMMUNITY">
          <comment><![CDATA[
                        This attribute specifies whether the timestamps are absolute or
                        relative to the startup time of the service.
                    ]]></comment>
          <default>true</default>
        </attributeBoolean>
        <default>true</default>
      </leafBoolean>
      <leafEnum name="Verbosity" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    This element specifies the verbosity level of the logging
                    information. The higher the level, the more (detailed)
                    information will be logged.
                ]]></comment>
        <value>SEVERE</value>
        <value>WARNING</value>
        <value>INFO</value>
        <value>CONFIG</value>
        <value>FINE</value>
        <value>FINER</value>
        <value>FINEST</value>
        <value>NONE</value>
        <default>INFO</default>
      </leafEnum>
    </element>
  </element>
  <element name="SNetworkService" minOccurrences="0" maxOccurrences="0" version="COMMERCIAL">
    <comment><![CDATA[
            When communication endpoints are located on different computing nodes,
            the data produced using the local DDS service must be communicated to
            the remote DDS service and the other way around. The Networking service
            provides a bridge between the local DDS service and a network interface.
            Multiple Networking services can exist next to each other; each serving
            one (or more) physical network interface(s). The Secure Networking service
            is responsible for forwarding data to the network and for receiving data
            from the network. It can be configured to distinguish multiple
            communication channels with different QoS policies assigned to be able
            to schedule sending and receival of specific messages to provide optimal
            performance for a specific application domain.
        ]]></comment>
    <attributeString name="name" required="true" version="COMMERCIAL">
      <comment><![CDATA[
                This attribute identifies the configuration for the Secure Networking service.
                Multiple Network service configurations can be specified in one single
                resource. The actual applicable configuration is determined by the value
                of the name attribute, which must match the one specified under the
                <i>//OpenSplice/Domain/Service[@name]</i> in the configuration of
                the DomainService.
            ]]></comment>
      <maxLength>0</maxLength>
      <default>snetworking</default>
    </attributeString>
    <element name="Watchdog" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
                This element controls the characteristics of the Watchdog thread.
            ]]></comment>
      <element name="Scheduling" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element specifies the type of OS scheduling class will be
                    used by the thread that announces its liveliness periodically.
                ]]></comment>
        <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the thread priority that will be used by the
                        watchdog thread. Only priorities that are supported by the
                        underlying operating system can be assigned to this element.
                        The user may need special privileges from the underlying operating
                        system to be able to assign some of the privileged priorities.
                    ]]></comment>
          <default>0</default>
          <attributeEnum name="priority_kind" required="false" version="COMMERCIAL">
            <comment><![CDATA[
                            This attribute specifies whether the specified
                            Priority is a relative or absolute priority.
                        ]]></comment>
            <value>Relative</value>
            <value>Absolute</value>
            <default>Relative</default>
          </attributeEnum>
        </leafInt>
        <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the thread scheduling class that will be used by
                        the watchdog thread. The user may need the appropriate privileges from
                        the underlying operating system to be able to assign some of the
                        privileged scheduling classes.
                    ]]></comment>
          <value>Timeshare</value>
          <value>Realtime</value>
          <value>Default</value>
          <default>Default</default>
        </leafEnum>
      </element>
    </element>
    <element name="General" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
                This element contains general parameters that concern the secure networking service
                as a whole.
            ]]></comment>
      <leafString name="NetworkInterfaceAddress" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element specifies which network interface card should be used.
                    Every Secure Networking service is bound to only one network interface card
                    (NIC). The card can be uniquely identified by its corresponding
                    IP address or by its symbolic name (e.g. eth0). If the
                    value "first available" is entered here, the Vortex OpenSplice
                    middleware will try to look up an interface that has
                    the required capabilities.
                 ]]></comment>
        <maxLength>0</maxLength>
        <default>first available</default>
        <attributeBoolean name="forced" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                    This attribute specifies whether only the selected NetworkInterfaceAddress should be used or others can be used too.
                    <ul>
                        <li>false - Specifies that the NetworkInterfaceAddress is first used but when not available another, when available, is used. (default).</li>
                        <li>true - Specifies that only the selected NetworkInterfaceAddress can be used.</li>
                     </ul>
                     ]]></comment>
          <default>false</default>
        </attributeBoolean>
        <attributeBoolean name="ipv6" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                    This attribute specifies whether IPv6 should be used for communication.
                    <ul>
                        <li>false - specifies that IPv4 should be used (default).</li>
                        <li>true - Specifies that IPv6 should be used.</li>
                     </ul>
                     This setting will be overriden & ignored if the element NetworkInterfaceAddress has an explicit value
                     that is unequivocally either an IPv4 or IPv6 address. This attribute is therefore only
                     optionally required to specify IPv6 communication when special values like "first available" or
                     an interface name are used instead of IP addresses.
                     ]]></comment>
          <default>false</default>
        </attributeBoolean>
        <attributeEnum name="bind" required="false">
          <comment><![CDATA[
                        Specifies the bind strategy to be used by the networking
                        service for its sockets.
                        <ul>
                            <li>any - Specifies that the service should bind to the wildcard-address (INADDR_ANY) (default).</li>
                            <li>strict - Specifies that the service should bind to the NetworkingInterfaceAddress.</li>
                        </ul>
                    ]]></comment>
          <value>any</value>
          <value>strict</value>
          <default>any</default>
        </attributeEnum>
        <attributeBoolean name="allowReuse" required="false">
          <comment><![CDATA[
                        By default the networking service will bind to a port
                        allowing other services to bind to the same port as well
                        (so reuse of the port is allowed). By setting this option
                        to 'false', the port is bound exclusively (SO_REUSEADDR
                        disabled).
                         <ul>
                             <li>true - Ports can be reused (SO_REUSEADDR enabled) (default).</li>
                             <li>false - Ports are bound exclusively.</li>
                        </ul>
                    ]]></comment>
          <default>true</default>
        </attributeBoolean>
      </leafString>
      <leafBoolean name="EnableMulticastLoopback" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[EnableMulticastLoopback specifies whether the secure networking service will allow
          IP multicast packets within the node to be visible to all secure networking participants in the node,
          including itself. It must be TRUE for intra-node multicast communications,
          but if a node runs only a single Vortex OpenSplice secure networking service and does not host
          any other networking-capable programs, it may be set to FALSE for improved performance.]]></comment>
        <value>True</value>
        <value>False</value>
        <default>True</default>
      </leafBoolean>
      <leafBoolean name="LegacyCompression" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                     This element specifies if compression is applied after of before fragmentations.
                     When set to TRUE compression is applied after fragmentation which is provided for
                     backward compatibility. When set to FALSE compression is applied before fragmentation.
                     The default value is TRUE.
            ]]></comment>
        <value>True</value>
        <value>False</value>
        <default>True</default>
      </leafBoolean>
      <element name="Reconnection" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                     This element specifies the desired secure networking-behavior with respect to the
                     validity of restoring lost connectivity with remote nodes.
                     Here 'lost connectivity' means a prolonged inability to communicate with a known
                     and still active remote node (typically because of network-issues)
                     that has resulted in such a node being declared 'dead' either by the topology-discovery or
                     lost-reliability being detected by a reliable channel's reactivity-checking mechanism.
                     If automatic reconnection is allowed, communication channels with the now-reachable-again node will be restored,
                     even though reliable data might have been lost during the disconnection period.
                ]]></comment>
        <attributeBoolean name="allowed" required="true" version="COMMERCIAL">
          <comment><![CDATA[
                    This attribute specifies whether the network service must
                    resume communication with an other network service when it
                    has already been seen before but has been disconnected
                    for a while.
                    <ul>
                        <li>false - Specifies that the network service must NOT resume communication. (default).</li>
                        <li>true -  Specifies that the network service must resume communication.</li>
                    </ul>
                    ]]></comment>
          <default>false</default>
        </attributeBoolean>
      </element>
    </element>
    <element name="Partitioning" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
                <p>The Vortex OpenSplice Secure Networking service is capable of leveraging
                the network's multicast and routing capabilities. If some a-priori
                knowledge about the participating
                nodes and their topic and partition interest is available, then the
                secure networking services in the system can be explicitly instructed to use
                specific unicast or multicast addresses for its networking traffic.
                This is done by means of so-called network partitions</p>
                <p>A network partition is defined by one or more unicast, multicast
                of broadcast IP addresses. Any secure networking service that is started
                will read the network partition settings and, if applicable, join
                the required multicast groups. For every sample distributed by the
                secure networking service, both its partition and topic name will be
                inspected. In combination with a set of network partition mapping rules,
                the service will determine to which network partition the sample is
                written. The mapping rules are configurable as well.</p>
                <p>Using
                networking configuration, nodes can be disconnected from any
                networking partition. If a node is connected via a low speed
                interface, it is not capable of receiving high volume data. If
                the DCPS partitioning is designed carefully, high volume data is
                published into a specific partition, which on its turn is mapped
                onto a specific networking partition, which on its turn is only
                connected to those nodes that are capable of handling high volume data.</p>
            ]]></comment>
      <element name="GlobalPartition" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element specifies the global or default secure networking partition.
                ]]></comment>
        <attributeString name="Address" required="true" version="COMMERCIAL">
          <comment><![CDATA[
                        The global
                        networking partition transports data that is either meant
                        to be global, like discovery heartbeats, or that is not
                        mapped onto any other networking partition. The address is a list
                        of one or more unicast, multicast or broadcast addresses. If more
                        than one address is specified, then the different
                        addresses are separated by a colon (,) semicolon (;) or space ( ).
                        Samples for the global partition will be sent to all addresses
                        that are specified in this list of addresses. To specify the
                        default broadcast address, use the expression "broadcast".
                        Addresses can be entered as dotted decimal notation or as the
                        symbolic hostname, in which case the middleware will try to resolve
                        the corresponding IP address.
                    ]]></comment>
          <default>broadcast</default>
          <maxLength>0</maxLength>
        </attributeString>
        <attributeString name="SecurityProfile" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                     In the context of secure networking, the GlobalPartition element provides
                     support for the attribute SecurityProfile. The attribute is referencing a security
                     profile declared in the context of the Security element.
                     If the given reference is invalid, the global partition configuration is invalid. In this
                     case, the partition will be blocked to prevent unwanted information leaks. A
                     configuration error message will be logged to the ospl-error.log file. If the
                     security feature has been enabled, but no profile is declared, then the NULL profile is
                     used by default: this means that no security is added to the transport
                    ]]></comment>
          <default>nullProfile</default>
          <maxLength>0</maxLength>
        </attributeString>
        <attributeLong name="MulticastTimeToLive" required="false" version="COMMERCIAL">
          <comment><![CDATA[
For each UDP packet sent out, The TimeToLive header value is set to this value for Multicast packets.
By specifying a value of '0', multicast traffic can be confined to the local node, and
such 'loopback' performance is typically optimized by the operating system.
           ]]></comment>
          <minimum>0</minimum>
          <maximum>255</maximum>
          <default>32</default>
        </attributeLong>
      </element>
      <element name="NetworkPartitions" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    Networking configuration can contain a set of networking partitions,
                    which are grouped under the NetworkPartitions element.
                ]]></comment>
        <element name="NetworkPartition" minOccurrences="1" maxOccurrences="0" version="COMMERCIAL">
          <comment><![CDATA[
                        Every NetworkPartition has a name, an address and a connected flag.
                    ]]></comment>
          <attributeString name="Name" required="false" version="COMMERCIAL">
            <comment><![CDATA[
                      The Name attribute identifies a Network Partition; it must be unique to create
                      associations with Element PartitionMappings.
                     ]]></comment>
            <default>networkPartition</default>
            <maxLength>0</maxLength>
          </attributeString>
          <attributeString name="Address" required="true" version="COMMERCIAL">
            <comment><![CDATA[
The address is a list of one or more unicast, multicast or broadcast addresses. If
more than one address is specified, then the different addresses should separated by
commas (,) semicolons (;) or spaces ( ). Samples for this partition will be sent to
all addresses that are specified in this list of addresses. To specify the default
broadcast address, use the expression "broadcast". Addresses can be entered as
'dotted decimal' IPv4 or 'colon-separated hexadecimal' IPv6 notation or as the
symbolic hostname, in which case Vortex OpenSplice will try to resolve the corresponding
IP address.
                        ]]></comment>
            <default>broadcast</default>
            <maxLength>0</maxLength>
          </attributeString>
          <attributeBoolean name="Connected" required="false" version="COMMERCIAL">
            <comment><![CDATA[
                            <p>A node can choose to be not connected to a networking
                            partition by setting the Connected attribute.</p>
                            <p>If a node is connected to a networking partition,
                            it will join the corresponding multicast group and
                            it will receive data distributed over the partition.
                            If it is not connected, data distributed over the
                            partition will not reach the node but will be
                            filtered by the networking interface or multicast
                            enabled switches.</p>
                        ]]></comment>
            <default>true</default>
          </attributeBoolean>
          <attributeBoolean name="Compression" required="false" version="COMMERCIAL">
            <comment><![CDATA[
                            This attribute specifies if networking will apply compression to limit bandwidth
                            for a specific network partition. This provides great flexibility as network
                            partition are dynamically bind to logical partitions. Compression is performed
                            before fragmentation of the messages. To provide backward compatibility the option
                            LegacyCompression (see General options) can be set to provide compression after
                            fragmentation. The following compression values are allowed:
                            <ul>
                                <li>false - No compression is applied. This is also the default value if not specified.</li>
                                <li>true - Compression is applicable</li>
                            </ul>
                        ]]></comment>
            <default>false</default>
          </attributeBoolean>
          <attributeString name="SecurityProfile" required="false" version="COMMERCIAL">
            <comment><![CDATA[
                       In the context of secure networking, the NetworkPartition element provides
                       support for the attribute SecurityProfile. The attribute is referencing a security
                       profile declared in the context of the Security element.
                       If the given reference is invalid, the network partition configuration is invalid. In
                       this case the partition will be blocked to prevent unwanted information leaks. A
                       configuration error message will be logged to the ospl-error.log file. If the
                       security feature has been enabled but no profile is declared, the NULL profile will be
                       used by default.
                       The ordering of network partition declarations in the OSPL configuration file must
                       be the same for all nodes within the Vortex OpenSplice domain. If certain nodes shall not
                       use one of the network partitions, the network partition in question must be declared
                       as connected="false". In this case the declared security profile would not be
                       evaluated or initialized, and the associated secret cipher keys need not to be defined
                       for the Vortex OpenSplice node in question.
                        ]]></comment>
            <default>nullProfile</default>
            <maxLength>0</maxLength>
          </attributeString>
          <attributeLong name="MulticastTimeToLive" required="false" version="COMMERCIAL">
            <comment><![CDATA[
For each UDP packet sent out, The TimeToLive header value is set to this value for Multicast packets.
By specifying a value of '0', multicast traffic can be confined to the local node, and
such 'loopback' performance is typically optimized by the operating system
              ]]></comment>
            <minimum>0</minimum>
            <maximum>255</maximum>
            <default>32</default>
          </attributeLong>
        </element>
      </element>
      <element name="IgnoredPartitions" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element is used to group the set of IgnoredPartition elements.
                ]]></comment>
        <element name="IgnoredPartition" minOccurrences="1" maxOccurrences="0" version="COMMERCIAL">
          <comment><![CDATA[
                        This element can be used to create a "Local Partition" that is only
                        available on the node on which it is specified, and therefore won't
                        generate network-load. Any DCPS partition-topic combination specified
                        in this element will not be distibuted by the Networking service.
                    ]]></comment>
          <attributeString name="DCPSPartitionTopic" required="true" version="COMMERCIAL">
            <comment><![CDATA[
                            The Networking service will match any DCPS messages
                            to the DCPSPartitionTopic expression and determine
                            if it matches. The PartitionExpression and
                            TopicExpression are allowed to contain a '*' wildcard,
                            meaning that anything matches. An exact match is
                            considered better than a wildcard match. If a DCPS messages
                            matches an expression it will not be send to the network.
                        ]]></comment>
            <default>*.*</default>
            <maxLength>0</maxLength>
          </attributeString>
        </element>
      </element>
      <element name="PartitionMappings" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element is used to group the set of PartitionMapping elements.
                ]]></comment>
        <element name="PartitionMapping" minOccurrences="1" maxOccurrences="0" version="COMMERCIAL">
          <comment><![CDATA[
                        <p>This element specifies a mapping between a network partition
                        and a partition-topic combination.</p>
                        <p>In order to give networking partitions a meaning in the context
                        of DCPS, mappings from DCPS partitions and topics onto networking
                        partitions should be defined. Networking allows for a set of
                        partition mappings to be defined.</p>
                    ]]></comment>
          <attributeString name="NetworkPartition" required="true" version="COMMERCIAL">
            <comment><![CDATA[
                            The NetworkPartition attribute of a partition mapping
                            defines that networking partitition that data in a
                            specific DCPS partition of a specific DCPS topic
                            should be sent to.
                        ]]></comment>
            <default>networkPartition</default>
            <maxLength>0</maxLength>
          </attributeString>
          <attributeString name="DCPSPartitionTopic" required="true" version="COMMERCIAL">
            <comment><![CDATA[
                            The Networking service will match any DCPS messages
                            to the DCPSPartitionTopic expression and determine
                            if it matches. The PartitionExpression and
                            TopicExpression are allowed to contain a '*' wildcard,
                            meaning that anything matches. An exact match is
                            considered better than a wildcard match. For every
                            DCPS message, the best matching partition is determined
                            and the data is sent over the corresponding networking
                            partition as specified by the matching
                            <i>NetworkPartition</i> element.
                        ]]></comment>
            <default>*.*</default>
            <maxLength>0</maxLength>
          </attributeString>
        </element>
      </element>
    </element>
    <element name="Security" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
                The Security section defines the parameters relevant for secure networking.
                Declaring this element in the OSPL configuration file will activate the secure
                networking feature. Without any additional security settings, all network partitions
                of the node would use the NULL cipher encoding. If confidentiality and integrity is
                required for a network partition, the network partition must be associated with a
                security profile
            ]]></comment>
      <attributeBoolean name="enabled" required="false" version="COMMERCIAL">
        <comment><![CDATA[
                        This is an optional attribute. If not defined it defaults to true and all network
                        partitions, if not specified otherwise, will be encoded using the NULL cipher. The
                        NULL cipher does not provide for any level of integrity or confidentiality, but
                        message items will be sent unencrypted.
                        In case of enabled="false" the security feature will not be activated, and the
                        node acts like any other Vortex OpenSplice node not being security aware. Security profiles
                        defined in the configuration file will not take effect, but will cause the system to log
                        warnings.
                    ]]></comment>
        <values>true</values>
        <values>false</values>
        <default>false</default>
      </attributeBoolean>
      <element name="SecurityProfile" minOccurrences="0" maxOccurrences="0" version="COMMERCIAL">
        <comment><![CDATA[
                   This element defines the security profile which can be applied to one or more
                   network partitions. This element is optional.
                ]]></comment>
        <attributeString name="Name" required="true" version="COMMERCIAL">
          <comment><![CDATA[
                       This is a mandatory attribute. The name must be unique for all Security Profiles
                       being declared. If the name is not specified, the security profile will be ignored as it
                       cannot be referenced anyway.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default>aSecurityProfile</default>
        </attributeString>
        <attributeString name="Cipher" required="true" version="COMMERCIAL">
          <comment><![CDATA[
                        This is a mandatory attribute. Depending on the declared cipher, the cipher key must
                        have a specific length, 128 bits, 192 bits, 256 bits or none at all. The following
                        case-insensitive values are supported by the current implementation:
                        <ul>
                            <li>aes128, implements the AES cipher with 128 bit cipher-key (16 Bytes, 32 hexadecimal characters). This cipher will occupy 34 bytes of each UDP packet being sent.</li>
                            <li>aes192, implements the AES cipher with 192 bit cipher-key (24 Bytes, 48 hexadecimal characters). This cipher will occupy 34 bytes of each UDP packet being sent.</li>
                            <li>aes256, implements the AES cipher with 256 bit cipher-key (32 Bytes, 64 hexadecimal characters). This cipher will occupy 34 bytes of each UDP packet being sent.</li>
                            <li>blowfish, implements the Blowfish cipher with 128 bit cipher-key (16 Bytes, 32 hexadecimal characters). This cipher will occupy 26 bytes of each UDP packet being sent.</li>
                            <li>null, implements the NULL cipher. The only cipher that does not require a cipher-key. This cipher will occupy 4 bytes of each UDP packet being sent.</li>
                        </ul>
                        All ciphers except for the NULL cipher are combined with SHA1 to achieve data
                        integrity. Also, the rsa- prefix can be added to the ciphers. In this case, digital
                        signatures using RSA will be available.
                    ]]></comment>
          <maxLength>0</maxLength>
          <value>aes128</value>
          <value>aes192</value>
          <value>aes256</value>
          <value>blowfish</value>
          <value>null</value>
          <value>rsa-aes128</value>
          <value>rsa-aes192</value>
          <value>rsa-aes256</value>
          <value>rsa-blowfish</value>
          <value>rsa-null</value>
          <default>null</default>
        </attributeString>
        <attributeString name="CipherKey" required="true" version="COMMERCIAL">
          <comment><![CDATA[
                        The CipherKey attribute is used to define the secret key required by the declared
                        cipher. The value can be a URI referencing an external file containing the secret key,
                        or the secret key can be defined in-place directly as a string value. The key must be
                        defined as a hexadecimal string, each character representing 4 bits of the key, for
                        example. 1ABC represents the 16 bit key 0001 1010 1011 1100. The key must
                        not follow a well-known pattern and must match exactly the key length required by
                        the chosen cipher. In case of malformed cipher-keys, the security profile in question
                        will be marked as invalid. Moreover, each network partition referring to the invalid
                        Security Profile will not be operational and thus traffic will be blocked to prevent
                        information leaks.
                        As all Vortex OpenSplice applications require read access to the XML configuration file,
                        for security reasons it is recommended to store the secret key in an external file in
                        the file system, referenced by the URI in the configuration file. The file must be
                        protected against read and write access from other users on the host. Verify that
                        access rights are not given to any other user or group on the host.

                        Alternatively, storing the secret key in-place in the XML configuration file will give
                        read/write access to all DDS applications joining the same Vortex OpenSplice node.
                        Because of this, the 'in-place' method is strongly discouraged.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
      </element>
      <element name="AccessControl" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    The optional AccessControl element defines settings for access control enforcement
                    and which access control module shall be used.
                ]]></comment>
        <attributeBoolean name="enabled" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                        The access control feature will be activated when enabled="true"
                    ]]></comment>
          <values>true</values>
          <values>false</values>
          <default>false</default>
        </attributeBoolean>
        <attributeString name="policy" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                        The policy attribute references a file containing the access control policy.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <element name="AccessControlModule" minOccurrences="0" maxOccurrences="0" version="COMMERCIAL">
          <comment><![CDATA[
                        The AccessControlModule element defines which access control module will be
                        used. More than one module may be defined. All defined and enabled modules will
                        be used to determine if access should be granted.
                    ]]></comment>
          <attributeBoolean name="enabled" required="false" version="COMMERCIAL">
            <comment><![CDATA[
                            The module specified in the type attribute is used to evaluate access control rules
                            when enabled="true".
                        ]]></comment>
            <values>true</values>
            <values>false</values>
            <default>true</default>
          </attributeBoolean>
          <attributeString name="type" required="false" version="COMMERCIAL">
            <comment><![CDATA[
                            The type attribute defines the access control model type. Currently, Vortex OpenSplice only
                            supports mandatory access control, accordingly the only valid value for this
                            attribute is "MAC".
                        ]]></comment>
            <values>MAC</values>
            <default>none</default>
            <maxLength>0</maxLength>
          </attributeString>
        </element>
      </element>
      <element name="Authentication" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                     The optional Authentication element defines whether additional sender
                     authorization shall be performed. Enabling Authentication requires that a cipher,
                     including RSA (such as rsa-aes256), is used.
                  ]]></comment>
        <attributeBoolean name="enabled" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                         Authentication is performed when enabled is set to true.
                      ]]></comment>
          <values>true</values>
          <values>false</values>
          <default>true</default>
        </attributeBoolean>
        <element name="X509Authentication" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        The X509Authentication element defines where keys and certificates required for
                        X509 authentication may be found.
                    ]]></comment>
          <element name="Credentials" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                           The Credentials element is an optional element. If it is missing, then the node does
                           not sign messages (in other words, does not send credentials).
                       ]]></comment>
            <leafString name="Key" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
              <comment><![CDATA[
                           The Key element references the file containing the key.

                           It is recommended that the absolute path is used. A relative path
                           will be interpreted relative to the directory from which the
                           Vortex OpenSplice daemon is started.
                       ]]></comment>
              <maxLength>0</maxLength>
              <default/>
            </leafString>
            <leafString name="Cert" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
              <comment><![CDATA[
                           The Cert element references the file containing the certificate.

                           It is recommended that the absolute path is used. A relative path
                           will be interpreted relative to the directory from which the
                           Vortex OpenSplice daemon is started.
                       ]]></comment>
              <maxLength>0</maxLength>
              <default/>
            </leafString>
          </element>
          <leafString name="TrustedCertificates" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                        The TrustedCertificates element references a file containing the trusted certificates.

                        It is recommended that the absolute path is used. A relative path
                        will be interpreted relative to the directory from which the
                        Vortex OpenSplice daemon is started.
                    ]]></comment>
            <maxLength>0</maxLength>
            <default/>
          </leafString>
        </element>
      </element>
    </element>
    <element name="Channels" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
                <p>This element is used to group a set of Channels.</p>
                <p>The set of channels define the behaviour of the 'network' concerning
                aspects as priority, reliability and latency budget. By configuring
                a set of channels, the Networking service is able to function as a
                'scheduler' for the network bandwidth. It achieves this by using the
                application-defined DDS QoS policies of the data to select the most
                appropriate channel to send the data.</p>
            ]]></comment>
      <element name="Channel" minOccurrences="1" maxOccurrences="42" version="COMMERCIAL">
        <comment><![CDATA[
                    <p>This element specifies all properties of an individual Channel.</p>
                    <p>The Networking service will make sure messages with a higher
                    priority precede messages with a lower priority and it uses the
                    latency budget to assemble multiple messages into one UDP packet
                    where possible, to optimize the bandwidth usage. Of course, its
                    performance depends heavily on the compatbility of the configured
                    channels with the used DDS QoS policies of the applications.</p>
                ]]></comment>
        <attributeString name="name" required="true" version="COMMERCIAL">
          <comment><![CDATA[
                        The name uniquely identifies the channel.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default>aChannel</default>
        </attributeString>
        <attributeBoolean name="reliable" required="true" version="COMMERCIAL">
          <comment><![CDATA[
                        <p>If this attribute is set to true, the channel sends all messages reliably.
                        If not, data is sent only once (fire-and-forget).</p>
                        <p>The specific channel a message is written into depends on the attached
                        quality of service. Once a message has arrived in a channel, it will be
                        transported with the quality of service attached to the channel. If the
                        reliable attribute happens to be set to true, the message will be sent
                        over the network using a reliability protocol.</p>
                    ]]></comment>
          <default>false</default>
        </attributeBoolean>
        <attributeBoolean name="default" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                        <p>This attribute indicates whether the channel is selected as the
                        default channel in case no channel offers the quality of service
                        requested by a message.</p>
                        <p>The networking channels should be configured corresponding
                        to the quality of service settings that are expected to be
                        requested by the applications. It might happen, however,
                        that none of the available channels meets the requested
                        quality of service for a specific message. In that case,
                        the message will be written into the default channel.</p>
                        <p>Note that only one channel is allowed to have this attribute
                        set to true</p>
                    ]]></comment>
          <default>false</default>
        </attributeBoolean>
        <attributeBoolean name="enabled" required="true" version="COMMERCIAL">
          <comment><![CDATA[
                        This attribute toggles a channel on or off. Toggling a
                        channel between enabled and disabled is a quick alternative
                        for commenting out the corresponding lines in the configuration
                        file.
                    ]]></comment>
          <default>false</default>
        </attributeBoolean>
        <attributeInt name="priority" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                        This attribute sets the transport priority of the channel.
                        Messages sent to the network have a transport_priority
                        quality of service value. Selection of a networking channel
                        is based on the priority requested by the message and the
                        priority offered by the channel. The priority settings
                        of the different channels divide the priority range
                        into intervals. Within a channel, messages are sorted in
                        order of priority.
                    ]]></comment>
          <default>0</default>
        </attributeInt>
        <leafInt name="PortNr" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the port number used by the Channel.
                        Messages for the channel are sent to the port number given.
                        Each channel needs its own unique port number. Please note
                        that 'reliable' channels use a second port, which is the
                        specified PortNr + 1.
                    ]]></comment>
          <minimum>1</minimum>
          <maximum>65535</maximum>
          <default>53400</default>
        </leafInt>
        <leafSize name="FragmentSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        The networking module will fragment large message into smaller
                        fragments with size <b>FragmentSize</b>. These fragments
                        are sent as datagrams to the UDP stack. OS-settings determine
                        the maximum datagram size.
                        The human-readable option lets the user postfix the value with K(ilobyte),
                        M(egabyte) or G(igabtye). For example, 10M results in 10485760 bytes.
                    ]]></comment>
          <minimum>200</minimum>
          <maximum>65535</maximum>
          <default>1300</default>
          <dimension>bytes</dimension>
          <format>unsigned int</format>
        </leafSize>
        <leafInt name="Resolution" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        <p>The resolution indicates the number of milliseconds that
                        this channel sleeps between two consecutive resend or
                        packing actions. Latency budget values are truncated to a
                        multiple of "Resolution" milliseconds.</p>
                        <p>It is considered good practice to specify the ThrottleTreshold consistently throughout
                        the system.</p>
                    ]]></comment>
          <minimum>1</minimum>
          <default>10</default>
          <format>unsigned int</format>
          <dimension>milliseconds</dimension>
        </leafInt>
        <leafInt name="AdminQueueSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        <p>For reliable channels the receiving side needs to keep the sending
                        side informed about the received data and the received control messages.</p>
                        <p>This is done by means of an "AdminQueue". This setting determines the
                        size of this queue, and it must be greater than the maximum number of reliable
                        messages send or received during each "Resolution" milliseconds.</p>
                    ]]></comment>
          <minimum>400</minimum>
          <default>4000</default>
        </leafInt>
        <leafInt name="CompressionBufferSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        <p>When compression on messages is enabled then the CompressionBufferSize specifies the initial
                        size of the compression/decompression buffer. The compression buffer is used to store the messages
                        before they are compressed and send on the network. The decompression buffer is used to decompress
                        the received compressed messages. Note that the actual size of these buffers may be increased when
                        needed.</p>
                    ]]></comment>
          <minimum>65536</minimum>
          <default>131072</default>
          <resolution>bytes</resolution>
        </leafInt>
        <leafInt name="CompressionThreshold" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        <p>When compression on messages is enabled then the CompressionThreshold provides a threshold
                        to start compressing the accumulated data and sending the compressed data on the network.
                        The CompressionThreshold is used to estimate the size of the compressed messages.</p>
                    ]]></comment>
          <minimum>0</minimum>
          <default>0</default>
          <resolution>bytes</resolution>
        </leafInt>
        <element name="Sending" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element describes all properties for the transmitting side
                        of the Channel.
                    ]]></comment>
          <leafBoolean name="CrcCheck" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                       In order to protect Vortex OpenSplice network packets from malicious attack the CrcCheck(cyclic redundancy check) configuration item has been added.
                       CRCs are specifically designed to protect against common types of errors on communication channels.
                       When enabled the integrity of delivered network packets from one DDS process to another is assured.
                       There is a small performance cost using this feature due to the addtional overhead of carrying out the crc calculation.

                       When the sending side is enabled the network packet will contain a valid crc field.
                    ]]></comment>
            <default>false</default>
          </leafBoolean>
          <leafInt name="QueueSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            This element specifies the number of messages the networking queue
                            can contain.
                            Messages sent to the network are written into the networking queue.
                            The networking service will read from this queue. If this
                            queue is full, the writer writing into the queue is suspended
                            and will retry until success. Note that a full networking queue is
                            a symptom of an improperly designed system.
                        ]]></comment>
            <minimum>1</minimum>
            <default>400</default>
          </leafInt>
          <leafSize name="MaxBurstSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            Amount in bytes to be sent at maximum every
                            "Resolution" milliseconds. The default value is set to 1GB per resolution tick. This can be
                            considered "unlimited" as this far exceeds the capacity of modern physical networks.
                            The human-readable option lets the user postfix the value with K(ilobyte),
                            M(egabyte) or G(igabtye). For example, 10M results in 10485760 bytes
                        ]]></comment>
            <minimum>1024</minimum>
            <maximum>1073741823</maximum>
            <default>1073741823</default>
            <dimension>bytes/(resolution interval)</dimension>
          </leafSize>
          <leafSize name="ThrottleLimit" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            Throttling will enable you to further limit (below MaxBurstSize) the amount of data that is
                            sent every Resolution interval. This happens if one of the receiving nodes in the network
                            indicates that it has trouble processing all incoming data. This value is the lower boundary
                            of the range over which the throttling can adapt the limit. If this value is set to the same
                            value (or higher) as MaxBurstSize throttling is disabled.
                            The ThrottleLimit value is not allowed be smaller than the FragmentSize. If a lower value is
                            provided, then the value of FragmentSize is used as ThrottleLimit.
                            The human-readable option lets the user postfix the value with K(ilobyte),
                            M(egabyte) or G(igabtye). For example, 10K results in 10240 bytes
                        ]]></comment>
            <default>10240</default>
            <maximum>4294967295</maximum>
            <dimension>bytes/(resolution interval)</dimension>
          </leafSize>
          <leafInt name="ThrottleThreshold" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            <p>This is the number of unprocessed network fragments that a node will store before it will inform
                            the other nodes in the network that it has trouble processing the incoming data. Those other nodes
                            can use this information to adjust their throttle values, effectively reducing the amount of incoming
                            data in case of a temporary overflow, and increasing again when the node is able to catch up.</p>
                            <p>It is considered good practice to specify the ThrottleTreshold consistently throughout
                            the system.</p>
                        ]]></comment>
            <minimum>2</minimum>
            <default>50</default>
            <dimension>fragments</dimension>
          </leafInt>
          <leafInt name="MaxRetries" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
This element is only applicable for reliable channels.
A reliable channel implements a reliability protocol in which it builds a list of
connected remote services. This protocol expects all connected services to
acknowledge messages within a specific period of time, otherwise messages will be
resent. This element specifies the number of retransmissions the service has to
execute before considering that the addressed service has become unresponsive.
When this happens the remote service will be removed from the reliability protocol
and the channel will no longer expect messages to be acknowledged.
                        ]]></comment>
            <minimum>1</minimum>
            <default>100</default>
          </leafInt>
          <leafInt name="RecoveryFactor" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
A reliable channel implements a reliability protocol in which it builds a list of
connected remote services. This protocol expects all connected services to
acknowledge messages within a specific period of time otherwise messages will be
resent. The expected period of time is specified by this attribute as the number of
resolution ticks. (See also Section 4.4.1.5.1.9, Element Resolution, on page 218.)
The lost message is resent after Resolution * RecoveryFactor milliseconds.
            ]]></comment>
            <minimum>2</minimum>
            <default>3</default>
          </leafInt>
          <leafInt name="DiffServField" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                        This element describes the DiffServ setting the channel will apply to the networking messages.
                        This parameter determines the value of the  diffserv field of the IP version 4 packets send
                        on this channel which allows QoS setting to be applied to the network traffic send on this channel.
                        <br/><br/>
                        Windows platform support for setting the diffserv field is dependent on the OS version.
                        For Windows versions XP SP2 and 2003 to use the diffserv field the following parameter should
                        be added to the register:
                        <br/><br/>
                        HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\TcpIp\Parameters\DisableUserTOSSetting
                        <br/><br/>
                        The type of this parameter is a DWORD and it's value should be set to 0 to allow setting of the diffserv field.
                        <br/><br/>
                        For Windows version 7 or higher a new API (qWAVE) has been introduced For these platforms the specified
                        diffserv value is mapped to one of the support traffic types. The mapping is as follows:
                        1-8 background traffic; 9-40 excellent traffic; 41-55 audio/video traffic; 56 voice traffic; 57-63 control traffic.
                        When Vortex OpenSplice is run without Administrative priveleges then only the diffserv value of 0, 8, 40 or 56 is allowed.
                        ]]></comment>
            <minimum>0</minimum>
            <maximum>255</maximum>
            <default>0</default>
          </leafInt>
          <leafBoolean name="DontRoute" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[The IP DONTROUTE
                              socket option is set to the value specified.]]></comment>
            <value>True</value>
            <value>False</value>
            <default>True</default>
          </leafBoolean>
          <leafBoolean name="DontFragment" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                        Controls whether the "don't fragment" bit (DF) is set on outgoing UDP IPv4 packets.
                        Note that not all operating systems support setting this bit. When the operating
                        system does not support setting the DF bit this option is ignored.
                        ]]></comment>
            <value>True</value>
            <value>False</value>
            <default>False</default>
          </leafBoolean>
          <leafInt name="TimeToLive" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[For each UDP packet sent out, the IP Time To Live
                              header value is set to the value specified.]]></comment>
            <minimum>0</minimum>
            <maximum>255</maximum>
            <default>0</default>
          </leafInt>
          <element name="Scheduling" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            This element specifies the scheduling policies used to control the transmitter
                            thread of the current Channel.
                        ]]></comment>
            <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
              <comment><![CDATA[
                                This element specifies the thread priority that will be used by the transmitter
                                thread. Only priorities that are supported by the underlying operating system
                                can be assigned to this element. The user may need special privileges from the
                                underlying operating system to be able to assign some of the privileged priorities.
                            ]]></comment>
              <default>0</default>
              <attributeEnum name="priority_kind" required="false" version="COMMERCIAL">
                <comment><![CDATA[
                                    This attribute specifies whether the specified
                                    <i>Priority</i> is a relative or absolute priority.
                                ]]></comment>
                <value>Relative</value>
                <value>Absolute</value>
                <default>Relative</default>
              </attributeEnum>
            </leafInt>
            <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
              <comment><![CDATA[
                                This element specifies the thread scheduling class that will be used by the transmitter
                                thread. The user may need the appropriate privileges from the underlying operating system
                                to be able to assign some of the privileged scheduling classes.
                            ]]></comment>
              <value>Timeshare</value>
              <value>Realtime</value>
              <value>Default</value>
              <default>Default</default>
            </leafEnum>
          </element>
        </element>
        <element name="Receiving" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element describes all properties for the receiving side
                        of the Channel.
                    ]]></comment>
          <leafBoolean name="CrcCheck" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                       In order to protect Vortex OpenSplice network packets from malicious attack the CrcCheck(cyclic redundancy check) configuration item has been added.
                       CRCs are specifically designed to protect against common types of errors on communication channels.
                       When enabled the integrity of delivered network packets from one DDS process to another is assured.
                       There is a small performance cost using this feature due to the addtional overhead of carrying out the crc calculation.

                       When the receiving side is enabled only network packets that contain a valid crc field are accepted.
                    ]]></comment>
            <default>false</default>
          </leafBoolean>
          <leafSize name="ReceiveBufferSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            The UDP receive buffer of the best effort channel socket is
                            set to the value given. If many message are lost, the
                            receive buffer size has to be increased.
                            The human-readable option lets the user postfix the value with K(ilobyte),
                            M(egabyte) or G(igabtye). For example, 10M results in 10485760 bytes.
                        ]]></comment>
            <minimum>1024</minimum>
            <default>1000000</default>
            <resolution>bytes</resolution>
          </leafSize>
          <element name="Scheduling" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            This element specifies the scheduling policies used to control the
                            receiver thread of the current Channel.
                        ]]></comment>
            <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
              <comment><![CDATA[
                                This element specifies the thread priority that will be used by the receiver
                                thread. Only priorities that are supported by the underlying operating system
                                can be assigned to this element. The user may need special privileges from
                                the underlying operating system to be able to assign some of the privileged
                                priorities.
                            ]]></comment>
              <default>0</default>
              <attributeEnum name="priority_kind" required="false" version="COMMERCIAL">
                <comment><![CDATA[
                                    This attribute specifies whether the specified
                                    <i>Priority</i> is a relative or absolute priority.
                                ]]></comment>
                <value>Relative</value>
                <value>Absolute</value>
                <default>Relative</default>
              </attributeEnum>
            </leafInt>
            <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
              <comment><![CDATA[
                                This element specifies the thread scheduling class that will be used by the receiver
                                thread. The user may need the appropriate privileges from the underlying operating
                                system to be able to assign some of the privileged scheduling classes.
                            ]]></comment>
              <value>Timeshare</value>
              <value>Realtime</value>
              <value>Default</value>
              <default>Default</default>
            </leafEnum>
          </element>
          <leafSize name="DefragBufferSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            The maximum number of Fragment buffers that will be allocated for
                            this channel. These buffers are used to store incoming fragments
                            waiting to be processed, as well as fragments that are being processed.
                            With respect to very large messages be aware that the number of buffers times the
                            fragment size must be sufficient to process the messages otherwise they will be
                            dropped. (See also Element FragmentSize)
                        ]]></comment>
            <minimum>500</minimum>
            <default>5000</default>
            <resolution>fragments</resolution>
          </leafSize>
          <element name="SMPOptimization" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            This option will distribute the processing done for incoming fragements over
                            multiple threads, which will lead to an improved throughput on SMP nodes.
                        ]]></comment>
            <attributeBoolean name="enabled" required="true" version="COMMERCIAL">
              <comment><![CDATA[
                                This attribute toggles the Optimization on or off.
                            ]]></comment>
              <default>true</default>
            </attributeBoolean>
          </element>
          <leafInt name="MaxReliabBacklog" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
This element specifies the maximum number of received fragments maintained in
the channel from a single sender for the purpose of order preservation because an
earlier fragment from that sender is missing. A sender is disconnected and all
maintained fragments are discarded when this number is exceeded. Future
fragments from this sender are only accepted after a disconnect if reconnection is set
to true (see Element Reconnection).
                        ]]></comment>
            <minimum>100</minimum>
            <default>1000</default>
            <resolution>fragments</resolution>
          </leafInt>
          <leafInt name="PacketRetentionPeriod" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            This element specifies the number of milliseconds received packets are retained by the network
                            service for its so-called "reliability-under-publisher-crash" extended reliability
                            protocol. This protocol ensures that a consistent or aligned data-set is received by all
                            alive (receiving) nodes, even though some nodes might not have received some
                            packets at the moment a sending node disappears (for whatever reason). The
                            protocol implies that each node retains sufficient received data so that it can be
                            (re-)distributed if a publishing node disappears before all receiving nodes are
                            "up-to-date". When the PacketRetentionPeriod element is set to 0 (the default
                            value), the alignment amongst receiving nodes will not occur. To activate the
                            extended realibility protocol, this setting must be configured to a time period that
                            exceeds the worst-case death-detection time as configured for the discovery
                            protocol of the set of distributed networking services in the system.
                        ]]></comment>
            <minimum>0</minimum>
            <default>0</default>
            <resolution>ms</resolution>
          </leafInt>
          <leafInt name="ReliabilityRecoveryPeriod" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            This element specifies a timeout period (in milliseconds) for the alignment phase of the extended
                            reliability protocol. It only has an effect when the related
                            PacketRetentionperiod is set to a non-zero value. After the specified
                            reliabilityRecoveryPeriod timeout, any data retained for the purpose of
                            alignment of receiving nodes (following the disappearance or crash of a publishing
                            node) will be discarded. The value of this timeout period must be sufficient to allow
                            for the worst-case alignment-time of any "missed" data by individual receiving
                            nodes following the disappearance of a sending node in the system.
                        ]]></comment>
            <minimum>0</minimum>
            <default>1000</default>
            <resolution>ms</resolution>
          </leafInt>
        </element>
        <leafString name="AllowedPorts" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                AllowedPorts specifies the port numbers available for the network service to be used by the
                reliable network channels. The network channel is configured with a unique port number. However
                the reliable network channels require a second port number to provide the reliable communication
                service. For this second port number each reliable network channel will select a free port from
                the AllowedPorts.
                When the AllowedPorts is not specified for a particular channel then the default AllowedPorts which
                is configured on the Channels element is used. When also the default AllowedPorts is not specified
                each reliable network channel will first try to use the configured portNr + 1 as the second port or
                when this port number is already in use will determine a port number dynamically.
                The AllowedPorts is a list of entries where an entry is a port number or a port number range.
                When the AllowedPorts contains more than one entry then these entries must be seperated by a
                comma (,). A port number range consists of the lower and the upper bound of the port number range,
                where the lower and the upper bound are seperated by a minus (-).
              ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </leafString>
      </element>
      <leafString name="AllowedPorts" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                AllowedPorts specifies the port numbers available for the network service to be used by the
                reliable network channels. The network channel is configured with a unique port number. However
                the reliable network channels require a second port number to provide the reliable communication
                service. For this second port number each reliable network channel will select a free port from
                the AllowedPorts.
                When the AllowedPorts is not specified for a particular channel then the default AllowedPorts which
                is configured on the Channels element is used. When also the default AllowedPorts is not specified
                each reliable network channel will first try to use the configured portNr + 1 as the second port or
                when this port number is already in use will determine a port number dynamically.
                The AllowedPorts is a list of entries where an entry is a port number or a port number range.
                When the AllowedPorts contains more than one entry then these entries must be seperated by a
                comma (,). A port number range consists of the lower and the upper bound of the port number range,
                where the lower and the upper bound are seperated by a minus (-).
        ]]></comment>
        <maxLength>0</maxLength>
        <default/>
      </leafString>
    </element>
    <element name="Discovery" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
                This element is used to configure the various parameters of the Discovery Channel,
                which is used to discover all relevant participating entities in the current Domain.
                The purpose of the discovery process is to build-up and maintain a notion of all
                relevant active nodes within the domain.  The relevance of discovered remote nodes
                can be defined statically (by definition of the so-called Global Partition) and/or
                can be dynamically expanded and maintained by the dynamic-discovery process driven
                by the node's Role and Scope.
            ]]></comment>
      <attributeBoolean name="enabled" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element can be used to enable or disable the Discovery Channel. In case the Discovery
                    Channel is disabled, entities will only detect each others presence implicitly once messages
                    are received for the first time.
                ]]></comment>
        <default>true</default>
      </attributeBoolean>
      <attributeString name="Scope" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This attribute controls the dynamic discovery behaviour of this node within the current Domain.
                    If it is not set, dynamic discovery will be disabled and the networking service will only
                    communicate with nodes that can be reached through the predefined Global Partition. If the Scope
                    attribute is specified, dynamic discovery is enabled and the networking service will be able to
                    communicate with all nodes in the system that have a Role that matches the Scope expression.
                    The Scope expression can contain a comma separated list of wild-card role-expressions. If the
                    role of any  discovered node matches any of the wild-card expressions, the remote node is
                    considered a match and will become part of the communication reach (i.e. the Global Partition)
                    of the current domain.
                ]]></comment>
        <maxLength>512</maxLength>
        <default/>
      </attributeString>
      <leafInt name="PortNr" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element specifies the Port number used by the Discovery Channel.
                ]]></comment>
        <minimum>1</minimum>
        <maximum>65536</maximum>
        <default>3369</default>
      </leafInt>
      <leafString name="ProbeList" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element contains the addresses of the nodes that will be contacted to retrieve an initial
                    list of participating nodes in the current domain that match the specified Scope. Multiple
                    ProbeList addresses can be entered by separating them by a colon (,), semicolon (;) or space( ) .
                    The addresses can be entered as dotted decimal notation or as the symbolic hostname, in which
                    case the middleware will try to resolve the corresponding IP address.
                ]]></comment>
        <maxLength>512</maxLength>
        <default/>
      </leafString>
      <element name="Sending" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element describes all properties for the transmitting side
                    of the Discovery Channel.
                ]]></comment>
        <leafBoolean name="CrcCheck" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                       In order to protect Vortex OpenSplice network packets from malicious attack the CrcCheck(cyclic redundancy check) configuration item has been added.
                       CRCs are specifically designed to protect against common types of errors on communication channels.
                       When enabled the integrity of delivered network packets from one DDS process to another is assured.
                       There is a small performance cost using this feature due to the addtional overhead of carrying out the crc calculation.

                       When the sending side is enabled the network packet will contain a valid crc field.
                    ]]></comment>
          <default>false</default>
        </leafBoolean>
        <leafInt name="DiffServField" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element describes the DiffServ setting the channel will apply to the networking messages.
                        This parameter determines the value of the  diffserv field of the IP version 4 packets send
                        on this channel which allows QoS setting to be applied to the network traffic send on this channel.
                        <br/><br/>
                        Windows platform support for setting the diffserv field is dependent on the OS version.
                        For Windows versions XP SP2 and 2003 to use the diffserv field the following parameter should
                        be added to the register:
                        <br/><br/>
                        HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\TcpIp\Parameters\DisableUserTOSSetting
                        <br/><br/>
                        The type of this parameter is a DWORD and it's value should be set to 0 to allow setting of the diffserv field.
                        <br/><br/>
                        For Windows version 7 or higher a new API (qWAVE) has been introduced For these platforms the specified
                        diffserv value is mapped to one of the support traffic types. The mapping is as follows:
                        1-8 background traffic; 9-40 excellent traffic; 41-55 audio/video traffic; 56 voice traffic; 57-63 control traffic.
                        When Vortex OpenSplice is run without Administrative priveleges then only the diffserv value of 0, 8, 40 or 56 is allowed.
                        ]]></comment>
          <minimum>0</minimum>
          <maximum>255</maximum>
          <default>0</default>
        </leafInt>
        <leafBoolean name="DontRoute" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[The IP DONTROUTE
                              socket option is set to the value specified.]]></comment>
          <value>True</value>
          <value>False</value>
          <default>True</default>
        </leafBoolean>
        <leafBoolean name="DontFragment" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                      Controls whether the "don't fragment" bit (DF) is set on outgoing UDP IPv4 packets.
                      Note that not all operating systems support setting this bit. When the operating
                      system does not support setting the DF bit this option is ignored.
                    ]]></comment>
          <value>True</value>
          <value>False</value>
          <default>False</default>
        </leafBoolean>
        <leafInt name="TimeToLive" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[For each UDP packet sent out, the IP Time To Live
                              header value is set to the value specified.]]></comment>
          <minimum>0</minimum>
          <maximum>255</maximum>
          <default>0</default>
        </leafInt>
        <element name="Scheduling" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the scheduling policies used to control the transmitter thread
                        of the Discovery Channel.
                    ]]></comment>
          <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            This element specifies the thread priority that will be used by the transmitter thread
                            of the Discovery Channel. Only priorities that are supported by the underlying operating
                            system can be assigned to this element. The user may need special privileges from the
                            underlying operating system to be able to assign some of the privileged priorities.
                        ]]></comment>
            <default>0</default>
            <attributeEnum name="priority_kind" required="false" version="COMMERCIAL">
              <comment><![CDATA[
                                This attribute specifies whether the specified
                                <i>Priority</i> is a relative or absolute priority.
                            ]]></comment>
              <value>Relative</value>
              <value>Absolute</value>
              <default>Relative</default>
            </attributeEnum>
          </leafInt>
          <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            This element specifies the thread scheduling class that will be used by the transmitter
                            thread of the Discovery Channel. The user may need the appropriate privileges from the
                            underlying operating system to be able to assign some of the privileged scheduling classes.
                        ]]></comment>
            <value>Timeshare</value>
            <value>Realtime</value>
            <value>Default</value>
            <default>Default</default>
          </leafEnum>
        </element>
        <leafInt name="Interval" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element describes the interval(in milliseconds) at which remote nodes will expect heartbeats from this node.
                    ]]></comment>
          <minimum>10</minimum>
          <default>333</default>
        </leafInt>
        <leafFloat name="SafetyFactor" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        The SafetyFactor is used to set a margin on the discovery sending. This avoids tight timing issues.
                    ]]></comment>
          <minimum>0.2</minimum>
          <maximum>1.0</maximum>
          <default>0.9</default>
        </leafFloat>
        <leafInt name="SalvoSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        During starting and stopping, discovery messages are sent at higher frequency. This SalvoSize sets
                        the number of messages to send during these phases.
                    ]]></comment>
          <minimum>1</minimum>
          <default>3</default>
        </leafInt>
      </element>
      <element name="Receiving" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element describes all properties for the receiving side
                    of the Discovery Channel.
                ]]></comment>
        <leafBoolean name="CrcCheck" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                       In order to protect Vortex OpenSplice network packets from malicious attack the CrcCheck(cyclic redundancy check) configuration item has been added.
                       CRCs are specifically designed to protect against common types of errors on communication channels.
                       When enabled the integrity of delivered network packets from one DDS process to another is assured.
                       There is a small performance cost using this feature due to the addtional overhead of carrying out the crc calculation.

                       When the sending side is enabled the network packet will contain a valid crc field.
                    ]]></comment>
          <default>false</default>
        </leafBoolean>
        <element name="Scheduling" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the scheduling policies used to control the receiver thread
                        of the Discovery Channel.
                    ]]></comment>
          <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            This element specifies the thread priority that will be used by the receiver thread
                            of the Discovery Channel. Only priorities that are supported by the underlying operating
                            system can be assigned to this element. The user may need special privileges from the
                            underlying operating system to be able to assign some of the privileged priorities.
                        ]]></comment>
            <default>0</default>
            <attributeEnum name="priority_kind" required="false" version="COMMERCIAL">
              <comment><![CDATA[
                                This attribute specifies whether the specified
                                <i>Priority</i> is a relative or absolute priority.
                            ]]></comment>
              <value>Relative</value>
              <value>Absolute</value>
              <default>Relative</default>
            </attributeEnum>
          </leafInt>
          <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            This element specifies the thread scheduling class that will be used by the receiver
                            thread of the Discovery Channel. The user may need the appropriate privileges from the
                            underlying operating system to be able to assign some of the privileged scheduling classes.
                        ]]></comment>
            <value>Timeshare</value>
            <value>Realtime</value>
            <value>Default</value>
            <default>Default</default>
          </leafEnum>
        </element>
        <leafInt name="DeathDetectionCount" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies how often a heartbeat from a remote node must miss its Interval before
                        that remote node is considered dead.
                    ]]></comment>
          <minimum>1</minimum>
          <default>6</default>
        </leafInt>
        <leafSize name="ReceiveBufferSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        The UDP receive buffer of the Discovery Channel socket is set to the value given. If
                        many message are lost, the receive buffer size has to be increased.
                    ]]></comment>
          <minimum>1</minimum>
          <default>1000000</default>
        </leafSize>
      </element>
    </element>
    <element name="Tracing" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
                This element controls the amount and type of information that is written into the
                tracing log by the Networking Service. This is useful to track the Networking Service
                during application development. In the runtime system it should be turned off.
            ]]></comment>
      <attributeBoolean name="enabled" required="false" version="COMMERCIAL">
        <comment><![CDATA[
                    This attribute controls whether the tracing option is enabled or not.
                ]]></comment>
        <default>true</default>
      </attributeBoolean>
      <leafString name="OutputFile" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This option specifies where the logging is printed to. Note that "stdout" is considered a
                    legal value that represents "standard out".  The default value is an empty string,
                    indicating that the tracing log will be written to standard out.
                ]]></comment>
        <maxLength>0</maxLength>
        <default>networking.log</default>
      </leafString>
      <leafBoolean name="Timestamps" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element specifies whether the logging must contain timestamps.
                ]]></comment>
        <attributeBoolean name="absolute" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                        This attribute specifies whether the timestamps are absolute
                        or relative to the startup time of the service.
                    ]]></comment>
          <default>true</default>
        </attributeBoolean>
        <default>true</default>
      </leafBoolean>
      <element name="Categories" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element contains the logging properties for various networking categories.
                ]]></comment>
        <leafInt name="Default" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the tracing level used for categories that are not
                        explicitly specified. Level 0 indicates no tracing, level 6 indicates the
                        most detailed level of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Configuration" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Configuration</i> category.
                        This includes the processing of all NetworkService parameters in the config file.
                        Level 0 indicates no tracing, level 6 indicates the most detailed level
                        of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Construction" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Construction</i> category.
                        This includes the creation of all internal processing entities.
                        Level 0 indicates no tracing, level 6 indicates the most detailed level
                        of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Destruction" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Destruction</i> category.
                        This includes the destruction of all internal processing entities when the
                        NetworkService terminates. Level 0 indicates no tracing, level 6 indicates the
                        most detailed level of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Mainloop" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Mainloop</i> category.
                        This includes information about each of the threads spawned by the NetworkService.
                        Level 0 indicates no tracing, level 6 indicates the most detailed level
                        of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Groups" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Groups</i> category.
                        This includes the management of local groups (partition-topic combinations).
                        Level 0 indicates no tracing, level 6 indicates the most detailed level
                        of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Send" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Send</i> category.
                        This includes information about outgoing data.
                        Level 0 indicates no tracing, level 6 indicates the most detailed level
                        of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Receive" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Receive</i> category.
                        This includes information about incoming data.
                        Level 0 indicates no tracing, level 6 indicates the most detailed level
                        of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Throttling" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Throttling</i> category.
                        This includes information about throttling.
                        Level 0 indicates no tracing, level 6 indicates the most detailed level
                        of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Test" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Test</i> category.
                        This is a reserved category used for testing purposes.
                        Level 0 indicates no tracing, level 6 indicates the most detailed level
                        of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Discovery" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Discovery</i> category.
                        This includes all activity related to the discovery channel.
                        Level 0 indicates no tracing, level 6 indicates the most detailed level
                        of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
      </element>
      <leafEnum name="Verbosity" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>The Verbosity attribute sets the level of tracing for all Tracing Catagories. This attribute is an additional method besides the Tracing/Catagories tag to specify trace levels. The difference is that Verbosity sets the level for all catagories similar as by other services whereas the Tracing/Catagories element allows to set the trace level per catagory. The verbosity levels are mapped to Catagory levels as following:</p>
<ul><li><i>none</i>: level 0 (no Networking log)</li>
<li><i>severe</i>:   level 1 </li>
<li><i>warning</i>:  level 2 </li>
<li><i>info</i>:     level 3 </li>
<li><i>config</i>:   level 3 </li>
<li><i>fine</i>:     level 4 </li>
<li><i>finer</i>:    level 5 </li>
<li><i>finest</i>:   level 6 </ul>
          ]]></comment>
        <value>finest</value>
        <value>finer</value>
        <value>fine</value>
        <value>config</value>
        <value>info</value>
        <value>warning</value>
        <value>severe</value>
        <value>none</value>
        <default>none</default>
      </leafEnum>
    </element>
    <element name="Compression" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
                      <p>This group of attributes specifies a compression method to
                      use within the service in partitions where it is enabled. The
                      networking service includes (depending on platform) implementations
                      of zlib, lzf and snappy. Others may be implemented by writing a
                      dynamically-loadable library and configuring it here. See the
                      Vortex OpenSplice release notes for details of how to write such a
                      library.</p>
                      <p>It is imperative that all nodes exchanging compressed data
                      have the same configuration in this section.</p>
                  ]]></comment>
      <attributeString name="PluginLibrary" required="false" version="COMMERCIAL">
        <comment><![CDATA[
                        <p>This attribute names a dynamically loadable library
                        which must contain the code for compressing and decompressing
                        the network data. This may be left blank for the built-in
                        compressors.</p>
                    ]]></comment>
        <maxLength>0</maxLength>
        <default/>
      </attributeString>
      <attributeString name="PluginInitFunction" required="false" version="COMMERCIAL">
        <comment><![CDATA[
                        <p>This attribute specifies an initialization function for a
                        compression plugin to be used within the service. The functions
                        for the built-in compressors are named ospl_comp_zlib_init,
                        ospl_comp_lzf_init and ospl_comp_snappy_init but for convenience
                        they may be specified here as as zlib, lzf or snappy.</p>
                    ]]></comment>
        <maxLength>0</maxLength>
        <default/>
      </attributeString>
      <attributeString name="PluginParameter" required="false" version="COMMERCIAL">
        <comment><![CDATA[
                        <p>Some compression implementations are configurable with
                        respect to the tradeoff between speed and effectiveness. A
                        parameter may be specified here to control this. For example
                        the zlib compressor is configured with an integer between 0
                        (for no compression) to 9 (for maximum compression).</p>
                    ]]></comment>
        <maxLength>0</maxLength>
        <default/>
      </attributeString>
    </element>
    <element name="Debugging" hidden="true" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
       <comment><![CDATA[
                Debug options for networking
            ]]></comment>
        <leafInt name="WaitForDebugger" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            WaitForDebugger
                        ]]></comment>
            <default>0</default>
        </leafInt>
        <leafBoolean name="UseLoopback" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                        UseLoopback
                    ]]></comment>
            <default>false</default>
        </leafBoolean>
        <leafBoolean name="UseComplementPartitions" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                        UseComplementPartitions
                    ]]></comment>
            <default>false</default>
        </leafBoolean>
        <leafBoolean name="NoPacking" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                        NoPacking
                    ]]></comment>
            <default>false</default>
        </leafBoolean>
        <element name="Lossy" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                        Lossy
                    ]]></comment>
            <element name="Receiving" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
                <comment><![CDATA[
                        Lossy
                    ]]></comment>
                <leafBoolean name="BeLossy" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
                    <comment><![CDATA[
                                    BeLossy
                                ]]></comment>
                    <default>false</default>
                </leafBoolean>
                <leafInt name="Threshold" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
                    <comment><![CDATA[
                                        Threshold
                                    ]]></comment>
                    <minimum>1</minimum>
                    <default>5</default>
                </leafInt>
            </element>
            <element name="Sending" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
                <comment><![CDATA[
                        Lossy
                    ]]></comment>
                <leafBoolean name="BeLossy" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
                    <comment><![CDATA[
                                    BeLossy
                                ]]></comment>
                    <default>false</default>
                </leafBoolean>
                <leafInt name="Threshold" minOccurrences="0" maxOccurrences="1"
                    version="COMMERCIAL">
                    <comment><![CDATA[
                                        Threshold
                                    ]]></comment>
                    <minimum>1</minimum>
                    <default>5</default>
                </leafInt>
            </element>
        </element>
    </element>
    <element name="Reporting" hidden="true" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <leafEnum name="Level" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                        Level
                  ]]></comment>
        <value>None</value>
        <value>Basic</value>
        <value>Low_frequent</value>
        <value>Medium_frequentne</value>
        <value>High_frequent</value>
        <value>Full</value>
        <default>None</default>
      </leafEnum>
      <leafBoolean name="Events" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                        Events
                  ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafBoolean name="Periodic" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                        Periodic
                  ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafBoolean name="OneShot" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                        OneShot
                  ]]></comment>
        <default>false</default>
      </leafBoolean>
    </element>
    <element name="Profiling" hidden="true" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <leafString name="Outfile" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <maxLength>0</maxLength>
        <default>stdout</default>
      </leafString>
      <element name="ProfDefault" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <leafBoolean name="DoProfiling" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                         DoProfiling
                    ]]></comment>
          <default>false</default>
        </leafBoolean>
        <leafInt name="ReportLaps" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                          ReportLaps
                    ]]></comment>
          <minimum>0</minimum>
          <default>100</default>
        </leafInt>
      </element>
      <element name="Bridge" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <leafBoolean name="DoProfiling" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                         DoProfiling
                    ]]></comment>
          <default>false</default>
        </leafBoolean>
        <leafInt name="ReportLaps" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                          ReportLaps
                    ]]></comment>
          <minimum>0</minimum>
          <default>100</default>
        </leafInt>
      </element>
      <element name="Plug" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <leafBoolean name="DoProfiling" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                         DoProfiling
                    ]]></comment>
          <default>false</default>
        </leafBoolean>
        <leafInt name="ReportLaps" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                          ReportLaps
                    ]]></comment>
          <minimum>0</minimum>
          <default>100</default>
    </leafInt>
      </element>
      <element name="Fragmentation" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <leafBoolean name="DoProfiling" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                         DoProfiling
                    ]]></comment>
          <default>false</default>
        </leafBoolean>
        <leafInt name="ReportLaps" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                          ReportLaps
                    ]]></comment>
          <minimum>0</minimum>
          <default>100</default>
        </leafInt>
      </element>
      <element name="NetworkStack" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <leafBoolean name="DoProfiling" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                         DoProfiling
                    ]]></comment>
          <default>false</default>
        </leafBoolean>
        <leafInt name="ReportLaps" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                          ReportLaps
                    ]]></comment>
          <minimum>0</minimum>
          <default>100</default>
        </leafInt>
      </element>
      <element name="Serialization" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <leafBoolean name="DoProfiling" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                         DoProfiling
                    ]]></comment>
          <default>false</default>
        </leafBoolean>
        <leafInt name="ReportLaps" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                          ReportLaps
                    ]]></comment>
          <minimum>0</minimum>
          <default>100</default>
        </leafInt>
      </element>
    </element>
  </element>
  <element name="NetworkService" minOccurrences="0" maxOccurrences="0" version="COMMERCIAL">
    <comment><![CDATA[
The Network Service provides a bridge between the local DDS service and a
network interface.
<p>The Vortex OpenSplice NetworkService supports both Internet Protocol
Versions 4 and 6 (IPv4 & IPv6) where possible. Please refer to the Release Notes
(Known Issues section) to see if the IPv6 capability is present on your operating
system.</p>
<p>Note that each service instance will only communicate using one of these protocols.
It is an error to specify IPv6 ('colon-separated hexadecimal') and IPv4 ('dotted
decimal') addresses in the same NetworkService configuration.</p>
Multiple Network Services can exist next to each other, each serving one physical
network interface.
Please refer to Applications which operate in multiple domains, for notes about
applications operating in multiple domains and interactions with the Network Service.
The Network Service is responsible for forwarding data to the network and for
receiving data from the network. It can be configured to distinguish multiple
communication channels with different QoS policies assigned to be able to schedule
sending and receival of specific messages to provide optimal performance for a
specific application domain.
The Network Service is selected by using the following configuration element to the
Domain section of the configuration file (Element Application).
<i><br><Service name="networking">
<br><Command>networking</Command>
<br></Service></i>
<br>The network configuration expects a root element named
Vortex OpenSplice/NetworkService. Within this root element, the Network Service
will look for several child-elements. Each of these is listed and explained.
        ]]></comment>
    <attributeString name="name" required="true" version="COMMERCIAL">
      <comment><![CDATA[
                This attribute identifies the configuration for the Networking service.
                Multiple Network service configurations can be specified in one single
                resource. The actual applicable configuration is determined by the value
                of the name attribute, which must match the one specified under the
                <i>//OpenSplice/Domain/Service[@name]</i> in the configuration of
                the DomainService.
            ]]></comment>
      <maxLength>0</maxLength>
      <default>networking</default>
    </attributeString>
    <element name="Watchdog" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
                This element controls the characteristics of the Watchdog thread.
            ]]></comment>
      <element name="Scheduling" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element specifies the type of OS scheduling class will be
                    used by the thread that announces its liveliness periodically.
                ]]></comment>
        <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the thread priority that will be used by the
                        watchdog thread. Only priorities that are supported by the
                        underlying operating system can be assigned to this element.
                        The user may need special privileges from the underlying operating
                        system to be able to assign some of the privileged priorities.
                    ]]></comment>
          <default>0</default>
          <attributeEnum name="priority_kind" required="false" version="COMMERCIAL">
            <comment><![CDATA[
                            This attribute specifies whether the specified
                            Priority is a relative or absolute priority.
                        ]]></comment>
            <value>Relative</value>
            <value>Absolute</value>
            <default>Relative</default>
          </attributeEnum>
        </leafInt>
        <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the thread scheduling class that will be used by
                        the watchdog thread. The user may need the appropriate privileges from
                        the underlying operating system to be able to assign some of the
                        privileged scheduling classes.
                    ]]></comment>
          <value>Timeshare</value>
          <value>Realtime</value>
          <value>Default</value>
          <default>Default</default>
        </leafEnum>
      </element>
    </element>
    <element name="General" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
                This element contains general parameters that concern the networking service
                as a whole.
            ]]></comment>
      <leafString name="NetworkInterfaceAddress" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element specifies which network interface card should be used.
                    Every Networking service is bound to only one network interface card
                    (NIC). The card can be uniquely identified by its corresponding
                    IP address or by its symbolic name (e.g. eth0). If the
                    value "first available" is entered here, the Vortex OpenSplice
                    middleware will try to look up an interface that has
                    the required capabilities.
                 ]]></comment>
        <maxLength>0</maxLength>
        <default>first available</default>
        <attributeBoolean name="forced" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                    This attribute specifies whether only the selected NetworkInterfaceAddress should be used or others can be used too.
                    <ul>
                        <li>false - Specifies that the NetworkInterfaceAddress is first used but when not available another, when available, is used. (default).</li>
                        <li>true - Specifies that only the selected NetworkInterfaceAddress can be used.</li>
                     </ul>
                     ]]></comment>
          <default>false</default>
        </attributeBoolean>
        <attributeBoolean name="ipv6" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                    This attribute specifies whether IPv6 should be used for communication.
                    <ul>
                        <li>false - specifies that IPv4 should be used (default).</li>
                        <li>true - Specifies that IPv6 should be used.</li>
                     </ul>
                     This setting will be overriden & ignored if the element NetworkInterfaceAddress has an explicit value
                     that is unequivocally either an IPv4 or IPv6 address. This attribute is therefore only
                     optionally required to specify IPv6 communication when special values like "first available" or
                     an interface name are used instead of IP addresses.
                     ]]></comment>
          <default>false</default>
        </attributeBoolean>
        <attributeEnum name="bind" required="false">
          <comment><![CDATA[
                        Specifies the bind strategy to be used by the networking
                        service for its sockets.
                        <ul>
                            <li>any - Specifies that the service should bind to the wildcard-address (INADDR_ANY) (default).</li>
                            <li>strict - Specifies that the service should bind to the NetworkingInterfaceAddress.</li>
                        </ul>
                    ]]></comment>
          <value>any</value>
          <value>strict</value>
          <default>any</default>
        </attributeEnum>
        <attributeBoolean name="allowReuse" required="false">
          <comment><![CDATA[
                        By default the networking service will bind to a port
                        allowing other services to bind to the same port as well
                        (so reuse of the port is allowed). By setting this option
                        to 'false', the port is bound exclusively (SO_REUSEADDR
                        disabled).
                         <ul>
                             <li>true - Ports can be reused (SO_REUSEADDR enabled) (default).</li>
                             <li>false - Ports are bound exclusively.</li>
                        </ul>
                    ]]></comment>
          <default>true</default>
        </attributeBoolean>
      </leafString>
      <leafBoolean name="EnableMulticastLoopback" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
          EnableMulticastLoopback specifies whether the networking service will allow
          IP multicast packets within the node to be visible to all networking participants in the node,
          including itself. It must be TRUE for intra-node multicast communications,
          but if a node runs only a single Vortex OpenSplice networking service and does not host
          any other networking-capable programs, it may be set to FALSE for improved performance.
            ]]></comment>
        <value>True</value>
        <value>False</value>
        <default>True</default>
      </leafBoolean>
      <leafBoolean name="LegacyCompression" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                     This element specifies if compression is applied after of before fragmentations.
                     When set to TRUE compression is applied after fragmentation which is provided for
                     backward compatibility. When set to FALSE compression is applied before fragmentation.
                     The default value is TRUE.
            ]]></comment>
        <value>True</value>
        <value>False</value>
        <default>True</default>
      </leafBoolean>
      <element name="Reconnection" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                     This element specifies the desired networking-behavior with respect to the
                     validity of restoring lost connectivity with remote nodes.
                     Here 'lost connectivity' means a prolonged inability to communicate with a known
                     and still active remote node (typically because of network-issues)
                     that has resulted in such a node being declared 'dead' either by the topology-discovery or
                     lost-reliability being detected by a reliable channel's reactivity-checking mechanism.
                     If automatic reconnection is allowed, communication channels with the now-reachable-again node will be restored,
                     even though reliable data might have been lost during the disconnection period.
                ]]></comment>
        <attributeBoolean name="allowed" required="true" version="COMMERCIAL">
          <comment><![CDATA[
                    This attribute specifies whether the network service must
                    resume communication with an other network service when it
                    has already been seen before but has been disconnected
                    for a while.
                    <ul>
                        <li>false - Specifies that the network service must NOT resume communication. (default).</li>
                        <li>true -  Specifies that the network service must resume communication.</li>
                    </ul>
                    ]]></comment>
          <default>false</default>
        </attributeBoolean>
      </element>
    </element>
    <element name="Partitioning" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
                <p>The Vortex OpenSplice Networking service is capable of leveraging
                the network's multicast and routing capabilities. If some a-priori
                knowledge about the participating
                nodes and their topic and partition interest is available, then the
                networking services in the system can be explicitly instructed to use
                specific unicast or multicast addresses for its networking traffic.
                This is done by means of so-called network partitions</p>
                <p>A network partition is defined by one or more unicast, multicast
                of broadcast IP addresses. Any networking service that is started
                will read the network partition settings and, if applicable, join
                the required multicast groups. For every sample distributed by the
                networking service, both its partition and topic name will be
                inspected. In combination with a set of network partition mapping rules,
                the service will determine to which network partition the sample is
                written. The mapping rules are configurable as well.</p>
                <p>Using
                networking configuration, nodes can be disconnected from any
                networking partition. If a node is connected via a low speed
                interface, it is not capable of receiving high volume data. If
                the DCPS partitioning is designed carefully, high volume data is
                published into a specific partition, which on its turn is mapped
                onto a specific networking partition, which on its turn is only
                connected to those nodes that are capable of handling high volume data.</p>
            ]]></comment>
      <element name="GlobalPartition" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element specifies the global or default networking partition.
                    This global network partition transports data that is either meant to be global, like discovery heartbeats,
                    or that is not mapped onto any other network partition.
                ]]></comment>
        <attributeString name="Address" required="true" version="COMMERCIAL">
          <comment><![CDATA[
                        The global
                        networking partition transports data that is either meant
                        to be global, like discovery heartbeats, or that is not
                        mapped onto any other networking partition. The address is a list
                        of one or more unicast, multicast or broadcast addresses. If more
                        than one address is specified, then the different
                        addresses are separated by a colon (,) semicolon (;) or space ( ).
                        Samples for the global partition will be sent to all addresses
                        that are specified in this list of addresses. To specify the
                        default broadcast address, use the expression "broadcast".
                        Addresses can be entered as dotted decimal notation or as the
                        symbolic hostname, in which case the middleware will try to resolve
                        the corresponding IP address.
                        If the value for this attribute is one, or more, 'colon-separated hexadecimal' Internet
                        Protocol Version 6 (IPv6) address(es), then the NetworkService will be
                        configured to use IPv6 for communication.
                    ]]></comment>
          <default>broadcast</default>
          <maxLength>0</maxLength>
        </attributeString>
        <attributeLong name="MulticastTimeToLive" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                      For each UDP packet sent out, the TimeToLive header value is set to this value for
                      Multicast packets.
                      By specifying a value of '0', multicast traffic can be confined to the local node, and
                      such 'loopback' performance is typically optimized by the operating system
                   ]]></comment>
          <minimum>0</minimum>
          <maximum>255</maximum>
          <default>32</default>
        </attributeLong>
      </element>
      <element name="NetworkPartitions" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    Networking configuration can contain a set of networking partitions,
                    which are grouped under the NetworkPartitions element.
                ]]></comment>
        <element name="NetworkPartition" minOccurrences="1" maxOccurrences="0" version="COMMERCIAL">
          <comment><![CDATA[
                        Every NetworkPartition has a name, an address and a connected flag.
                    ]]></comment>
          <attributeString name="Name" required="false" version="COMMERCIAL">
            <comment><![CDATA[
                            A networking partition is uniquely identified by its name.
                        ]]></comment>
            <default>networkPartition</default>
            <maxLength>0</maxLength>
          </attributeString>
          <attributeString name="Address" required="true" version="COMMERCIAL">
            <comment><![CDATA[
                            The address is a list
                            of one or more unicast, multicast or broadcast addresses. If more
                            than one address is specified, then the different
                            addresses are separated by a colon (,) semicolon (;) or space ( ).
                            Samples for this network partition will be sent to all addresses
                            that are specified in this list of addresses. To specify the
                            default broadcast address, use the expression "broadcast".
                            Addresses can be entered as dotted decimal notation or as the
                            symbolic hostname, in which case the middleware will try to
                            resolve the corresponding IP address.
                        ]]></comment>
            <default>broadcast</default>
            <maxLength>0</maxLength>
          </attributeString>
          <attributeBoolean name="Connected" required="false" version="COMMERCIAL">
            <comment><![CDATA[
                            <p>A node can choose to be not connected to a networking
                            partition by setting the Connected attribute.</p>
                            <p>If a node is connected to a networking partition,
                            it will join the corresponding multicast group and
                            it will receive data distributed over the partition.
                            If it is not connected, data distributed over the
                            partition will not reach the node but will be
                            filtered by the networking interface or multicast
                            enabled switches.</p>
                        ]]></comment>
            <default>true</default>
          </attributeBoolean>
          <attributeBoolean name="Compression" required="false" version="COMMERCIAL">
            <comment><![CDATA[
                            This attribute specifies if networking will apply compression to limit bandwidth
                            for a specific network partition. This provides great flexibility as network
                            partition are dynamically bind to logical partitions. Compression is performed
                            before fragmentation of the messages. To provide backward compatibility the option
                            LegacyCompression (see General options) can be set to provide compression after
                            fragmentation. The following compression values are allowed:
                            <ul>
                                <li>false - No compression is applied. This is also the default value if not specified.</li>
                                <li>true - Compression is applicable</li>
                            </ul>
                        ]]></comment>
            <default>false</default>
          </attributeBoolean>
          <attributeString name="SecurityProfile" required="false" version="COMMERCIAL">
            <comment><![CDATA[
              In the context of secure networking, the NetworkPartition element provides
              support for the attribute SecurityProfile. The attribute is referencing a security
              profile declared in the context of the Security element.
              If the given reference is invalid, the network partition configuration is invalid. In
              this case the partition will be blocked to prevent unwanted information leaks. A
              configuration error message will be logged to the ospl-error.log file. If the
              security feature has been enabled but no profile is declared, the NULL profile will be
              used by default.
              The ordering of network partition declarations in the OSPL configuration file must
              be the same for all nodes within the Vortex OpenSplice domain. If certain nodes shall not
              use one of the network partitions, the network partition in question must be declared
              as connected="false". In this case the declared security profile would not be
              evaluated or initialized, and the associated secret cipher keys need not to be defined
              for the Vortex OpenSplice node in question.
                      ]]></comment>
            <default>nullProfile</default>
            <maxLength>0</maxLength>
          </attributeString>
          <attributeLong name="MulticastTimeToLive" required="false" version="COMMERCIAL">
            <comment><![CDATA[For each UDP packet sent out, The TimeToLive header value is set to this value for Multicast packets.]]></comment>
            <minimum>0</minimum>
            <maximum>255</maximum>
            <default>32</default>
          </attributeLong>
        </element>
      </element>
      <element name="IgnoredPartitions" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element is used to group the set of IgnoredPartition elements.
                ]]></comment>
        <element name="IgnoredPartition" minOccurrences="1" maxOccurrences="0" version="COMMERCIAL">
          <comment><![CDATA[
                        This element can be used to create a "Local Partition" that is only
                        available on the node on which it is specified, and therefore won't
                        generate network-load. Any DCPS partition-topic combination specified
                        in this element will not be distibuted by the Networking service.
                    ]]></comment>
          <attributeString name="DCPSPartitionTopic" required="true" version="COMMERCIAL">
            <comment><![CDATA[
                            The Networking service will match any DCPS messages
                            to the DCPSPartitionTopic expression and determine
                            if it matches. The PartitionExpression and
                            TopicExpression are allowed to contain a '*' wildcard,
                            meaning that anything matches. An exact match is
                            considered better than a wildcard match. If a DCPS messages
                            matches an expression it will not be send to the network.
                        ]]></comment>
            <default>*.*</default>
            <maxLength>0</maxLength>
          </attributeString>
        </element>
      </element>
      <element name="PartitionMappings" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element is used to group the set of PartitionMapping elements.
                ]]></comment>
        <element name="PartitionMapping" minOccurrences="1" maxOccurrences="0" version="COMMERCIAL">
          <comment><![CDATA[
                        <p>This element specifies a mapping between a network partition
                        and a partition-topic combination.</p>
                        <p>In order to give networking partitions a meaning in the context
                        of DCPS, mappings from DCPS partitions and topics onto networking
                        partitions should be defined. Networking allows for a set of
                        partition mappings to be defined.</p>
                    ]]></comment>
          <attributeString name="NetworkPartition" required="true" version="COMMERCIAL">
            <comment><![CDATA[
                            The NetworkPartition attribute of a partition mapping
                            defines that networking partitition that data in a
                            specific DCPS partition of a specific DCPS topic
                            should be sent to.
                        ]]></comment>
            <default>networkPartition</default>
            <maxLength>0</maxLength>
          </attributeString>
          <attributeString name="DCPSPartitionTopic" required="true" version="COMMERCIAL">
            <comment><![CDATA[
                            The Networking service will match any DCPS messages
                            to the DCPSPartitionTopic expression and determine
                            if it matches. The PartitionExpression and
                            TopicExpression are allowed to contain a '*' wildcard,
                            meaning that anything matches. An exact match is
                            considered better than a wildcard match. For every
                            DCPS message, the best matching partition is determined
                            and the data is sent over the corresponding networking
                            partition as specified by the matching
                            <i>NetworkPartition</i> element.
                        ]]></comment>
            <default>*.*</default>
            <maxLength>0</maxLength>
          </attributeString>
        </element>
      </element>
    </element>
    <element name="Channels" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
                <p>This element is used to group a set of Channels.</p>
                <p>The set of channels define the behaviour of the 'network' concerning
                aspects as priority, reliability and latency budget. By configuring
                a set of channels, the Networking service is able to function as a
                'scheduler' for the network bandwidth. It achieves this by using the
                application-defined DDS QoS policies of the data to select the most
                appropriate channel to send the data.</p>
            ]]></comment>
      <element name="Channel" minOccurrences="1" maxOccurrences="42" version="COMMERCIAL">
        <comment><![CDATA[
                    <p>This element specifies all properties of an individual Channel.</p>
                    <p>The Networking service will make sure messages with a higher
                    priority precede messages with a lower priority and it uses the
                    latency budget to assemble multiple messages into one UDP packet
                    where possible, to optimize the bandwidth usage. Of course, its
                    performance depends heavily on the compatbility of the configured
                    channels with the used DDS QoS policies of the applications.</p>
                ]]></comment>
        <attributeString name="name" required="true" version="COMMERCIAL">
          <comment><![CDATA[
                        The name uniquely identifies the channel.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default>aChannel</default>
        </attributeString>
        <attributeBoolean name="reliable" required="true" version="COMMERCIAL">
          <comment><![CDATA[
                        <p>If this attribute is set to true, the channel sends all messages reliably.
                        If not, data is sent only once (fire-and-forget).</p>
                        <p>The specific channel a message is written into depends on the attached
                        quality of service. Once a message has arrived in a channel, it will be
                        transported with the quality of service attached to the channel. If the
                        reliable attribute happens to be set to true, the message will be sent
                        over the network using a reliability protocol.</p>
                    ]]></comment>
          <default>false</default>
        </attributeBoolean>
        <attributeBoolean name="default" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                        <p>This attribute indicates whether the channel is selected as the
                        default channel in case no channel offers the quality of service
                        requested by a message.</p>
                        <p>The networking channels should be configured corresponding
                        to the quality of service settings that are expected to be
                        requested by the applications. It might happen, however,
                        that none of the available channels meets the requested
                        quality of service for a specific message. In that case,
                        the message will be written into the default channel.</p>
                        <p>Note that only one channel is allowed to have this attribute
                        set to true</p>
                    ]]></comment>
          <default>false</default>
        </attributeBoolean>
        <attributeBoolean name="enabled" required="true" version="COMMERCIAL">
          <comment><![CDATA[
                        This attribute toggles a channel on or off. Toggling a
                        channel between enabled and disabled is a quick alternative
                        for commenting out the corresponding lines in the configuration
                        file.
                    ]]></comment>
          <default>false</default>
        </attributeBoolean>
        <attributeInt name="priority" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                        This attribute sets the transport priority of the channel.
                        Messages sent to the network have a transport_priority
                        quality of service value. Selection of a networking channel
                        is based on the priority requested by the message and the
                        priority offered by the channel. The priority settings
                        of the different channels divide the priority range
                        into intervals. Within a channel, messages are sorted in
                        order of priority.
                    ]]></comment>
          <default>0</default>
        </attributeInt>
        <leafInt name="PortNr" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the port number used by the Channel.
                        Messages for the channel are sent to the port number given.
                        Each channel needs its own unique port number. Please note
                        that 'reliable' channels use a second port, which is the
                        specified PortNr + 1.
                    ]]></comment>
          <minimum>1</minimum>
          <maximum>65535</maximum>
          <default>53400</default>
        </leafInt>
        <leafSize name="FragmentSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        The networking module will fragment large message into smaller
                        fragments with size <b>FragmentSize</b>. These fragments
                        are sent as datagrams to the UDP stack. OS-settings determine
                        the maximum datagram size.
                    ]]></comment>
          <minimum>200</minimum>
          <maximum>65535</maximum>
          <default>1300</default>
        </leafSize>
        <leafInt name="Resolution" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        <p>The resolution indicates the number of milliseconds that
                        this channel sleeps between two consecutive resend or
                        packing actions. Latency budget values are truncated to a
                        multiple of "Resolution" milliseconds.</p>
                        <p>It is considered good practice to specify the ThrottleTreshold consistently throughout
                        the system.</p>
                    ]]></comment>
          <minimum>1</minimum>
          <default>10</default>
        </leafInt>
        <leafInt name="AdminQueueSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        <p>For reliable channels the receiving side needs to keep the sending
                        side informed about the received data and the received control messages.</p>
                        <p>This is done by means of an "AdminQueue". This setting determines the
                        size of this queue, and it must be greater than the maximum number of reliable
                        messages send or received during each "Resolution" milliseconds.</p>
                    ]]></comment>
          <minimum>400</minimum>
          <default>4000</default>
        </leafInt>
        <leafInt name="CompressionBufferSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        <p>When compression on messages is enabled then the CompressionBufferSize specifies the initial
                        size of the compression/decompression buffer. The compression buffer is used to store the messages
                        before they are compressed and send on the network. The decompression buffer is used to decompress
                        the received compressed messages. Note that the actual size of these buffers may be increased when
                        needed.</p>
                    ]]></comment>
          <minimum>65536</minimum>
          <default>131072</default>
          <resolution>bytes</resolution>
        </leafInt>
        <leafInt name="CompressionThreshold" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        <p>When compression on messages is enabled then the CompressionThreshold provides a threshold
                        to start compressing the accumulated data and sending the compressed data on the network.
                        The CompressionThreshold is used to estimate the size of the compressed messages.</p>
                    ]]></comment>
          <minimum>0</minimum>
          <default>0</default>
          <resolution>bytes</resolution>
        </leafInt>
        <element name="Sending" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element describes all properties for the transmitting side
                        of the Channel.
                    ]]></comment>
          <leafBoolean name="CrcCheck" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                       In order to protect Vortex OpenSplice network packets from malicious attack the CrcCheck(cyclic redundancy check) configuration item has been added.
                       CRCs are specifically designed to protect against common types of errors on communication channels.
                       When enabled the integrity of delivered network packets from one DDS process to another is assured.
                       There is a small performance cost using this feature due to the addtional overhead of carrying out the crc calculation.

                       When the sending side is enabled the network packet will contain a valid crc field.
                    ]]></comment>
            <default>false</default>
          </leafBoolean>
          <leafInt name="QueueSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            This element specifies the number of messages the networking queue
                            can contain.
                            Messages sent to the network are written into the networking queue.
                            The networking service will read from this queue. If this
                            queue is full, the writer writing into the queue is suspended
                            and will retry until success. Note that a full networking queue is
                            a symptom of an improperly designed system.
                        ]]></comment>
            <minimum>1</minimum>
            <default>400</default>
          </leafInt>
          <leafSize name="MaxBurstSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            Amount in bytes to be sent at maximum every
                            "Resolution" milliseconds. The default value is set to 1GB per resolution tick. This can be
                            considered "unlimited" as this far exceeds the capacity of modern physical networks.
                        ]]></comment>
            <minimum>1024</minimum>
            <maximum>1073741823</maximum>
            <default>1073741823</default>
          </leafSize>
          <leafSize name="ThrottleLimit" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            Throttling will enable you to further limit (below MaxBurstSize) the amount of data that is
                            sent every Resolution interval. This happens if one of the receiving nodes in the network
                            indicates that it has trouble processing all incoming data. This value is the lower boundary
                            of the range over which the throttling can adapt the limit. If this value is set to the same
                            value (or higher) as MaxBurstSize throttling is disabled.
                            The ThrottleLimit value is not allowed be smaller than the FragmentSize. If a lower value is
                            provided, then the value of FragmentSize is used as ThrottleLimit.
                        ]]></comment>
            <default>10240</default>
          </leafSize>
          <leafInt name="ThrottleThreshold" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            <p>This is the number of unprocessed network fragments that a node will store before it will inform
                            the other nodes in the network that it has trouble processing the incoming data. Those other nodes
                            can use this information to adjust their throttle values, effectively reducing the amount of incoming
                            data in case of a temporary overflow, and increasing again when the node is able to catch up.</p>
                            <p>It is considered good practice to specify the ThrottleTreshold consistently throughout
                            the system.</p>
                        ]]></comment>
            <minimum>2</minimum>
            <default>50</default>
          </leafInt>
          <leafInt name="MaxRetries" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            The number of retransmissions the service has to execute before considering the addressed node
                            as not responding.
                        ]]></comment>
            <minimum>1</minimum>
            <default>100</default>
          </leafInt>
          <leafInt name="RecoveryFactor" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[A lost message is resent after Resolution * RecoveryFactor milliseconds.]]></comment>
            <minimum>2</minimum>
            <default>3</default>
          </leafInt>
          <leafInt name="DiffServField" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                        This element describes the DiffServ setting the channel will apply to the networking messages.
                        This parameter determines the value of the  diffserv field of the IP version 4 packets send
                        on this channel which allows QoS setting to be applied to the network traffic send on this channel.
                        <br/><br/>
                        Windows platform support for setting the diffserv field is dependent on the OS version.
                        For Windows versions XP SP2 and 2003 to use the diffserv field the following parameter should
                        be added to the register:
                        <br/><br/>
                        HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\TcpIp\Parameters\DisableUserTOSSetting
                        <br/><br/>
                        The type of this parameter is a DWORD and it's value should be set to 0 to allow setting of the diffserv field.
                        <br/><br/>
                        For Windows version 7 or higher a new API (qWAVE) has been introduced For these platforms the specified
                        diffserv value is mapped to one of the support traffic types. The mapping is as follows:
                        1-8 background traffic; 9-40 excellent traffic; 41-55 audio/video traffic; 56 voice traffic; 57-63 control traffic.
                        When Vortex OpenSplice is run without Administrative priveleges then only the diffserv value of 0, 8, 40 or 56 is allowed.
                        ]]></comment>
            <minimum>0</minimum>
            <maximum>255</maximum>
            <default>0</default>
          </leafInt>
          <leafBoolean name="DontRoute" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[The IP DONTROUTE
                              socket option is set to the value specified.]]></comment>
            <value>True</value>
            <value>False</value>
            <default>True</default>
          </leafBoolean>
          <leafBoolean name="DontFragment" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                        Controls whether the "don't fragment" bit (DF) is set on outgoing UDP IPv4 packets.
                        Note that not all operating systems support setting this bit. When the operating
                        system does not support setting the DF bit this option is ignored.
                        ]]></comment>
            <value>True</value>
            <value>False</value>
            <default>False</default>
          </leafBoolean>
          <leafInt name="TimeToLive" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[For each UDP packet sent out, the IP Time To Live
                              header value is set to the value specified.]]></comment>
            <minimum>1</minimum>
            <maximum>255</maximum>
            <default>1</default>
          </leafInt>
          <element name="Scheduling" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            This element specifies the scheduling policies used to control the transmitter
                            thread of the current Channel.
                        ]]></comment>
            <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
              <comment><![CDATA[
                                This element specifies the thread priority that will be used by the transmitter
                                thread. Only priorities that are supported by the underlying operating system
                                can be assigned to this element. The user may need special privileges from the
                                underlying operating system to be able to assign some of the privileged priorities.
                            ]]></comment>
              <default>0</default>
              <attributeEnum name="priority_kind" required="false" version="COMMERCIAL">
                <comment><![CDATA[
                                    This attribute specifies whether the specified
                                    <i>Priority</i> is a relative or absolute priority.
                                ]]></comment>
                <value>Relative</value>
                <value>Absolute</value>
                <default>Relative</default>
              </attributeEnum>
            </leafInt>
            <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
              <comment><![CDATA[
                                This element specifies the thread scheduling class that will be used by the transmitter
                                thread. The user may need the appropriate privileges from the underlying operating system
                                to be able to assign some of the privileged scheduling classes.
                            ]]></comment>
              <value>Timeshare</value>
              <value>Realtime</value>
              <value>Default</value>
              <default>Default</default>
            </leafEnum>
          </element>
          <leafInt name="ReportInterval" hidden="true" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
              <comment><![CDATA[
                                This element applies to the tracing of messages send. When tracing is enabled
                                this element specifies the interval between the tracing messages reporting
                                the number of message send. The resolution of thisinterval is in millisecond.
                        ]]></comment>
              <minimum>10</minimum>
              <default>100</default>
          </leafInt>
        </element>
        <element name="Receiving" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element describes all properties for the receiving side
                        of the Channel.
                    ]]></comment>
          <leafBoolean name="CrcCheck" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                       In order to protect Vortex OpenSplice network packets from malicious attack the CrcCheck(cyclic redundancy check) configuration item has been added.
                       CRCs are specifically designed to protect against common types of errors on communication channels.
                       When enabled the integrity of delivered network packets from one DDS process to another is assured.
                       There is a small performance cost using this feature due to the addtional overhead of carrying out the crc calculation.

                       When the receiving side is enabled only network packets that contain a valid crc field are accepted.
                    ]]></comment>
            <default>false</default>
          </leafBoolean>
          <leafSize name="ReceiveBufferSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            The UDP receive buffer of the best effort channel socket is
                            set to the value given. If many message are lost, the
                            receive buffer size has to be increased.
                        ]]></comment>
            <minimum>1024</minimum>
            <default>1000000</default>
          </leafSize>
          <element name="Scheduling" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            This element specifies the scheduling policies used to control the
                            receiver thread of the current Channel.
                        ]]></comment>
            <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
              <comment><![CDATA[
                                This element specifies the thread priority that will be used by the receiver
                                thread. Only priorities that are supported by the underlying operating system
                                can be assigned to this element. The user may need special privileges from
                                the underlying operating system to be able to assign some of the privileged
                                priorities.
                            ]]></comment>
              <default>0</default>
              <attributeEnum name="priority_kind" required="false" version="COMMERCIAL">
                <comment><![CDATA[
                                    This attribute specifies whether the specified
                                    <i>Priority</i> is a relative or absolute priority.
                                ]]></comment>
                <value>Relative</value>
                <value>Absolute</value>
                <default>Relative</default>
              </attributeEnum>
            </leafInt>
            <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
              <comment><![CDATA[
                                This element specifies the thread scheduling class that will be used by the receiver
                                thread. The user may need the appropriate privileges from the underlying operating
                                system to be able to assign some of the privileged scheduling classes.
                            ]]></comment>
              <value>Timeshare</value>
              <value>Realtime</value>
              <value>Default</value>
              <default>Default</default>
            </leafEnum>
            <leafInt name="ReportInterval" hidden="true" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
              <comment><![CDATA[
                                This element applies to the tracing of messages send. When tracing is enabled
                                this element specifies the interval between the tracing messages reporting
                                the number of message send. The resolution of thisinterval is in millisecond.
                        ]]></comment>
              <minimum>10</minimum>
              <default>100</default>
            </leafInt>
          </element>
          <leafSize name="DefragBufferSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            The maximum number of Fragment buffers that will be allocated for
                            this channel. These buffers are used to store incoming fragments
                            waiting to be processed, as well as fragments that are being processed.
                        ]]></comment>
            <minimum>500</minimum>
            <default>5000</default>
          </leafSize>
          <element name="SMPOptimization" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            This option will distribute the processing done for incoming fragements over
                            multiple threads, which will lead to an improved throughput on SMP nodes.
                        ]]></comment>
            <attributeBoolean name="enabled" required="true" version="COMMERCIAL">
              <comment><![CDATA[
                                This attribute toggles the Optimization on or off.
                            ]]></comment>
              <default>true</default>
            </attributeBoolean>
          </element>
          <leafInt name="MaxReliabBacklog" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            This is a lower limit to the DefragBufferSize that specifies the number of received fragments
                            from a single remote node allocated for the purpose of order preservation because an earlier
                            fragment from that remote node is missing. If this number is exceeded, then that particular
                            remote node that didn't resend the missing fragent in time is considered dead for this channel.
                        ]]></comment>
            <minimum>100</minimum>
            <default>1000</default>
          </leafInt>
          <leafInt name="PacketRetentionPeriod" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
              This element specifies the number of milliseconds received packets are retained by the network
              service for its so-called "reliability-under-publisher-crash" extended reliability
              protocol. This protocol ensures that a consistent or aligned data-set is received by all
              alive (receiving) nodes, even though some nodes might not have received some
              packets at the moment a sending node disappears (for whatever reason). The
              protocol implies that each node retains sufficient received data so that it can be
              (re-)distributed if a publishing node disappears before all receiving nodes are
              "up-to-date". When the PacketRetentionPeriod element is set to 0 (the default
              value), the alignment amongst receiving nodes will not occur. To activate the
              extended realibility protocol, this setting must be configured to a time period that
              exceeds the worst-case death-detection time as configured for the discovery
              protocol of the set of distributed networking services in the system.
                        ]]></comment>
            <minimum>0</minimum>
            <default>0</default>
          </leafInt>
          <leafInt name="ReliabilityRecoveryPeriod" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
              This element specifies a timeout period (in milliseconds) for the alignment phase of the extended
              reliability protocol. It only has an effect when the related
              PacketRetentionperiod is set to a non-zero value. After the specified
              reliabilityRecoveryPeriod timeout, any data retained for the purpose of
              alignment of receiving nodes (following the disappearance or crash of a publishing
              node) will be discarded. The value of this timeout period must be sufficient to allow
              for the worst-case alignment-time of any "missed" data by individual receiving
              nodes following the disappearance of a sending node in the system.
                        ]]></comment>
            <minimum>0</minimum>
            <default>1000</default>
          </leafInt>
        </element>
        <leafString name="AllowedPorts" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                AllowedPorts specifies the port numbers available for the network service to be used by the
                reliable network channels. The network channel is configured with a unique port number. However
                the reliable network channels require a second port number to provide the reliable communication
                service. For this second port number each reliable network channel will select a free port from
                the AllowedPorts.
                When the AllowedPorts is not specified for a particular channel then the default AllowedPorts which
                is configured on the Channels element is used. When also the default AllowedPorts is not specified
                each reliable network channel will first try to use the configured portNr + 1 as the second port or
                when this port number is already in use will determine a port number dynamically.
                The AllowedPorts is a list of entries where an entry is a port number or a port number range.
                When the AllowedPorts contains more than one entry then these entries must be seperated by a
                comma (,). A port number range consists of the lower and the upper bound of the port number range,
                where the lower and the upper bound are seperated by a minus (-).
              ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </leafString>
      </element>
      <leafString name="AllowedPorts" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                AllowedPorts specifies the port numbers available for the network service to be used by the
                reliable network channels. The network channel is configured with a unique port number. However
                the reliable network channels require a second port number to provide the reliable communication
                service. For this second port number each reliable network channel will select a free port from
                the AllowedPorts.
                When the AllowedPorts is not specified for a particular channel then the default AllowedPorts which
                is configured on the Channels element is used. When also the default AllowedPorts is not specified
                each reliable network channel will first try to use the configured portNr + 1 as the second port or
                when this port number is already in use will determine a port number dynamically.
                The AllowedPorts is a list of entries where an entry is a port number or a port number range.
                When the AllowedPorts contains more than one entry then these entries must be seperated by a
                comma (,). A port number range consists of the lower and the upper bound of the port number range,
                where the lower and the upper bound are seperated by a minus (-).
        ]]></comment>
        <maxLength>0</maxLength>
        <default/>
      </leafString>
    </element>
    <element name="Discovery" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
This element controls various parameters of the Network Services Discovery
mechanism.
Discovery reduces the Network Service configuration and minimizes network
traffic. Without Discovery, data is always sent to the network and all Networking
Services need to configure the addresses (This can be multicast addresses and/or
uni-cast addresses, especially in an uni-cast environment with many nodes the
configuration of the Network Service's lists can be cumbersome.)
of all Network Services they need to
communicate with. With Discovery, data is only sent to where interest exists and
connectivity is discovered based on a minimum configuration (Only a subset of
addresses of nodes are initially specified, these nodes are assumed to be
available as a discovery source, all nodes will make themselves known to these discovery
nodes and thereby making its existence and address available for all other nodes) (see Element ProbeList).
Discovery is based on a heartbeat mechanism to advertize the service's availability.
The Network Service starts by announcing its existence by sending heartbeats to the
Global Partition (The Global Partition contains all the addresses that the Network Service communicate
with) which is initially filled with the addresses specified in the
ProbeList; remote Network Services receiving the heartbeat will start sending
heartbeats in return. All Network Services that discover new heartbeats will
automatically request address information that match their Scope (see Attribute Scope)
from the Network Service sending the
heartbeat, and add the retrieved address information to their Global Partition.
Currently only uni-cast addresses are exchanged. Addresses are removed from the
Global Partition when a remote Network Service stops and heartbeats are no longer
received.
            ]]></comment>
      <attributeBoolean name="enabled" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element can be used to enable or disable the Discovery Channel. In case the Discovery
                    Channel is disabled, entities will only detect each others presence implicitly once messages
                    are received for the first time.
                ]]></comment>
        <default>true</default>
      </attributeBoolean>
      <attributeString name="Scope" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This attribute controls the dynamic discovery behaviour of this node within the current Domain.
                    If it is not set, dynamic discovery will be disabled and the networking service will only
                    communicate with nodes that can be reached through the predefined Global Partition. If the Scope
                    attribute is specified, dynamic discovery is enabled and the networking service will be able to
                    communicate with all nodes in the system that have a Role that matches the Scope expression.
                    The Scope expression can contain a comma separated list of wild-card role-expressions. If the
                    role of any  discovered node matches any of the wild-card expressions, the remote node is
                    considered a match and will become part of the communication reach (i.e. the Global Partition)
                    of the current domain.
                ]]></comment>
        <maxLength>512</maxLength>
        <default/>
      </attributeString>
      <leafInt name="PortNr" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element specifies the Port number used by the Discovery Channel.
                ]]></comment>
        <minimum>1</minimum>
        <maximum>65536</maximum>
        <default>3369</default>
      </leafInt>
      <leafString name="ProbeList" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element contains the addresses of the nodes that will be contacted to retrieve an initial
                    list of participating nodes in the current domain that match the specified Scope. Multiple
                    ProbeList addresses can be entered by separating them by a colon (,), semicolon (;) or space( ) .
                    The addresses can be entered as dotted decimal notation or as the symbolic hostname, in which
                    case the middleware will try to resolve the corresponding IP address.
                ]]></comment>
        <maxLength>512</maxLength>
        <default/>
      </leafString>
      <element name="Sending" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element describes all properties for the transmitting side
                    of the Discovery Channel.
                ]]></comment>
        <leafBoolean name="CrcCheck" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                       In order to protect Vortex OpenSplice network packets from malicious attack the CrcCheck(cyclic redundancy check) configuration item has been added.
                       CRCs are specifically designed to protect against common types of errors on communication channels.
                       When enabled the integrity of delivered network packets from one DDS process to another is assured.
                       There is a small performance cost using this feature due to the addtional overhead of carrying out the crc calculation.

                       When the sending side is enabled the network packet will contain a valid crc field.
                    ]]></comment>
          <default>false</default>
        </leafBoolean>
        <leafInt name="DiffServField" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element describes the DiffServ setting the channel will apply to the networking messages.
                        This parameter determines the value of the  diffserv field of the IP version 4 packets send
                        on this channel which allows QoS setting to be applied to the network traffic send on this channel.
                        <br/><br/>
                        Windows platform support for setting the diffserv field is dependent on the OS version.
                        For Windows versions XP SP2 and 2003 to use the diffserv field the following parameter should
                        be added to the register:
                        <br/><br/>
                        HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\TcpIp\Parameters\DisableUserTOSSetting
                        <br/><br/>
                        The type of this parameter is a DWORD and it's value should be set to 0 to allow setting of the diffserv field.
                        <br/><br/>
                        For Windows version 7 or higher a new API (qWAVE) has been introduced For these platforms the specified
                        diffserv value is mapped to one of the support traffic types. The mapping is as follows:
                        1-8 background traffic; 9-40 excellent traffic; 41-55 audio/video traffic; 56 voice traffic; 57-63 control traffic.
                        When Vortex OpenSplice is run without Administrative priveleges then only the diffserv value of 0, 8, 40 or 56 is allowed.
                        ]]></comment>
          <minimum>0</minimum>
          <maximum>255</maximum>
          <default>0</default>
        </leafInt>
        <leafBoolean name="DontRoute" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[The IP DONTROUTE
                              socket option is set to the value specified.]]></comment>
          <value>True</value>
          <value>False</value>
          <default>True</default>
        </leafBoolean>
        <leafBoolean name="DontFragment" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                      Controls whether the "don't fragment" bit (DF) is set on outgoing UDP IPv4 packets.
                      Note that not all operating systems support setting this bit. When the operating
                      system does not support setting the DF bit this option is ignored.
                    ]]></comment>
          <value>True</value>
          <value>False</value>
          <default>False</default>
        </leafBoolean>
        <leafInt name="TimeToLive" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[For each UDP packet sent out, the IP Time To Live
                              header value is set to the value specified.]]></comment>
          <minimum>1</minimum>
          <maximum>255</maximum>
          <default>1</default>
        </leafInt>
        <element name="Scheduling" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the scheduling policies used to control the transmitter thread
                        of the Discovery Channel.
                    ]]></comment>
          <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            This element specifies the thread priority that will be used by the transmitter thread
                            of the Discovery Channel. Only priorities that are supported by the underlying operating
                            system can be assigned to this element. The user may need special privileges from the
                            underlying operating system to be able to assign some of the privileged priorities.
                        ]]></comment>
            <default>0</default>
            <attributeEnum name="priority_kind" required="false" version="COMMERCIAL">
              <comment><![CDATA[
                                This attribute specifies whether the specified
                                <i>Priority</i> is a relative or absolute priority.
                            ]]></comment>
              <value>Relative</value>
              <value>Absolute</value>
              <default>Relative</default>
            </attributeEnum>
          </leafInt>
          <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            This element specifies the thread scheduling class that will be used by the transmitter
                            thread of the Discovery Channel. The user may need the appropriate privileges from the
                            underlying operating system to be able to assign some of the privileged scheduling classes.
                        ]]></comment>
            <value>Timeshare</value>
            <value>Realtime</value>
            <value>Default</value>
            <default>Default</default>
          </leafEnum>
        </element>
        <leafInt name="Interval" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element describes the interval(in milliseconds) at which remote nodes will expect heartbeats from this node.
                    ]]></comment>
          <minimum>10</minimum>
          <default>333</default>
          <dimension>milliseconds</dimension>
        </leafInt>
        <leafFloat name="SafetyFactor" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
The SafetyFactor is used to set a margin (< 1) on the expected heartbeat interval.
The actual interval at which the heartbeats are sent is the specified interval
multiplied by this factor, so the actual interval will be equal to or smaller than the
specified value. This can be used to avoid timing issues such as those caused by
typical scheduling or network latencies.
                    ]]></comment>
          <minimum>0.2</minimum>
          <maximum>1.0</maximum>
          <default>0.9</default>
        </leafFloat>
        <leafInt name="SalvoSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                   The reactivity of discovery depends on the heartbeat frequency, a higher heartbeat
                   frequency gives a faster reactivity but also imposes a higher network load, which is
                   not desirable. Ideally the heartbeat frequency must be kept as low as possible but
                   from a startup (and shutdown) perspective a high reactivity is often desired. So the
                   Network Service has the capability to send an additional salvo of heartbeats at
                   startup and shutdown at ten times the normal heartbeat speed to maximize reactivity
                   during these phases without requiring a continuous high heartbeat frequency. The
                   SalvoSize sets the number of messages to send during these phases.
                      ]]></comment>
          <minimum>1</minimum>
          <default>3</default>
        </leafInt>
      </element>
      <element name="Receiving" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element describes all properties for the receiving side
                    of the Discovery Channel.
                ]]></comment>
        <leafBoolean name="CrcCheck" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                       In order to protect Vortex OpenSplice network packets from malicious attack the CrcCheck(cyclic redundancy check) configuration item has been added.
                       CRCs are specifically designed to protect against common types of errors on communication channels.
                       When enabled the integrity of delivered network packets from one DDS process to another is assured.
                       There is a small performance cost using this feature due to the addtional overhead of carrying out the crc calculation.

                       When the sending side is enabled the network packet will contain a valid crc field.
                    ]]></comment>
          <default>false</default>
        </leafBoolean>
        <element name="Scheduling" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the scheduling policies used to control the receiver thread
                        of the Discovery Channel.
                    ]]></comment>
          <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            This element specifies the thread priority that will be used by the receiver thread
                            of the Discovery Channel. Only priorities that are supported by the underlying operating
                            system can be assigned to this element. The user may need special privileges from the
                            underlying operating system to be able to assign some of the privileged priorities.
                        ]]></comment>
            <default>0</default>
            <attributeEnum name="priority_kind" required="false" version="COMMERCIAL">
              <comment><![CDATA[
                                This attribute specifies whether the specified
                                <i>Priority</i> is a relative or absolute priority.
                            ]]></comment>
              <value>Relative</value>
              <value>Absolute</value>
              <default>Relative</default>
            </attributeEnum>
          </leafInt>
          <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            This element specifies the thread scheduling class that will be used by the receiver
                            thread of the Discovery Channel. The user may need the appropriate privileges from the
                            underlying operating system to be able to assign some of the privileged scheduling classes.
                        ]]></comment>
            <value>Timeshare</value>
            <value>Realtime</value>
            <value>Default</value>
            <default>Default</default>
          </leafEnum>
        </element>
        <leafInt name="DeathDetectionCount" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies how often a heartbeat from a remote node must miss its Interval before
                        that remote node is considered dead.
                    ]]></comment>
          <minimum>1</minimum>
          <default>6</default>
        </leafInt>
        <leafSize name="ReceiveBufferSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        The UDP receive buffer of the Discovery Channel socket is set to the value given. If
                        many message are lost, the receive buffer size has to be increased.
                    ]]></comment>
          <minimum>1</minimum>
          <default>1000000</default>
          <dimension>bytes</dimension>
        </leafSize>
      </element>
    </element>
    <element name="Tracing" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
                This element controls the amount and type of information that is written into the
                tracing log by the Networking Service. This is useful to track the Networking Service
                during application development. In the runtime system it should be turned off.
            ]]></comment>
      <attributeBoolean name="enabled" required="false" version="COMMERCIAL">
        <comment><![CDATA[
                    This attribute controls whether the tracing option is enabled or not.
                ]]></comment>
        <default>true</default>
      </attributeBoolean>
      <leafString name="OutputFile" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This option specifies where the logging is printed to. Note that "stdout" is considered a
                    legal value that represents "standard out".  The default value is an empty string,
                    indicating that the tracing log will be written to standard out.
                ]]></comment>
        <maxLength>0</maxLength>
        <default>networking.log</default>
      </leafString>
      <leafBoolean name="Timestamps" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element specifies whether the logging must contain timestamps.
                ]]></comment>
        <attributeBoolean name="absolute" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                        This attribute specifies whether the timestamps are absolute
                        or relative to the startup time of the service.
                    ]]></comment>
          <default>true</default>
        </attributeBoolean>
        <default>true</default>
      </leafBoolean>
      <element name="Categories" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element contains the logging properties for various networking categories.
                ]]></comment>
        <leafInt name="Default" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the tracing level used for categories that are not
                        explicitly specified. Level 0 indicates no tracing, level 6 indicates the
                        most detailed level of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Configuration" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Configuration</i> category.
                        This includes the processing of all NetworkService parameters in the config file.
                        Level 0 indicates no tracing, level 6 indicates the most detailed level
                        of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Construction" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Construction</i> category.
                        This includes the creation of all internal processing entities.
                        Level 0 indicates no tracing, level 6 indicates the most detailed level
                        of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Destruction" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Destruction</i> category.
                        This includes the destruction of all internal processing entities when the
                        NetworkService terminates. Level 0 indicates no tracing, level 6 indicates the
                        most detailed level of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Mainloop" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Mainloop</i> category.
                        This includes information about each of the threads spawned by the NetworkService.
                        Level 0 indicates no tracing, level 6 indicates the most detailed level
                        of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Groups" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Groups</i> category.
                        This includes the management of local groups (partition-topic combinations).
                        Level 0 indicates no tracing, level 6 indicates the most detailed level
                        of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Send" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Send</i> category.
                        This includes information about outgoing data.
                        Level 0 indicates no tracing, level 6 indicates the most detailed level
                        of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Receive" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Receive</i> category.
                        This includes information about incoming data.
                        Level 0 indicates no tracing, level 6 indicates the most detailed level
                        of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Throttling" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Throttling</i> category.
                        This includes information about throttling.
                        Level 0 indicates no tracing, level 6 indicates the most detailed level
                        of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Test" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Test</i> category.
                        This is a reserved category used for testing purposes.
                        Level 0 indicates no tracing, level 6 indicates the most detailed level
                        of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
        <leafInt name="Discovery" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                        This element specifies the tracing level for the <i>Discovery</i> category.
                        This includes all activity related to the discovery channel.
                        Level 0 indicates no tracing, level 6 indicates the most detailed level
                        of tracing.
                    ]]></comment>
          <minimum>0</minimum>
          <maximum>6</maximum>
          <default>0</default>
        </leafInt>
      </element>
      <leafEnum name="Verbosity" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>The Verbosity attribute sets the level of tracing for all Tracing Catagories. This attribute is an additional method besides the Tracing/Catagories tag to specify trace levels. The difference is that Verbosity sets the level for all catagories similar as by other services whereas the Tracing/Catagories element allows to set the trace level per catagory. The verbosity levels are mapped to Catagory levels as following:</p>
<ul><li><i>none</i>: level 0 (no Networking log)</li>
<li><i>severe</i>:   level 1 </li>
<li><i>warning</i>:  level 2 </li>
<li><i>info</i>:     level 3 </li>
<li><i>config</i>:   level 3 </li>
<li><i>fine</i>:     level 4 </li>
<li><i>finer</i>:    level 5 </li>
<li><i>finest</i>:   level 6 </ul>
          ]]></comment>
        <value>finest</value>
        <value>finer</value>
        <value>fine</value>
        <value>config</value>
        <value>info</value>
        <value>warning</value>
        <value>severe</value>
        <value>none</value>
        <default>none</default>
      </leafEnum>
    </element>
    <element name="Compression" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
                      <p>This group of attributes specifies a compression method to
                      use within the service in partitions where it is enabled. The
                      networking service includes (depending on platform) implementations
                      of zlib, lzf and snappy. Others may be implemented by writing a
                      dynamically-loadable library and configuring it here. See the
                      Vortex OpenSplice release notes for details of how to write such a
                      library.</p>
                      <p>It is imperative that all nodes exchanging compressed data
                      have the same configuration in this section.</p>
                  ]]></comment>
      <attributeString name="PluginLibrary" required="false" version="COMMERCIAL">
        <comment><![CDATA[
                        <p>This attribute names a dynamically loadable library
                        which must contain the code for compressing and decompressing
                        the network data. This may be left blank for the built-in
                        compressors.</p>
                    ]]></comment>
        <maxLength>0</maxLength>
        <default/>
      </attributeString>
      <attributeString name="PluginInitFunction" required="false" version="COMMERCIAL">
        <comment><![CDATA[
                        <p>This attribute specifies an initialization function for a
                        compression plugin to be used within the service. The functions
                        for the built-in compressors are named ospl_comp_zlib_init,
                        ospl_comp_lzf_init and ospl_comp_snappy_init but for convenience
                        they may be specified here as as zlib, lzf or snappy.</p>
                    ]]></comment>
        <maxLength>0</maxLength>
        <default/>
      </attributeString>
      <attributeString name="PluginParameter" required="false" version="COMMERCIAL">
        <comment><![CDATA[
                        <p>Some compression implementations are configurable with
                        respect to the tradeoff between speed and effectiveness. A
                        parameter may be specified here to control this. For example
                        the zlib compressor is configured with an integer between 0
                        (for no compression) to 9 (for maximum compression).</p>
                    ]]></comment>
        <maxLength>0</maxLength>
        <default/>
      </attributeString>
    </element>
    <element name="Debugging" hidden="true" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
       <comment><![CDATA[
                Debug options for networking
            ]]></comment>
       <leafInt name="WaitForDebugger" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
         <comment><![CDATA[
                         WaitForDebugger
                    ]]></comment>
          <default>0</default>
        </leafInt>
        <leafBoolean name="UseLoopback" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                          UseLoopback
                   ]]></comment>
          <default>false</default>
        </leafBoolean>
        <leafBoolean name="UseComplementPartitions" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                          UseComplementPartitions
                    ]]></comment>
          <default>false</default>
        </leafBoolean>
        <leafBoolean name="NoPacking" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                          NoPacking
                    ]]></comment>
          <default>false</default>
        </leafBoolean>
        <element name="Lossy" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                          Lossy
                    ]]></comment>
          <element name="Receiving" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            Lossy
                      ]]></comment>
            <leafBoolean name="BeLossy" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
              <comment><![CDATA[
                              BeLossy
                        ]]></comment>
              <default>false</default>
            </leafBoolean>
            <leafInt name="Threshold" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
              <comment><![CDATA[
                              Threshold
                        ]]></comment>
              <minimum>1</minimum>
              <default>5</default>
            </leafInt>
          </element>
          <element name="Sending" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
                            Lossy
                      ]]></comment>
            <leafBoolean name="BeLossy" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
              <comment><![CDATA[
                              BeLossy
                        ]]></comment>
              <default>false</default>
            </leafBoolean>
            <leafInt name="Threshold" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
              <comment><![CDATA[
                              Threshold
                        ]]></comment>
              <minimum>1</minimum>
              <default>5</default>
            </leafInt>
          </element>
      </element>
    </element>
    <element name="Reporting" hidden="true" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <leafEnum name="Level" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                        Level
                  ]]></comment>
        <value>None</value>
        <value>Basic</value>
        <value>Low_frequent</value>
        <value>Medium_frequentne</value>
        <value>High_frequent</value>
        <value>Full</value>
        <default>None</default>
      </leafEnum>
      <leafBoolean name="Events" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                        Events
                  ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafBoolean name="Periodic" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                        Periodic
                  ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafBoolean name="OneShot" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                        OneShot
                  ]]></comment>
        <default>false</default>
      </leafBoolean>
    </element>
    <element name="Profiling" hidden="true" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <leafString name="Outfile" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <maxLength>0</maxLength>
        <default>stdout</default>
      </leafString>
      <element name="ProfDefault" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <leafBoolean name="DoProfiling" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                          DoProfiling
                    ]]></comment>
          <default>false</default>
        </leafBoolean>
        <leafInt name="ReportLaps" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                          ReportLaps
                    ]]></comment>
          <minimum>0</minimum>
          <default>100</default>
        </leafInt>
      </element>
      <element name="Bridge" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <leafBoolean name="DoProfiling" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                         DoProfiling
                    ]]></comment>
          <default>false</default>
        </leafBoolean>
        <leafInt name="ReportLaps" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                          ReportLaps
                    ]]></comment>
          <minimum>0</minimum>
          <default>100</default>
        </leafInt>
      </element>
      <element name="Plug" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <leafBoolean name="DoProfiling" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                         DoProfiling
                    ]]></comment>
          <default>false</default>
        </leafBoolean>
        <leafInt name="ReportLaps" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                          ReportLaps
                    ]]></comment>
          <minimum>0</minimum>
          <default>100</default>
        </leafInt>
      </element>
      <element name="Fragmentation" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <leafBoolean name="DoProfiling" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                         DoProfiling
                    ]]></comment>
          <default>false</default>
        </leafBoolean>
        <leafInt name="ReportLaps" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                          ReportLaps
                    ]]></comment>
          <minimum>0</minimum>
          <default>100</default>
        </leafInt>
      </element>
      <element name="NetworkStack" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <leafBoolean name="DoProfiling" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                         DoProfiling
                    ]]></comment>
          <default>false</default>
        </leafBoolean>
        <leafInt name="ReportLaps" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                          ReportLaps
                    ]]></comment>
          <minimum>0</minimum>
          <default>100</default>
        </leafInt>
      </element>
      <element name="Serialization" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <leafBoolean name="DoProfiling" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                         DoProfiling
                    ]]></comment>
          <default>false</default>
        </leafBoolean>
        <leafInt name="ReportLaps" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
                          ReportLaps
                    ]]></comment>
          <minimum>0</minimum>
          <default>100</default>
        </leafInt>
      </element>
    </element>
  </element>
  <!-- NetworkingBridgeService CONFIGURATION AUTOMAGICALLY GENERATED (see src/services/ddsi2e/extract-configuration-xml.awk) -->
  <element name="NetworkingBridgeService" minOccurrences="0" maxOccurrences="0" version="COMMERCIAL">
    <comment><![CDATA[
<p>The root element of a networking bridge service configuration.</p>
      ]]></comment>
    <maxLength>0</maxLength>
    <attributeString name="name" required="true" version="COMMERCIAL">
      <comment><![CDATA[
<p>This attribute identifies the configuration for the Networking Bridge Service. Multiple service configurations can be specified in one single XML file. The actual applicable configuration is determined by the value of the name attribute, which must match the specified under the element OpenSplice/Domain/Service[@name] in the Domain Service configuration.</p>
        ]]></comment>
      <maxLength>0</maxLength>
      <default>networkingbridge</default>
    </attributeString>
    <element name="Exclude" minOccurrences="0" maxOccurrences="0" version="COMMERCIAL">
      <comment><![CDATA[
<p>This element specifies which partition/topic combinations may not be forwarded.</p>
        ]]></comment>
      <element name="Entry" minOccurrences="0" maxOccurrences="0" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element configures a single partition/topic combination for exclusion in the set of forwarded partition/topic combinations.</p>
          ]]></comment>
        <attributeString name="DCPSPartitionTopic" required="true" version="COMMERCIAL">
          <comment><![CDATA[
<p>This attribute specifies a partition and a topic expression, separated by a single '.', that are used to determine if a given partition and topic will be excluded w.r.t. forwarding. The expressions may use the usual wildcards '*' and '?'.</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
      </element>
    </element>
    <element name="Include" minOccurrences="0" maxOccurrences="0" version="COMMERCIAL">
      <comment><![CDATA[
<p>This element specifies which partition/topic combinations are to be forwarded, provided they are not listed in the Exclude section.</p>
        ]]></comment>
      <element name="Entry" minOccurrences="0" maxOccurrences="0" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element configures a single partition/topic combination for inclusion in the set of forwarded partition/topic combinations.</p>
          ]]></comment>
        <attributeString name="DCPSPartitionTopic" required="true" version="COMMERCIAL">
          <comment><![CDATA[
<p>This attribute specifies a partition and a topic expression, separated by a single '.', that are used to determine if a given partition and topic will be included w.r.t. forwarding. The expressions may use the usual wildcards '*' and '?'.</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
      </element>
    </element>
    <element name="Tracing" minOccurrences="0" maxOccurrences="0" version="COMMERCIAL">
      <comment><![CDATA[
<p>The Tracing element controls the amount and type of information that is written into the tracing log by the DDSI service. This is useful to track the DDSI service during application development.</p>
        ]]></comment>
      <leafBoolean name="AppendToFile" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This option specifies whether the output is to be appended to an existing log file. The default is to create a new log file each time, which is generally the best option if a detailed log is generated.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafString name="EnableCategory" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element enables individual logging categories. These are enabled in addition to those enabled by Tracing/Verbosity. Recognised categories are:
<ul><li><i>fatal</i>: all fatal errors, errors causing immediate termination</li>
<li><i>error</i>: failures probably impacting correctness but not necessarily causing immediate termination</li>
<li><i>warning</i>: abnormal situations that will likely not impact correctness</li>
<li><i>config</i>: full dump of the configuration</li>
<li><i>info</i>: general informational notices</li></ul>
In addition, there is the keyword <i>trace</i> that enables all but <i>radmin</i></p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default/>
      </leafString>
      <leafString name="OutputFile" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This option specifies where the logging is printed to. Note that <i>stdout</i> and <i>stderr</i> are treated as special values, representing "standard out" and "standard error" respectively. No file is created unless logging categories are enabled using the Tracing/Verbosity or Tracing/EnabledCategory settings.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>nwbridge.log</default>
      </leafString>
      <leafEnum name="Verbosity" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element enables standard groups of categories, based on a desired verbosity level. This is in addition to the categories enabled by the Tracing/EnableCategory setting. Recognised verbosity levels and the categories they map to are:
<ul><li><i>none</i>: no NetworkingBridge log</li>
<li><i>severe</i>: error and fatal</li>
<li><i>warning</i>: <i>severe</i> + warning</li>
<li><i>info</i>: <i>warning</i> + general information messages</li>
<li><i>config</i>: <i>info</i> + config</li>
<li><i>fine</i>: equivalent to <i>config</i></li>
<li><i>finest</i>: <i>fine</i> + trace</li></ul>
While <i>none</i> prevents any message from being written to a NetworkingBridge log file, warnings and errors are still logged in the ospl-info.log and ospl-error.log files.</p>
          ]]></comment>
        <value>finest</value>
        <value>fine</value>
        <value>config</value>
        <value>info</value>
        <value>warning</value>
        <value>severe</value>
        <value>none</value>
        <default>none</default>
      </leafEnum>
    </element>
    <element name="Watchdog" minOccurrences="0" maxOccurrences="0" version="COMMERCIAL">
      <comment><![CDATA[
<p>This element specifies the type of OS scheduling class will be used by the thread that announces its liveliness periodically.</p>
        ]]></comment>
      <element name="Scheduling" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element specifies the type of OS scheduling class will be used by the thread that announces its liveliness periodically.</p>
          ]]></comment>
        <leafEnum name="Class" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<p>This element specifies the thread scheduling class that will be used by the watchdog thread. The user may need the appropriate privileges from the underlying operating system to be able to assign some of the privileged scheduling classes.</p>
            ]]></comment>
          <value>realtime</value>
          <value>timeshare</value>
          <value>default</value>
          <default>default</default>
        </leafEnum>
        <leafInt name="Priority" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<p>This element specifies the thread priority. Only priorities that are supported by the underlying operating system can be assigned to this element. The user may need special privileges from the underlying operating system to be able to assign some of the privileged priorities.</p>
            ]]></comment>
          <default>0</default>
          <attributeEnum name="priority_kind" required="false" version="COMMERCIAL">
            <comment><![CDATA[
<p>This attribute specifies whether the specified Priority is a relative or absolute priority.</p>
              ]]></comment>
            <value>relative</value>
            <value>absolute</value>
            <default>relative</default>
          </attributeEnum>
        </leafInt>
      </element>
    </element>
  </element>
  <!-- END NetworkingBridgeService CONFIGURATION AUTOMAGICALLY GENERATED (see src/services/ddsi2e/extract-configuration-xml.awk) -->
<!-- DDSI2EService CONFIGURATION AUTOMAGICALLY GENERATED (see src/services/ddsi2e/extract-configuration-xml.awk) -->
  <element name="DDSI2EService" minOccurrences="0" maxOccurrences="0" version="COMMERCIAL">
    <comment><![CDATA[
<p>The root element of a DDSI2E networking service configuration.</p>
      ]]></comment>
    <maxLength>0</maxLength>
    <attributeString name="name" required="true" version="COMMERCIAL">
      <comment><![CDATA[
<p>This attribute identifies the configuration for the DDSI2E Service. Multiple DDSI2E service configurations can be specified in one single resource. The actual applicable configuration is determined by the value of the name attribute, which must match the specified under the element OpenSplice/Domain/Service[@name] in the Domain Service configuration.</p>
        ]]></comment>
      <maxLength>0</maxLength>
      <default>ddsi2e</default>
    </attributeString>
    <element name="Channels" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
<p>This element is used to group a set of channels. The channels are independent data paths through DDSI2E and by using separate threads and setting their priorities appropriately, chanenls can be used to map transport priorities to operating system scheduler priorities, ensuring system-wide end-to-end priority preservation.</p>
        ]]></comment>
      <element name="Channel" minOccurrences="0" maxOccurrences="42" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element defines a channel.</p>
          ]]></comment>
        <attributeString name="Name" required="true" version="COMMERCIAL">
          <comment><![CDATA[
<p>This attribute specifies name of this channel. The name should uniquely identify the channel.</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default></default>
        </attributeString>
        <attributeInt name="TransportPriority" required="false" version="COMMERCIAL">
          <comment><![CDATA[
<p>This attribute sets the transport priority threshold for the channel. Each DCPS data writer has a "transport_priority" QoS and this QoS is used to select a channel for use by this writer. The selected channel is the one with the largest threshold not greater than the writer's transport priority, and if no such channel exists, the channel with the lowest threshold.</p>
            ]]></comment>
          <default>0</default>
        </attributeInt>
        <leafString name="AuxiliaryBandwidthLimit" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<p>This element specifies the maximum transmit rate of auxiliary traffic on this channel (e.g. retransmits, heartbeats, etc). Bandwidth limiting uses a leaky bucket scheme. The default value "inf" means DDSI2E imposes no limitation, the underlying operating system and hardware will likely limit the maimum transmit rate.</p>
<p>The unit must be specified explicitly. Recognised units: <i>X</i>b/s, <i>X</i>bps for bits/s or <i>X</i>B/s, <i>X</i>Bps for bytes/s; where <i>X</i> is an optional prefix: k for 10<sup>3</sup>, Ki for 2<sup>10</sup>, M for 10<sup>6</sup>, Mi for 2<sup>20</sup>, G for 10<sup>9</sup>, Gi for 2<sup>30</sup>.</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default>inf</default>
        </leafString>
        <leafString name="DataBandwidthLimit" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<p>This element specifies the maximum transmit rate of new samples and directly related data, for this channel. Bandwidth limiting uses a leaky bucket scheme. The default value "inf" means DDSI2E imposes no limitation, the underlying operating system and hardware will likely limit the maimum transmit rate.</p>
<p>The unit must be specified explicitly. Recognised units: <i>X</i>b/s, <i>X</i>bps for bits/s or <i>X</i>B/s, <i>X</i>Bps for bytes/s; where <i>X</i> is an optional prefix: k for 10<sup>3</sup>, Ki for 2<sup>10</sup>, M for 10<sup>6</sup>, Mi for 2<sup>20</sup>, G for 10<sup>9</sup>, Gi for 2<sup>30</sup>.</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default>inf</default>
        </leafString>
        <leafInt name="DiffServField" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<p>This element describes the DiffServ setting the channel will apply to the networking messages. This parameter determines the value of the diffserv field of the IP version 4 packets sent on this channel which allows QoS setting to be applied to the network traffic send on this channel.<br/>
Windows platform support for setting the diffserv field is dependent on the OS version.<br/>
For Windows versions XP SP2 and 2003 to use the diffserv field the following parameter should be added to the register:<br/><br>
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\TcpIp\Parameters\DisableUserTOSSetting<br/><br/>
The type of this parameter is a DWORD and its value should be set to 0 to allow setting of the diffserv field.<br/><br/>
For Windows version 7 or higher a new API (qWAVE) has been introduced. For these platforms the specified diffserv value is mapped to one of the support traffic types.
The mapping is as follows: 1-8 background traffic; 9-40 excellent traffic; 41-55 audio/video traffic; 56 voice traffic; 57-63 control traffic.
When an application is run without Administrative priveleges then only the diffserv value of 0, 8, 40 or 56 is allowed.</p>
            ]]></comment>
          <default>0</default>
        </leafInt>
        <leafInt name="QueueSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<p>This element specifies the number of messages the network queue for this channel can contain. The Vortex OpenSplice kernel writes data to be transmitted to the network queue, and DDSI2E takes them from this queue. If this queue is full when an application tries to write a sample, the sample will be dropped or the writer suspended, depending on the QoS settings of the writer. Vortex OpenSplice and its services are optimised for a well-balanced system design, where the queue never becomes full.</p>
            ]]></comment>
          <default>0</default>
        </leafInt>
        <attributeString name="Resolution" required="false" version="COMMERCIAL">
          <comment><![CDATA[
<p>This element specifies the interval at which the DDSI2E transmit thread for this channel wakes up, and which controls the smallest latency_budget that has an effect. A shorter latency_budget is rounded to 0. The downside of a reducing this setting is that it increases the number of idle wake-ups of the transmit thread when there is no data to be sent.</p>
<p>The unit must be specified explicitly. Recognised units: ns, us, ms, s, min, hr, day.</p>
            ]]></comment>
          <minimum>0</minimum>
          <maximum>1s</maximum>
          <maxLength>0</maxLength>
          <default>1s</default>
        </attributeString>
      </element>
    </element>
    <element name="Compatibility" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
<p>The Compatibility elements allows specifying various settings related to compatability with standards and with other DDSI implementations.</p>
        ]]></comment>
      <leafInt name="AckNackNumbitsEmptySet" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element governs the representation of an acknowledgement message that does not also negatively-acknowledge some samples. If set to 0, the generated acknowledgements have an invalid form and will be reject by the strict and pedantic conformance modes, but several other implementation require this setting for smooth interoperation.</p>
<p>If set to 1, all acknowledgements sent by DDSI2E adhere the form of acknowledgement messages allowed by the standard, but this causes problems when interoperating with these other implementations. The strict and pedantic standards conformance modes always overrule an AckNackNumbitsEmptySet=0 to prevent the transmitting of invalid messages.</p>
          ]]></comment>
        <default>0</default>
      </leafInt>
      <leafBoolean name="ArrivalOfDataAssertsPpAndEpLiveliness" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>When set to true, arrival of a message from a peer asserts liveliness of that peer. When set to false, only SPDP and explicit lease renewals have this effect.</p>
          ]]></comment>
        <default>true</default>
      </leafBoolean>
      <leafBoolean name="AssumeRtiHasPmdEndpoints" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This option assumes ParticipantMessageData endpoints required by the liveliness protocol are present in RTI participants even when not properly advertised by the participant discovery protocol.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafBoolean name="ExplicitlyPublishQosSetToDefault" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element specifies whether QoS settings set to default values are explicitly published in the discovery protocol. Implementations are to use the default value for QoS settings not published, which allows a significant reduction of the amount of data that needs to be exchanged for the discovery protocol, but this requires all implementations to adhere to the default values specified by the specifications.</p>
<p>When interoperability is required with an implementation that does not follow the specifications in this regard, setting this option to true will help.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafBoolean name="ManySocketsMode" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This option specifies whether a network socket will be created for each domain participant on a host. The specification seems to assume that each participant has a unique address, and setting this option will ensure this to be the case. This is not the defeault.</p>
<p>Disabling it slightly improves performance and reduces network traffic somewhat. It also causes the set of port numbers needed by DDSI2E to become predictable, which may be useful for firewall and NAT configuration.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafBoolean name="RespondToRtiInitZeroAckWithInvalidHeartbeat" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element allows a closer mimicking of the behaviour of some other DDSI implementations, albeit at the cost of generating even more invalid messages. Setting it to true ensures a Heartbeat can be sent at any time when a remote node requests one, setting it to false delays it until a valid one can be sent.</p>
<p>The latter is fully compliant with the specification, and no adverse effects have been observed. It is the default.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafEnum name="StandardsConformance" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element sets the level of standards conformance of this instance of the DDSI2E Service. Stricter conformance typically means less interoperability with other implementations. Currently three modes are defined:</p>
<ul><li><i>pedantic</i>: very strictly conform to the specification, ultimately for compliancy testing, but currently of little value because it adheres even to what will most likely turn out to be editing errors in the DDSI standard. Arguably, as long as no errata have been published it is the current text that is in effect, and that is what pedantic currently does.</li>
<li><i>strict</i>: a slightly less strict view of the standard than does pedantic: it follows the established behaviour where the standard is obviously in error.</li>
<li><i>lax</i>: attempt to provide the smoothest possible interoperability, anticipating future revisions of elements in the standard in areas that other implementations do not adhere to, even though there is no good reason not to.</li></ul>
<p>The default setting is "lax".</p>
          ]]></comment>
        <value>lax</value>
        <value>strict</value>
        <value>pedantic</value>
        <default>lax</default>
      </leafEnum>
    </element>
    <element name="Discovery" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
<p>The Discovery element allows specifying various parameters related to the discovery of peers.</p>
        ]]></comment>
      <leafBoolean name="AdvertiseBuiltinTopicWriters" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element controls whether or not DDSI2E advertises writers for the built-in topics from its discovery for backwards compatibility with older Vortex OpenSplice versions.</p>
          ]]></comment>
        <default>true</default>
      </leafBoolean>
      <leafString name="DSGracePeriod" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This setting controls for how long endpoints discovered via a Cloud discovery service will survive after the discovery service disappeared, allowing reconnect without loss of data when the discovery service restarts (or another instance takes over).</p>
<p>Valid values are finite durations with an explicit unit or the keyword 'inf' for infinity. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>30 s</default>
      </leafString>
      <leafString name="DefaultMulticastAddress" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element specifies the default multicast address for all traffic other than participant discovery packets. It defaults to Discovery/SPDPMulticastAddress.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>auto</default>
      </leafString>
      <leafString name="DomainId" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element allows overriding of the DDS Domain Id that is used for DDSI2E.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>default</default>
      </leafString>
      <leafBoolean name="GenerateBuiltinTopics" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element controls whether or not DDSI2E generates built-in topics from its discovery. When disabled, it relies on the durability service.</p>
          ]]></comment>
        <default>true</default>
      </leafBoolean>
      <leafString name="LocalDiscoveryPartition" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element controls which partition is monitored by DDSI2E for built-in topics describing entities the it mirrors in DDSI.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>__BUILT-IN PARTITION__</default>
      </leafString>
      <leafInt name="MaxAutoParticipantIndex" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element specifies the maximum DDSI participant index selected by this instance of the DDSI2E service if the Discovery/ParticipantIndex is "auto".</p>
          ]]></comment>
        <default>9</default>
      </leafInt>
      <leafString name="ParticipantIndex" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element specifies the DDSI participant index used by this instance of the DDSI2E service for discovery purposes. Only one such participant id is used, independent of the number of actual DomainParticipants on the node. It is either:</p>
<ul><li><i>auto</i>: which will attempt to automatically determine an available participant index (see also Discovery/MaxAutoParticipantIndex), or</li>
<li>a non-negative integer less than 120, or</li>
<li><i>none</i>:, which causes it to use arbitrary port numbers for unicast sockets which entirely removes the constraints on the participant index but makes unicast discovery impossible.</li></ul>
<p>The default is <i>auto</i>. The participant index is part of the port number calculation and if predictable port numbers are needed and fixing the participant index has no adverse effects, it is recommended that the second be option be used.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>auto</default>
      </leafString>
      <element name="Peers" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element statically configures addresses for discovery.</p>
<p>Valid values are finite durations with an explicit unit or the keyword 'inf' for infinity. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <element name="Group" minOccurrences="0" maxOccurrences="0" version="COMMERCIAL">
          <comment><![CDATA[
<p>This element statically configures a fault tolerant group of addresses for discovery. Each member of the group is tried in sequence until one succeeds.</p>
            ]]></comment>
          <element name="Peer" minOccurrences="0" maxOccurrences="0" version="COMMERCIAL">
            <comment><![CDATA[
<p>This element statically configures an addresses for discovery.</p>
              ]]></comment>
            <attributeString name="Address" required="true" version="COMMERCIAL">
              <comment><![CDATA[
<p>This element specifies an IP address to which discovery packets must be sent, in addition to the default multicast address (see also General/AllowMulticast). Both a hostnames and a numerical IP address is accepted; the hostname or IP address may be suffixed with :PORT to explicitly set the port to which it must be sent. Multiple Peers may be specified.</p>
                ]]></comment>
              <maxLength>0</maxLength>
              <default></default>
            </attributeString>
          </element>
        </element>
        <element name="Peer" minOccurrences="0" maxOccurrences="0" version="COMMERCIAL">
          <comment><![CDATA[
<p>This element statically configures an addresses for discovery.</p>
            ]]></comment>
          <attributeString name="Address" required="true" version="COMMERCIAL">
            <comment><![CDATA[
<p>This element specifies an IP address to which discovery packets must be sent, in addition to the default multicast address (see also General/AllowMulticast). Both a hostnames and a numerical IP address is accepted; the hostname or IP address may be suffixed with :PORT to explicitly set the port to which it must be sent. Multiple Peers may be specified.</p>
              ]]></comment>
            <maxLength>0</maxLength>
            <default></default>
          </attributeString>
        </element>
      </element>
      <element name="Ports" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>The Ports element allows specifying various parameters related to the port numbers used for discovery. These all have default values specified by the DDSI 2.1 (and 2.2) specification and rarely need to be changed.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <leafInt name="Base" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<p>This element specifies the base port number (refer to the DDSI 2.1 or 2.2 specification, section 9.6.1, constant PB).</p>
            ]]></comment>
          <minimum>1</minimum>
          <maximum>65535</maximum>
          <default>7400</default>
        </leafInt>
        <leafInt name="DomainGain" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<p>This element specifies the domain gain, relating domain ids to sets of port numbers (refer to the DDSI 2.1 or 2.2 specification, section 9.6.1, constant DG).</p>
            ]]></comment>
          <default>250</default>
        </leafInt>
        <leafInt name="MulticastDataOffset" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<p>This element specifies the port number for multicast meta traffic (refer to the DDSI 2.1 or 2.2 specification, section 9.6.1, constant d2).</p>
            ]]></comment>
          <default>1</default>
        </leafInt>
        <leafInt name="MulticastMetaOffset" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<p>This element specifies the port number for multicast meta traffic (refer to the DDSI 2.1 or 2.2 specification, section 9.6.1, constant d0).</p>
            ]]></comment>
          <default>0</default>
        </leafInt>
        <leafInt name="ParticipantGain" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<p>This element specifies the participant gain, relating p0, articipant index to sets of port numbers (refer to the DDSI 2.1 or 2.2 specification, section 9.6.1, constant PG).</p>
            ]]></comment>
          <default>2</default>
        </leafInt>
        <leafInt name="UnicastDataOffset" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<p>This element specifies the port number for unicast meta traffic (refer to the DDSI 2.1 or 2.2 specification, section 9.6.1, constant d3).</p>
            ]]></comment>
          <default>11</default>
        </leafInt>
        <leafInt name="UnicastMetaOffset" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<p>This element specifies the port number for unicast meta traffic (refer to the DDSI 2.1 or 2.2 specification, section 9.6.1, constant d1).</p>
            ]]></comment>
          <default>10</default>
        </leafInt>
      </element>
      <leafString name="SPDPInterval" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element specifies the interval between spontaneous transmissions of participant discovery packets.</p>
<p>The unit must be specified explicitly. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <minimum>0</minimum>
        <maximum>1hr</maximum>
        <maxLength>0</maxLength>
        <default>30 s</default>
      </leafString>
      <leafString name="SPDPMulticastAddress" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element specifies the multicast address that is used as the destination for the participant discovery packets. In IPv4 mode the default is the (standardised) 239.255.0.1, in IPv6 mode it becomes ff02::ffff:239.255.0.1, which is a non-standardised link-local multicast address.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>239.255.0.1</default>
      </leafString>
    </element>
    <element name="General" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
<p>The General element specifies overall DDSI2E service settings.</p>
        ]]></comment>
      <leafString name="AllowMulticast" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element controls whether DDSI2E uses multicasts for data traffic.</p>
<p>It is a comma-separated list of some of the following keywords: "spdp", "asm", "ssm", or either of "false" or "true".</p>
<ul>
<li><i>spdp</i>: enables the use of ASM (any-source multicast) for participant discovery</li>
<li><i>asm</i>: enables the use of ASM for all traffic (including SPDP)</li>
<li><i>ssm</i>: enables the use of SSM (source-specific multicast) for all non-SPDP traffic (if supported)</li>
</ul>
<p>When set to "false" all multicasting is disabled. The default, "true" enables full use of multicasts. Listening for multicasts can be controlled by General/MulticastRecvNetworkInterfaceAddresses.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>true</default>
      </leafString>
      <leafBoolean name="CoexistWithNativeNetworking" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element specifies whether the DDSI2E service operates in conjunction with the Vortex OpenSplice RT Networking service. When "false", the DDSI2E service will take care of all communications, including those between Vortex OpenSplice nodes; when "true", the DDSI2E service only communicates with DDS implementations other than Vortex OpenSplice. In this case the RT Networking service should be configured as well.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafBoolean name="DontRoute" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element allows setting the SO_DONTROUTE option for outgoing packets, to bypass the local routing tables. This is generally useful only when the routing tables cannot be trusted, which is highly unusual.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafBoolean name="EnableMulticastLoopback" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element specifies whether DDSI2E allows IP multicast packets to be visible to all DDSI participants in the same node, including itself. It must be "true" for intra-node multicast communications, but if a node runs only a single DDSI2E service and does not host any other DDSI-capable programs, it should be set to "false" for improved performance.</p>
          ]]></comment>
        <default>true</default>
      </leafBoolean>
      <leafString name="ExternalNetworkAddress" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element allows explicitly overruling the network address DDSI2E advertises in the discovery protocol, which by default is the address of the preferred network interface (General/NetworkInterfaceAddress), to allow DDSI2E to communicate across a Network Address Translation (NAT) device.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>auto</default>
      </leafString>
      <leafString name="ExternalNetworkMask" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element specifies the network mask of the external network address. This element is relevant only when an external network address (General/ExternalNetworkAddress) is explicitly configured. In this case locators received via the discovery protocol that are within the same external subnet (as defined by this mask) will be translated to an internal address by replacing the network portion of the external address with the corresponding portion of the preferred network interface address. This option is IPv4-only.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>0.0.0.0</default>
      </leafString>
      <leafString name="FragmentSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element specifies the size of DDSI sample fragments generated by DDSI2E. Samples larger than FragmentSize are fragmented into fragments of FragmentSize bytes each, except the last one, which may be smaller. The DDSI spec mandates a minimum fragment size of 1025 bytes, but DDSI2E will do whatever size is requested, accepting fragments of which the size is at least the minimum of 1025 and FragmentSize.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>1280 B</default>
      </leafString>
      <leafString name="MaxMessageSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element specifies the maximum size of the UDP payload that DDSI2E will generate. DDSI2E will try to maintain this limit within the bounds of the DDSI specification, which means that in some cases (especially for very low values of MaxMessageSize) larger payloads may sporadically be observed (currently up to 1192 B).</p>
<p>On some networks it may be necessary to set this item to keep the packetsize below the MTU to prevent IP fragmentation. In those cases, it is generally advisable to also consider reducing Internal/FragmentSize.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>4096 B</default>
      </leafString>
      <leafString name="MulticastRecvNetworkInterfaceAddresses" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element specifies on which network interfaces DDSI2E listens to multicasts. The following options are available:</p>
<ul>
<li><i>all</i>: listen for multicasts on all multicast-capable interfaces; or</li>
<li><i>any</i>: listen for multicasts on the operating system default interface; or</li>
<li><i>preferred</i>: listen for multicasts on the preferred interface (General/NetworkInterfaceAddress); or</li>
<li><i>none</i>: does not listen for multicasts on any interface; or</li>
<li>a comma-separated list of network addresses: configures DDSI2E to listen for multicasts on all of the listed addresses.</li>
</ul>
<p>If DDSI2E is in IPv6 mode and the address of the preferred network interface is a link-local address, "all" is treated as a synonym for "preferred" and a comma-separated list is treated as "preferred" if it contains the preferred interface and as "none" if not.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>preferred</default>
      </leafString>
      <leafInt name="MulticastTimeToLive" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element specifies the time-to-live setting for outgoing multicast packets.</p>
          ]]></comment>
        <minimum>0</minimum>
        <maximum>255</maximum>
        <default>32</default>
      </leafInt>
      <leafString name="NetworkInterfaceAddress" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element specifies the preferred network interface for use by DDSI2E. The preferred network interface determines the IP address that DDSI2E advertises in the discovery protocol (but see also General/ExternalNetworkAddress), and is also the only interface over which multicasts are transmitted. The interface can be identified by its IP address, network interface name or network portion of the address. If the value "auto" is entered here, DDSI2E will select what it considers the most suitable interface.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>auto</default>
      </leafString>
      <leafBoolean name="StartupModeCoversTransient" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element configures whether startup-mode should also cover transient and persistent data, for configurations where the durability service does not take care of it. Configurations without defined merge policies best leave this enabled.</p>
          ]]></comment>
        <default>true</default>
      </leafBoolean>
      <leafString name="StartupModeDuration" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element specifies how long the DDSI2E remains in its "startup" mode. While in "startup" mode all volatile reliable data published on the local node is retained as-if it were transient-local data, allowing existing readers on remote nodes to obtain the data even though discovering them takes some time. Best-effort data by definition need not arrive, and transient and persistent data are covered by the durability service.</p>
<p>Once the system is stable, DDSI2E keeps track of the existence of remote readers whether or not matching writers exist locally, avoiding this discovery delay and ensuring this is merely a node startup issue.</p>
<p>Setting General/StartupModeDuration to 0s will disable it.</p>
<p>The unit must be specified explicitly. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <minimum>0</minimum>
        <maximum>60000</maximum>
        <maxLength>0</maxLength>
        <default>2 s</default>
      </leafString>
      <leafBoolean name="UseIPv6" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element can be used to DDSI2E use IPv6 instead of IPv4. This is currently an either/or switch.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
    </element>
    <element name="Internal" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
<p>The Internal elements deal with a variety of settings that evolving and that are not necessarily fully supported. For the vast majority of the Internal settings, the functionality per-se is supported, but the right to change the way the options control the functionality is reserved. This includes renaming or moving options.</p>
        ]]></comment>
      <leafInt name="AccelerateRexmitBlockSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>Proxy readers that are assumed to sill be retrieving historical data get this many samples retransmitted when they NACK something, even if some of these samples have sequence numbers outside the set covered by the NACK.</p>
          ]]></comment>
        <default>0</default>
      </leafInt>
      <leafBoolean name="AggressiveKeepLastWhc" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls whether to drop a reliable sample from a DDSI2E WHC before all readers have acknowledged it as soon as a later sample becomes available. It only affects DCPS data writers with a history QoS setting of KEEP_LAST with depth 1. The default setting, <i>false</i>, mimics the behaviour of the Vortex OpenSplice RT networking and is necessary to make the behaviour of wait_for_acknowledgements() consistent across the networking services.</p>
          ]]></comment>
        <default>true</default>
      </leafBoolean>
      <leafBoolean name="AggressiveKeepLastWhc" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls whether to drop a reliable sample from a DDSI2E WHC before all readers have acknowledged it as soon as a later sample becomes available. It only affects DCPS data writers with a history QoS setting of KEEP_LAST with depth 1. The default setting, <i>false</i>, mimics the behaviour of the Vortex OpenSplice RT networking and is necessary to make the behaviour of wait_for_acknowledgements() consistent across the networking services.</p>
          ]]></comment>
        <default>true</default>
      </leafBoolean>
      <leafString name="AssumeMulticastCapable" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls which network interfaces are assumed to be capable of multicasting even when the interface flags returned by the operating system state it is not (this provides a workaround for some platforms). It is a comma-separated lists of patterns (with ? and * wildcards) against which the interface names are matched.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default></default>
      </leafString>
      <leafString name="AutoReschedNackDelay" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This setting controls the interval with which a reader will continue NACK'ing missing samples in the absence of a response from the writer, as a protection mechanism against writers incorrectly stopping the sending of HEARTBEAT messages.</p>
<p>Valid values are finite durations with an explicit unit or the keyword 'inf' for infinity. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>1 s</default>
      </leafString>
      <leafString name="AuxiliaryBandwidthLimit" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This element specifies the maximum transmit rate of auxiliary traffic not bound to a specific channel, such as discovery traffic, as well as auxiliary traffic related to a certain channel if that channel has elected to share this global AuxiliaryBandwidthLimit. Bandwidth limiting uses a leaky bucket scheme. The default value "inf" means DDSI2E imposes no limitation, the underlying operating system and hardware will likely limit the maimum transmit rate.</p>
<p>The unit must be specified explicitly. Recognised units: <i>X</i>b/s, <i>X</i>bps for bits/s or <i>X</i>B/s, <i>X</i>Bps for bytes/s; where <i>X</i> is an optional prefix: k for 10<sup>3</sup>, Ki for 2<sup>10</sup>, M for 10<sup>6</sup>, Mi for 2<sup>20</sup>, G for 10<sup>9</sup>, Gi for 2<sup>30</sup>.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>inf</default>
      </leafString>
      <leafEnum name="BuiltinEndpointSet" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls which participants will have which built-in endpoints for the discovery and liveliness protocols. Valid values are:</p>
<ul><li><i>full</i>: all participants have all endpoints;</li>
<li><i>writers</i>: all participants have the writers, but just one has the readers;</li>
<li><i>minimal</i>: only one participant has built-in endpoints.</li></ul>
<p>The default is <i>writers</i>, as this is thought to be compliant and reasonably efficient. <i>Minimal</i> may or may not be compliant but is most efficient, and <i>full</i> is inefficient but certain to be compliant. See also Internal/ConservativeBuiltinReaderStartup.</p>
          ]]></comment>
        <value>full</value>
        <value>writers</value>
        <value>minimal</value>
        <default>writers</default>
      </leafEnum>
      <leafBoolean name="ConservativeBuiltinReaderStartup" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This element forces all DDSI2E built-in discovery-related readers to request all historical data, instead of just one for each "topic". There is no indication that any of the current DDSI implementations requires changing of this setting, but it is conceivable that an implementation might track which participants have been informed of the existence of endpoints and which have not been, refusing communication with those that have "can't" know.</p>
<p>Should it be necessary to hide DDSI2E's shared discovery behaviour, set this to <i>true</i> and Internal/BuiltinEndpointSet to <i>full</i>.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <element name="ControlTopic" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>The ControlTopic element allows configured whether DDSI2E provides a special control interface via a predefined topic or not.<p>
          ]]></comment>
        <attributeBoolean name="enable" required="false" version="COMMERCIAL">
          <comment><![CDATA[
<b>Internal</b> <p>This attribute controls whether the DDSI2E control topic is defined and acted upon by DDSI2</p>
            ]]></comment>
          <default>false</default>
        </attributeBoolean>
        <attributeString name="initialreset" required="false" version="COMMERCIAL">
          <comment><![CDATA[
<b>Internal</b> <p>This attribute sets the time until the deaf and mute settings are automatically reset to false</p>
<p>Valid values are finite durations with an explicit unit or the keyword 'inf' for infinity. Recognised units: ns, us, ms, s, min, hr, day.</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default>inf</default>
        </attributeString>
        <leafBoolean name="Deaf" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<b>Internal</b> <p>This element controls whether DDSI2E defaults to deaf mode or to normal mode. This controls both the initial behaviour and what behaviour it auto-reverts to.</p>
            ]]></comment>
          <default>false</default>
        </leafBoolean>
        <leafBoolean name="Mute" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<b>Internal</b> <p>This element controls whether DDSI2E defaults to mute mode or to normal mode. This controls both the initial behaviour and what behaviour it auto-reverts to.</p>
            ]]></comment>
          <default>false</default>
        </leafBoolean>
      </element>
      <leafInt name="DDSI2DirectMaxThreads" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This element sets the maximum number of extra threads for an experimental, undocumented and unsupported direct mode.</p>
          ]]></comment>
        <default>1</default>
      </leafInt>
      <leafInt name="DefragReliableMaxSamples" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This element sets the maximum number of samples that can be defragmented simultaneously for a reliable writer. This has to be large enough to handle retransmissions of historical data in addition to new samples.</p>
          ]]></comment>
        <default>16</default>
      </leafInt>
      <leafInt name="DefragUnreliableMaxSamples" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This element sets the maximum number of samples that can be defragmented simultaneously for a best-effort writers.</p>
          ]]></comment>
        <default>4</default>
      </leafInt>
      <leafInt name="DeliveryQueueMaxSamples" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls the Maximum size of a delivery queue, expressed in samples. Once a delivery queue is full, incoming samples destined for that queue are dropped until space becomes available again.</p>
          ]]></comment>
        <default>256</default>
      </leafInt>
      <leafBoolean name="ForwardAllMessages" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>Forward all messages from a writer, rather than trying to forward each sample only once. The default of trying to forward each sample only once filters out duplicates for writers in multiple partitions under nearly all circumstances, but may still publish the odd duplicate. Note: the current implementation also can lose in contrived test cases, that publish more than 2**32 samples using a single data writer in conjunction with carefully controlled management of the writer history via cooperating local readers.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafEnum name="ForwardRemoteData" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls whether DDSI2E forwards data received from other network services in the domain.</p>
          ]]></comment>
        <value>false</value>
        <value>true</value>
        <value>default</value>
        <default>default</default>
      </leafEnum>
      <leafBoolean name="GenerateKeyhash" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>When true, include keyhashes in outgoing data for topics with keys.</p>
          ]]></comment>
        <default>true</default>
      </leafBoolean>
      <leafString name="HeartbeatInterval" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This element sets the base interval for the asynchronous, periodic writer heartbeats when unacknowledged data is present in its writer history cache. The actual interval is dynamically adjusted, the attributes of this element allow further configuration.</p>
<p>Valid values are finite durations with an explicit unit or the keyword 'inf' for infinity. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>100 ms</default>
        <attributeString name="max" required="false" version="COMMERCIAL">
          <comment><![CDATA[
<b>Internal</b> <p>This attribute sets the maximum interval for periodic heartbeats.</p>
<p>Valid values are finite durations with an explicit unit or the keyword 'inf' for infinity. Recognised units: ns, us, ms, s, min, hr, day.</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default>8 s</default>
        </attributeString>
        <attributeString name="min" required="false" version="COMMERCIAL">
          <comment><![CDATA[
<b>Internal</b> <p>This attribute sets the minimum interval that must have passed since the most recent heartbeat from a writer, before another asynchronous (not directly related to writing) will be sent.</p>
<p>Valid values are finite durations with an explicit unit or the keyword 'inf' for infinity. Recognised units: ns, us, ms, s, min, hr, day.</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default>5 ms</default>
        </attributeString>
        <attributeString name="minsched" required="false" version="COMMERCIAL">
          <comment><![CDATA[
<b>Internal</b> <p>This attribute sets the minimum interval for periodic heartbeats. Other events may still cause heartbeats to go out.</p>
<p>Valid values are finite durations with an explicit unit or the keyword 'inf' for infinity. Recognised units: ns, us, ms, s, min, hr, day.</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default>20 ms</default>
        </attributeString>
      </leafString>
      <leafBoolean name="LateAckMode" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>Ack a sample only when it has been delivered, instead of when committed to delivering it.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafString name="LeaseDuration" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This setting controls the default participant lease duration. <p>
<p>The unit must be specified explicitly. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <minimum>0</minimum>
        <maximum>1hr</maximum>
        <maxLength>0</maxLength>
        <default>0 s</default>
      </leafString>
      <leafBoolean name="LegacyFragmentation" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This option enables a backwards-compatible, non-compliant setting and interpretation of the control flags in fragmented data messages. To be enabled <i>only</i> when requiring interoperability between compliant and non-compliant versions of DDSI2E for large messages.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafBoolean name="LogStackTraces" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls whether or not to write stack traces to the DDSI2 trace when a thread fails to make progress (on select platforms only).</p>
          ]]></comment>
        <default>true</default>
      </leafBoolean>
      <leafInt name="MaxParticipants" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This elements configures the maximum number of DCPS domain participants this DDSI2E instance is willing to service. 0 is unlimited.</p>
          ]]></comment>
        <default>0</default>
      </leafInt>
      <leafString name="MaxQueuedRexmitBytes" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This setting limits the maximum number of bytes queued for retransmission. The default value of 0 is unlimited unless an AuxiliaryBandwidthLimit has been set, in which case it becomes NackDelay * AuxiliaryBandwidthLimit. It must be large enough to contain the largest sample that may need to be retransmitted.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>50 kB</default>
      </leafString>
      <leafInt name="MaxQueuedRexmitMessages" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This settings limits the maximum number of samples queued for retransmission.</p>
          ]]></comment>
        <default>200</default>
      </leafInt>
      <leafString name="MaxSampleSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This setting controls the maximum (CDR) serialised size of samples that DDSI2E will forward in either direction. Samples larger than this are discarded with a warning.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>2147483647 B</default>
      </leafString>
      <leafBoolean name="MeasureHbToAckLatency" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This element enables heartbeat-to-ack latency among DDSI2E services by prepending timestamps to Heartbeat and AckNack messages and calculating round trip times. This is non-standard behaviour. The measured latencies are quite noisy and are currently not used anywhere.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafString name="MinimumSocketReceiveBufferSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This setting controls the minimum size of socket receive buffers. The operating system provides some size receive buffer upon creation of the socket, this option can be used to increase the size of the buffer beyond that initially provided by the operating system. If the buffer size cannot be increased to the specified size, an error is reported.</p>
<p>The default setting is the word "default", which means DDSI2E will attempt to increase the buffer size to 1MB, but will silently accept a smaller buffer should that attempt fail.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>default</default>
      </leafString>
      <leafString name="MinimumSocketSendBufferSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This setting controls the minimum size of socket send buffers. This setting can only increase the size of the send buffer, if the operating system by default creates a larger buffer, it is left unchanged.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>64 KiB</default>
      </leafString>
      <leafEnum name="MirrorRemoteEntities" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls whether DDSI2 mirrors all entities in the domain in DDSI or only local ones. Default is to discover remote ones iff General/LocalDiscoveryPartition is not the built-in partition.</p>
          ]]></comment>
        <value>false</value>
        <value>true</value>
        <value>default</value>
        <default>default</default>
      </leafEnum>
      <leafInt name="MonitorPort" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This element allows configuring a service that dumps a text description of part the internal state to TCP clients. By default (-1), this is disabled; specifying 0 means a kernel-allocated port is used; a positive number is used as the TCP port number.</p>
          ]]></comment>
        <default>-1</default>
      </leafInt>
      <leafString name="NackDelay" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This setting controls the delay between receipt of a HEARTBEAT indicating missing samples and a NACK (ignored when the HEARTBEAT requires an answer). However, no NACK is sent if a NACK had been scheduled already for a response earlier than the delay requests: then that NACK will incorporate the latest information.</p>
<p>The unit must be specified explicitly. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <minimum>0</minimum>
        <maximum>1hr</maximum>
        <maxLength>0</maxLength>
        <default>10 ms</default>
      </leafString>
      <leafString name="PreEmptiveAckDelay" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This setting controls the delay between the discovering a remote writer and sending a pre-emptive AckNack to discover the range of data available.</p>
<p>The unit must be specified explicitly. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <minimum>0</minimum>
        <maximum>1hr</maximum>
        <maxLength>0</maxLength>
        <default>10 ms</default>
      </leafString>
      <leafInt name="PrimaryReorderMaxSamples" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This element sets the maximum size in samples of a primary re-order administration. Each proxy writer has one primary re-order administration to buffer the packet flow in case some packets arrive out of order. Old samples are forwarded to secondary re-order administrations associated with readers in need of historical data.</p>
          ]]></comment>
        <default>64</default>
      </leafInt>
      <leafBoolean name="PrioritizeRetransmit" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls whether retransmits are prioritized over new data, speeding up recovery.</p>
          ]]></comment>
        <default>true</default>
      </leafBoolean>
      <leafString name="RediscoveryBlacklistDuration" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls for how long a remote participant that was previously deleted will remain on a blacklist to prevent rediscovery, giving the software on a node time to perform any cleanup actions it needs to do. To some extent this delay is required internally by DDSI2E, but in the default configuration with the 'enforce' attribute set to false, DDSI2E will reallow rediscovery as soon as it has cleared its internal administration. Setting it to too small a value may result in the entry being pruned from the blacklist before DDSI2E is ready, it is therefore recommended to set it to at least several seconds.</p>
<p>Valid values are finite durations with an explicit unit or the keyword 'inf' for infinity. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>10s</default>
        <attributeBoolean name="enforce" required="false" version="COMMERCIAL">
          <comment><![CDATA[
<b>Internal</b> <p>This attribute controls whether the configured time during which recently deleted participants will not be rediscovered (i.e., "black listed") is enforced and following complete removal of the participant in DDSI2E, or whether it can be rediscovered earlier provided all traces of that participant have been removed already.</p>
            ]]></comment>
          <default>false</default>
        </attributeBoolean>
      </leafString>
      <leafString name="ResponsivenessTimeout" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls for how long an unresponsive reader can block the transmit thread by failing to acknowledge data when a writer's DDSI2E write cache is full. If after this time the writer's cache has not shrunk to below the low-water mark, the reader is considered unresponsive and degraded to unreliable. It will be restored to reliable service once it resumes acknowledging samples.</p>
<p>Valid values are finite durations with an explicit unit or the keyword 'inf' for infinity. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>inf</default>
      </leafString>
      <leafEnum name="RetransmitMerging" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This elements controls the addressing and timing of retransmits. Possible values are:</p>
<ul><li><i>never</i>: retransmit only to the NACK-ing reader;</li>
<li><i>adaptive</i>: attempt to combine retransmits needed for reliability, but send historical (transient-local) data to the requesting reader only;</li>
<li><i>always</i>: do not distinguish between different causes, always try to merge.</li></ul>
<p>The default is <i>adaptive</i>. See also Internal/RetransmitMergingPeriod.</p>
          ]]></comment>
        <value>never</value>
        <value>adaptive</value>
        <value>always</value>
        <default>adaptive</default>
      </leafEnum>
      <leafString name="RetransmitMergingPeriod" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This setting determines the size of the time window in which a NACK of some sample is ignored because a retransmit of that sample has been multicasted too recently. This setting has no effect on unicasted retransmits.</p>
<p>See also Internal/RetransmitMerging.</p>
<p>The unit must be specified explicitly. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <minimum>0</minimum>
        <maximum>1s</maximum>
        <maxLength>0</maxLength>
        <default>5 ms</default>
      </leafString>
      <leafBoolean name="RetryOnRejectBestEffort" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>Whether or not to locally retry pushing a received best-effort sample into the reader caches when resource limits are reached.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafString name="RetryOnRejectDuration" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>How long to keep locally retrying pushing a received sample into the reader caches when resource limits are reached. Default is dependent on Internal/LateAckMode: if the latter is false, it is 80% of Internal/ResponsivenessTimeout, otherwise it is 0.</p>
<p>Valid values are finite durations with an explicit unit or the keyword 'inf' for infinity. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>default</default>
      </leafString>
      <leafString name="SPDPResponseMaxDelay" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>Maximum pseudo-random delay in milliseconds between discovering a remote participant and responding to it.</p>
<p>The unit must be specified explicitly. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <minimum>0</minimum>
        <maximum>1s</maximum>
        <maxLength>0</maxLength>
        <default>0 ms</default>
      </leafString>
      <leafString name="ScheduleTimeRounding" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This setting allows the timing of scheduled events to be rounded up so that more events can be handled in a single cycle of the event queue. The default is 0 and causes no rounding at all, i.e. are scheduled exactly, whereas a value of 10ms would mean that events are rounded up to the nearest 10 milliseconds.</p>
<p>The unit must be specified explicitly. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <minimum>0</minimum>
        <maximum>1hr</maximum>
        <maxLength>0</maxLength>
        <default>0 ms</default>
      </leafString>
      <leafInt name="SecondaryReorderMaxSamples" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This element sets the maximum size in samples of a secondary re-order administration. The secondary re-order administration is per reader in need of historical data.</p>
          ]]></comment>
        <default>16</default>
      </leafInt>
      <leafBoolean name="SquashParticipants" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls whether DDSI2E advertises all the domain participants it serves in DDSI (when set to <i>false</i>), or rather only one domain participant (the one corresponding to the DDSI2E process; when set to <i>true</i>). In the latter case DDSI2E becomes the virtual owner of all readers and writers of all domain participants, dramatically reducing discovery traffic (a similar effect can be obtained by setting Internal/BuiltinEndpointSet to "minimal" but with less loss of information).</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafBoolean name="SuppressSPDPMulticast" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>The element controls whether the mandatory multicasting of the participant discovery packets occurs. Completely disabling multicasting requires this element be set to <i>true</i>, and generally requires explicitly listing peers to ping for unicast discovery.</p>
<p>See also General/AllowMulticast.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafString name="SynchronousDeliveryLatencyBound" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls whether samples sent by a writer with QoS settings transport_priority >= SynchronousDeliveryPriorityThreshold and a latency_budget at most this element's value will be delivered synchronously from the "recv" thread, all others will be delivered asynchronously through delivery queues. This reduces latency at the expense of aggregate bandwidth.</p>
<p>Valid values are finite durations with an explicit unit or the keyword 'inf' for infinity. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>inf</default>
      </leafString>
      <leafInt name="SynchronousDeliveryPriorityThreshold" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls whether samples sent by a writer with QoS settings latency_budget <= SynchronousDeliveryLatencyBound and transport_priority greater than or equal to this element's value will be delivered synchronously from the "recv" thread, all others will be delivered asynchronously through delivery queues. This reduces latency at the expense of aggregate bandwidth.</p>
          ]]></comment>
        <default>0</default>
      </leafInt>
      <element name="Test" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>Testing options.</p>
          ]]></comment>
        <leafInt name="XmitLossiness" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<b>Internal</b> <p>This element controls the fraction of outgoing packets to drop, specified as samples per thousand.</p>
            ]]></comment>
          <default>0</default>
        </leafInt>
      </element>
      <leafBoolean name="UnicastResponseToSPDPMessages" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls whether the response to a newly discovered participant is sent as a unicasted SPDP packet, instead of rescheduling the periodic multicasted one. There is no known benefit to setting this to <i>false</i>.</p>
          ]]></comment>
        <default>true</default>
      </leafBoolean>
      <leafInt name="UseMulticastIfMreqn" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>Do not use.</p>
          ]]></comment>
        <default>0</default>
      </leafInt>
      <element name="Watermarks" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>Watermarks for flow-control.</p>
          ]]></comment>
        <leafBoolean name="WhcAdaptive" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<b>Internal</b> <p>This element controls whether DDSI2E will adapt the high-water mark to current traffic conditions, based on retransmit requests and transmit pressure.</p>
            ]]></comment>
          <default>true</default>
        </leafBoolean>
        <leafString name="WhcHigh" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<b>Internal</b> <p>This element sets the maximum allowed high-water mark for the DDSI2E WHCs, expressed in bytes. A writer is suspended when the WHC reaches this size.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default>100 kB</default>
        </leafString>
        <leafString name="WhcHighInit" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<b>Internal</b> <p>This element sets the initial level of the high-water mark for the DDSI2E WHCs, expressed in bytes.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default>30 kB</default>
        </leafString>
        <leafString name="WhcLow" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<b>Internal</b> <p>This element sets the low-water mark for the DDSI2E WHCs, expressed in bytes. A suspended writer resumes transmitting when its DDSI2E WHC shrinks to this size.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default>1 kB</default>
        </leafString>
      </element>
      <leafString name="WriterLingerDuration" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<b>Internal</b> <p>This setting controls the maximum duration for which actual deletion of a reliable writer with unacknowledged data in its history will be postponed to provide proper reliable transmission.<p>
<p>The unit must be specified explicitly. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <minimum>0</minimum>
        <maximum>1hr</maximum>
        <maxLength>0</maxLength>
        <default>1 s</default>
      </leafString>
    </element>
    <element name="Partitioning" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
<p>The Partitioning element specifies DDSI2E network partitions and how DCPS partition/topic combinations are mapped onto the network partitions.</p>
        ]]></comment>
      <element name="IgnoredPartitions" minOccurrences="0" maxOccurrences="0" version="COMMERCIAL">
        <comment><![CDATA[
<p>The IgnoredPartitions element specifies DCPS partition/topic combinations that are not distributed over the network.</p>
          ]]></comment>
        <element name="IgnoredPartition" minOccurrences="0" maxOccurrences="0" version="COMMERCIAL">
          <comment><![CDATA[
<p>This element can be used to prevent certain combinations of DCPS partition and topic from being transmitted over the network. DDSI2E will complete ignore readers and writers for which all DCPS partitions as well as their topic is ignored, not even creating DDSI readers and writers to mirror the DCPS ones.</p>
            ]]></comment>
          <attributeString name="DCPSPartitionTopic" required="true" version="COMMERCIAL">
            <comment><![CDATA[
<p>This attribute specifies a partition and a topic expression, separated by a single '.', that are used to determine if a given partition and topic will be ignored or not. The expressions may use the usual wildcards '*' and '?'. DDSI2E will consider an wildcard DCPS partition to match an expression iff there exists a string that satisfies both expressions.</p>
              ]]></comment>
            <maxLength>0</maxLength>
            <default></default>
          </attributeString>
        </element>
      </element>
      <element name="NetworkPartitions" minOccurrences="0" maxOccurrences="0" version="COMMERCIAL">
        <comment><![CDATA[
<p>The NetworkPartitions element specifies the DDSI2E network partitions.</p>
          ]]></comment>
        <element name="NetworkPartition" minOccurrences="0" maxOccurrences="0" version="COMMERCIAL">
          <comment><![CDATA[
<p>This element defines a DDSI2E network partition.</p>
            ]]></comment>
          <attributeString name="Address" required="true" version="COMMERCIAL">
            <comment><![CDATA[
<p>This attribute specifies the multicast addresses associated with the network partition as a comma-separated list. Readers matching this network partition (cf. Partitioning/PartitionMappings) will listen for multicasts on all of these addresses and advertise them in the discovery protocol. The writers will select the most suitable address from the addresses advertised by the readers.</p>
              ]]></comment>
            <maxLength>0</maxLength>
            <default></default>
          </attributeString>
          <attributeBoolean name="Connected" required="false" version="COMMERCIAL">
            <comment><![CDATA[
<p>This attribute is a placeholder.</p>
              ]]></comment>
            <default>true</default>
          </attributeBoolean>
          <attributeString name="Name" required="true" version="COMMERCIAL">
            <comment><![CDATA[
<p>This attribute specifies the name of this DDSI2E network partition. Two network partitions cannot have the same name.</p>
              ]]></comment>
            <maxLength>0</maxLength>
            <default></default>
          </attributeString>
          <attributeString name="SecurityProfile" required="false" version="COMMERCIAL">
            <comment><![CDATA[
<p>This attribute selects the DDSI2E security profile for encrypting the traffic mapped to this DDSI2E network partition. The default "null" means the network partition is unsecured; any other name refers to a security profile defined using the Security/SecurityProfile elements.</p>
              ]]></comment>
            <maxLength>0</maxLength>
            <default>null</default>
          </attributeString>
        </element>
      </element>
      <element name="PartitionMappings" minOccurrences="0" maxOccurrences="0" version="COMMERCIAL">
        <comment><![CDATA[
<p>The PartitionMappings element specifies the mapping from DCPS partition/topic combinations to DDSI2E network partitions.</p>
          ]]></comment>
        <element name="PartitionMapping" minOccurrences="0" maxOccurrences="0" version="COMMERCIAL">
          <comment><![CDATA[
<p>This element defines a mapping from a DCPS partition/topic combination to a DDSI2E network partition. This allows partitioning data flows by using special multicast addresses for part of the data and possibly also encrypting the data flow.</p>
            ]]></comment>
          <attributeString name="DCPSPartitionTopic" required="true" version="COMMERCIAL">
            <comment><![CDATA[
<p>This attribute specifies a partition and a topic expression, separated by a single '.', that are used to determine if a given partition and topic maps to the DDSI2E network partition named by the NetworkPartition attribute in this PartitionMapping element. The expressions may use the usual wildcards '*' and '?'. DDSI2E will consider a wildcard DCPS partition to match an expression if there exists a string that satisfies both expressions.</p>
              ]]></comment>
            <maxLength>0</maxLength>
            <default></default>
          </attributeString>
          <attributeString name="NetworkPartition" required="true" version="COMMERCIAL">
            <comment><![CDATA[
<p>This attribute specifies which DDSI2E network partition is to be used for DCPS partition/topic combinations matching the DCPSPartitionTopic attribute within this PartitionMapping element.</p>
              ]]></comment>
            <maxLength>0</maxLength>
            <default></default>
          </attributeString>
        </element>
      </element>
    </element>
    <element name="SSL" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
<p>The SSL element allows specifying various parameters related to using SSL/TLS for DDSI over TCP.</p>
        ]]></comment>
      <leafBoolean name="CertificateVerification" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>If disabled this allows SSL connections to occur even if an X509 certificate fails verification.</p>
          ]]></comment>
        <default>true</default>
      </leafBoolean>
      <leafString name="Ciphers" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>The set of ciphers used by SSL/TLS</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH</default>
      </leafString>
      <leafBoolean name="Enable" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This enables SSL/TLS for TCP.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafString name="EntropyFile" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>The SSL/TLS random entropy file name.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default></default>
      </leafString>
      <leafString name="KeyPassphrase" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>The SSL/TLS key pass phrase for encrypted keys.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>secret</default>
      </leafString>
      <leafString name="KeystoreFile" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>The SSL/TLS key and certificate store file name. The keystore must be in PEM format.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>keystore</default>
      </leafString>
      <leafBoolean name="SelfSignedCertificates" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This enables the use of self signed X509 certificates.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafBoolean name="VerifyClient" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This enables an SSL server checking the X509 certificate of a connecting client.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
    </element>
    <element name="Security" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
<p>The Security element specifies DDSI2E security profiles that can be used to encrypt traffic mapped to DDSI2E network partitions.</p>
        ]]></comment>
      <element name="SecurityProfile" minOccurrences="0" maxOccurrences="0" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element defines a DDSI2E security profile.</p>
          ]]></comment>
        <attributeEnum name="Cipher" required="false" version="COMMERCIAL">
          <comment><![CDATA[
<p>This attribute specifies the cipher to be used for encrypting traffic over network partitions secured by this security profile. The possible ciphers are:</p>
<ul><li><i>aes128</i>: AES with a 128-bit key;</li>
<li><i>aes192</i>: AES with a 192-bit key;</li>
<li><i>aes256</i>: AES with a 256-bit key;</li>
<li><i>blowfish</i>: the Blowfish cipher with a 128 bit key;</li>
<li><i>null</i>: no encryption;</li></ul>
<p>SHA1 is used on conjunction with all ciphers except "null" to ensure data integrity.</p>
            ]]></comment>
          <value>null</value>
          <value>blowfish</value>
          <value>aes128</value>
          <value>aes192</value>
          <value>aes256</value>
          <default>null</default>
        </attributeEnum>
        <attributeString name="CipherKey" required="false" version="COMMERCIAL">
          <comment><![CDATA[
<p>The CipherKey attribute is used to define the secret key required by the cipher selected using the Cipher attribute. The value can be a URI referencing an external file containing the secret key, or the secret key can be defined in-place as a string value.</p>
<p>The key must be specified as a hexadecimal string with each character representing 4 bits of the key. E.g., 1ABC represents the 16-bit key 0001 1010 1011 1100. The key should not follow a well-known pattern and must exactly match the key length of the selected cipher.</p>
<p>A malformed key will cause the security profile to be marked as invalid, and disable all network partitions secured by the (invalid) security profile to prevent information leaks.</p>
<p>As all DDS applications require read access to the XML configuration file, for security reasons it is recommended to store the secret key in an external file in the file system, referenced by its URI. The file should be protected against read and write access from other users on the host.</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default></default>
        </attributeString>
        <attributeString name="Name" required="true" version="COMMERCIAL">
          <comment><![CDATA[
<p>This attribute specifies the name of this DDSI2E security profile. Two security profiles cannot have the same name.</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default></default>
        </attributeString>
      </element>
    </element>
    <element name="Sizing" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
<p>The Sizing element specifies a variety of configuration settings dealing with expected system sizes, buffer sizes, &c.</p>
        ]]></comment>
      <leafInt name="EndpointsInSystem" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This endpoint specifies the expected maximum number of endpoints in the network. Underestimating this number will have a significant performance impact, but will not affect correctness; signficantly overestimating it will cause more memory to be used than necessary.</p>
          ]]></comment>
        <default>20000</default>
      </leafInt>
      <leafInt name="EndpointsInSystem" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This endpoint specifies the expected maximum number of endpoints in the network. Underestimating this number will have a significant performance impact, but will not affect correctness; signficantly overestimating it will cause more memory to be used than necessary.</p>
          ]]></comment>
        <default>20000</default>
      </leafInt>
      <leafInt name="LocalEndpoints" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element specifies the expected maximum number of endpoints local to one DDSI2E service. Underestimating this number will have a significant performance impact, but will not affect correctness; signficantly overestimating it will cause more memory to be used than necessary.</p>
          ]]></comment>
        <default>1000</default>
      </leafInt>
      <leafInt name="NetworkQueueSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element specifies the maximum number of samples in the network queue. Write/dispose operations add samples to this queue, the DDSI2E service drains it. Larger values allow large bursts of writes to occur without forcing synchronization between the application and the DDSI2E service, but do introduce the potential for longer latencies and increase the maximum amount of memory potentially occupied by messages in the queue.</p>
          ]]></comment>
        <default>1000</default>
      </leafInt>
      <leafInt name="NetworkQueueSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element specifies the maximum number of samples in the network queue. Write/dispose operations add samples to this queue, the DDSI2E service drains it. Larger values allow large bursts of writes to occur without forcing synchronization between the application and the DDSI2E service, but do introduce the potential for longer latencies and increase the maximum amount of memory potentially occupied by messages in the queue.</p>
          ]]></comment>
        <default>1000</default>
      </leafInt>
      <leafString name="ReceiveBufferChunkSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element specifies the size of one allocation unit in the receive buffer. Must be greater than the maximum packet size by a modest amount (too large packets are dropped). Each allocation is shrunk immediately after processing a message, or freed straightaway.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>128 KiB</default>
      </leafString>
      <leafString name="ReceiveBufferChunkSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element specifies the size of one allocation unit in the receive buffer. Must be greater than the maximum packet size by a modest amount (too large packets are dropped). Each allocation is shrunk immediately after processing a message, or freed straightaway.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>128 KiB</default>
      </leafString>
      <element name="Watermarks" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
#if LITE  { LEAF ("ReceiveBufferSize"), 1, "128 KiB", ABSOFF (rbuf_size), 0, uf_memsize, 0, pf_memsize,    "<p>This element sets the size of a single receive buffer. Many receive buffers may be needed. Their size must be greater than ReceiveBufferChunkSize by a modest amount.</p>
          ]]></comment>
        <leafBoolean name="WhcAdaptive" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<p>This element controls whether DDSI2E will adapt the high-water mark to current traffic conditions, based on retransmit requests and transmit pressure.</p>
            ]]></comment>
          <default>true</default>
        </leafBoolean>
        <leafString name="WhcHigh" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<p>This element sets the maximum allowed high-water mark for the DDSI2E WHCs, expressed in bytes. A writer is suspended when the WHC reaches this size.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default>100 kB</default>
        </leafString>
        <leafString name="WhcHighInit" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<p>This element sets the initial level of the high-water mark for the DDSI2E WHCs, expressed in bytes.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default>30 kB</default>
        </leafString>
        <leafString name="WhcLow" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<p>This element sets the low-water mark for the DDSI2E WHCs, expressed in bytes. A suspended writer resumes transmitting when its DDSI2E WHC shrinks to this size.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default>1 kB</default>
        </leafString>
      </element>
    </element>
    <element name="TCP" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
<p>The TCP element allows specifying various parameters related to running DDSI over TCP.</p>
        ]]></comment>
      <leafBoolean name="Enable" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element enables the optional TCP transport.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafBoolean name="NoDelay" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element enables the TCP_NODELAY socket option, preventing multiple DDSI messages being sent in the same TCP request. Setting this option typically optimises latency over throughput.</p>
          ]]></comment>
        <default>true</default>
      </leafBoolean>
      <leafInt name="Port" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element specifies the TCP port number on which DDSI2E accepts connections. If the port is set it is used in entity locators, published with DDSI discovery. Dynamically allocated if zero. Disabled if -1 or not configured. If disabled other DDSI services will not be able to establish connections with the service, the service can only communicate by establishing connections to other services.</p>
          ]]></comment>
        <minimum>-1</minimum>
        <maximum>65535</maximum>
        <default>-1</default>
      </leafInt>
      <leafString name="ReadTimeout" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element specifies the timeout for blocking TCP read operations. If this timeout expires then the connection is closed.</p>
<p>The unit must be specified explicitly. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <minimum>0</minimum>
        <maximum>1hr</maximum>
        <maxLength>0</maxLength>
        <default>2 s</default>
      </leafString>
      <leafString name="WriteTimeout" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element specifies the timeout for blocking TCP write operations. If this timeout expires then the connection is closed.</p>
<p>The unit must be specified explicitly. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <minimum>0</minimum>
        <maximum>1hr</maximum>
        <maxLength>0</maxLength>
        <default>2 s</default>
      </leafString>
    </element>
    <element name="ThreadPool" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
<p>The ThreadPool element allows specifying various parameters related to using a thread pool to send DDSI messages to multiple unicast addresses (TCP or UDP).</p>
        ]]></comment>
      <leafBoolean name="Enable" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element enables the optional thread pool.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafInt name="ThreadMax" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This elements configures the maximum number of threads in the thread pool.</p>
          ]]></comment>
        <default>8</default>
      </leafInt>
      <leafInt name="Threads" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This elements configures the initial number of threads in the thread pool.</p>
          ]]></comment>
        <default>4</default>
      </leafInt>
    </element>
    <element name="Threads" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
<p>This element is used to set thread properties.</p>
        ]]></comment>
      <element name="Thread" minOccurrences="0" maxOccurrences="1000" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element is used to set thread properties.</p>
          ]]></comment>
        <attributeString name="Name" required="true" version="COMMERCIAL">
          <comment><![CDATA[
<p>The Name of the thread for which properties are being set. The following threads exist:</p>
<ul><li><i>gc</i>: garbage collector thread involved in deleting entities;</li>
<li><i>recv</i>: receive thread, taking data from the network and running the protocol state machine;</li>
<li><i>dq.builtins</i>: delivery thread for DDSI-builtin data, primarily for discovery;</li>
<li><i>lease</i>: DDSI liveliness monitoring;</li>
<li><i>tev</i>: general timed-event handling, retransmits and discovery;</li>
<li><i>xmit.CHAN</i>: transmit thread for channel CHAN;</li>
<li><i>dq.CHAN</i>: delivery thread for channel CHAN;</li>
<li><i>tev.CHAN</i>: timed-even thread for channel CHAN.</li></ul>
            ]]></comment>
          <maxLength>0</maxLength>
          <default></default>
        </attributeString>
        <element name="Scheduling" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<p>This element configures the scheduling properties of the thread.</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <leafEnum name="Class" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
<p>This element specifies the thread scheduling class (<i>realtime</i>, <i>timeshare</i> or <i>default</i>). The user may need special privileges from the underlying operating system to be able to assign some of the privileged scheduling classes.</p>
              ]]></comment>
            <value>realtime</value>
            <value>timeshare</value>
            <value>default</value>
            <default>default</default>
          </leafEnum>
          <leafString name="Priority" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
            <comment><![CDATA[
<p>This element specifies the thread priority (decimal integer or <i>default</i>). Only priorities that are supported by the underlying operating system can be assigned to this element. The user may need special privileges from the underlying operating system to be able to assign some of the privileged priorities.</p>
              ]]></comment>
            <maxLength>0</maxLength>
            <default>default</default>
          </leafString>
        </element>
        <leafString name="StackSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<p>This element configures the stack size for this thread. The default value <i>default</i> leaves the stack size at the operating system default.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default>default</default>
        </leafString>
      </element>
    </element>
    <element name="Tracing" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
<p>The Tracing element controls the amount and type of information that is written into the tracing log by the DDSI service. This is useful to track the DDSI service during application development.</p>
        ]]></comment>
      <leafBoolean name="AppendToFile" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This option specifies whether the output is to be appended to an existing log file. The default is to create a new log file each time, which is generally the best option if a detailed log is generated.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafString name="EnableCategory" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element enables individual logging categories. These are enabled in addition to those enabled by Tracing/Verbosity. Recognised categories are:</p>
<ul><li><i>fatal</i>: all fatal errors, errors causing immediate termination</li>
<li><i>error</i>: failures probably impacting correctness but not necessarily causing immediate termination</li>
<li><i>warning</i>: abnormal situations that will likely not impact correctness</li>
<li><i>config</i>: full dump of the configuration</li>
<li><i>info</i>: general informational notices</li>
<li><i>discovery</i>: all discovery activity</li>
<li><i>data</i>: include data content of samples in traces</li>
<li><i>radmin</i>: receive buffer administration</li>
<li><i>timing</i>: periodic reporting of CPU loads per thread</li>
<li><i>traffic</i>: periodic reporting of total outgoing data</li>
<li><i>whc</i>: tracing of writer history cache changes</li>
<li><i>tcp</i>: tracing of TCP-specific activity</li>
<li><i>topic</i>: tracing of topic definitions</li>
<li>>i>plist</i>: tracing of discovery parameter list interpretation</li> </ul>
<p>In addition, there is the keyword <i>trace</i> that enables all but <i>radmin</i>, <i>topic</i>, <i>plist</i> and <i>whc</i></p>.
<p>The categorisation of tracing output is incomplete and hence most of the verbosity levels and categories are not of much use in the current release. This is an ongoing process and here we describe the target situation rather than the current situation. Currently, the most useful is <i>trace</i>.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default></default>
      </leafString>
      <leafString name="OutputFile" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This option specifies where the logging is printed to. Note that <i>stdout</i> and <i>stderr</i> are treated as special values, representing "standard out" and "standard error" respectively. No file is created unless logging categories are enabled using the Tracing/Verbosity or Tracing/EnabledCategory settings.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>ddsi2.log</default>
      </leafString>
      <leafString name="PacketCaptureFile" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This option specifies the file to which received and sent packets will be logged in the "pcap" format suitable for analysis using common networking tools, such as WireShark. IP and UDP headers are ficitious, in particular the destination address of received packets. The TTL may be used to distinguish between sent and received packets: it is 255 for sent packets and 128 for received ones. Currently IPv4 only.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default></default>
      </leafString>
      <leafBoolean name="Timestamps" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This option has no effect.</p>
          ]]></comment>
        <default>true</default>
        <attributeBoolean name="absolute" required="false" version="COMMERCIAL">
          <comment><![CDATA[
<p>This option has no effect</p>
            ]]></comment>
          <default>true</default>
        </attributeBoolean>
      </leafBoolean>
      <leafEnum name="Verbosity" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element enables standard groups of categories, based on a desired verbosity level. This is in addition to the categories enabled by the Tracing/EnableCategory setting. Recognised verbosity levels and the categories they map to are:</p>
<ul><li><i>none</i>: no DDSI2E log</li>
<li><i>severe</i>: error and fatal</li>
<li><i>warning</i>: <i>severe</i> + warning</li>
<li><i>info</i>: <i>warning</i> + info</li>
<li><i>config</i>: <i>info</i> + config</li>
<li><i>fine</i>: <i>config</i> + discovery</li>
<li><i>finer</i>: <i>fine</i> + traffic and timing</li>
<li><i>finest</i>: <i>finer</i> + trace</li></ul>
<p>The categorisation of tracing output is incomplete and hence most of the verbosity levels and categories are not of much use in the current release. This is an ongoing process and here we describe the target situation rather than the current situation. Currently, the most useful verbosity levels are <i>config</i>, <i>fine</i> and <i>finest</i>.</p>
          ]]></comment>
        <value>finest</value>
        <value>finer</value>
        <value>fine</value>
        <value>config</value>
        <value>info</value>
        <value>warning</value>
        <value>severe</value>
        <value>none</value>
        <default>none</default>
      </leafEnum>
    </element>
    <element name="Watchdog" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
<p>This element specifies the type of OS scheduling class will be used by the thread that announces its liveliness periodically.</p>
        ]]></comment>
      <element name="Scheduling" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
<p>This element specifies the type of OS scheduling class will be used by the thread that announces its liveliness periodically.</p>
          ]]></comment>
        <leafEnum name="Class" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<p>This element specifies the thread scheduling class that will be used by the watchdog thread. The user may need the appropriate privileges from the underlying operating system to be able to assign some of the privileged scheduling classes.</p>
            ]]></comment>
          <value>realtime</value>
          <value>timeshare</value>
          <value>default</value>
          <default>default</default>
        </leafEnum>
        <leafInt name="Priority" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
<p>This element specifies the thread priority. Only priorities that are supported by the underlying operating system can be assigned to this element. The user may need special privileges from the underlying operating system to be able to assign some of the privileged priorities.</p>
            ]]></comment>
          <default>0</default>
          <attributeEnum name="priority_kind" required="false" version="COMMERCIAL">
            <comment><![CDATA[
<p>This attribute specifies whether the specified Priority is a relative or absolute priority.</p>
              ]]></comment>
            <value>relative</value>
            <value>absolute</value>
            <default>relative</default>
          </attributeEnum>
        </leafInt>
      </element>
    </element>
  </element>
<!-- END DDSI2EService CONFIGURATION AUTOMAGICALLY GENERATED (see src/services/ddsi2e/extract-configuration-xml.awk) -->
<!-- DDSI2Service CONFIGURATION AUTOMAGICALLY GENERATED (see src/services/ddsi2e/extract-configuration-xml.awk) -->
  <element name="DDSI2Service" minOccurrences="0" maxOccurrences="0" version="COMMUNITY">
    <comment><![CDATA[
<p>The root element of a DDSI2 networking service configuration.</p>
      ]]></comment>
    <maxLength>0</maxLength>
    <attributeString name="name" required="true" version="COMMUNITY">
      <comment><![CDATA[
<p>This attribute identifies the configuration for the DDSI2 Service. Multiple DDSI2 service configurations can be specified in one single resource. The actual applicable configuration is determined by the value of the name attribute, which must match the specified under the element OpenSplice/Domain/Service[@name] in the Domain Service configuration.</p>
        ]]></comment>
      <maxLength>0</maxLength>
      <default>ddsi2</default>
    </attributeString>
    <element name="Compatibility" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
<p>The Compatibility elements allows specifying various settings related to compatability with standards and with other DDSI implementations.</p>
        ]]></comment>
      <leafInt name="AckNackNumbitsEmptySet" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element governs the representation of an acknowledgement message that does not also negatively-acknowledge some samples. If set to 0, the generated acknowledgements have an invalid form and will be reject by the strict and pedantic conformance modes, but several other implementation require this setting for smooth interoperation.</p>
<p>If set to 1, all acknowledgements sent by DDSI2 adhere the form of acknowledgement messages allowed by the standard, but this causes problems when interoperating with these other implementations. The strict and pedantic standards conformance modes always overrule an AckNackNumbitsEmptySet=0 to prevent the transmitting of invalid messages.</p>
          ]]></comment>
        <default>0</default>
      </leafInt>
      <leafBoolean name="ArrivalOfDataAssertsPpAndEpLiveliness" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>When set to true, arrival of a message from a peer asserts liveliness of that peer. When set to false, only SPDP and explicit lease renewals have this effect.</p>
          ]]></comment>
        <default>true</default>
      </leafBoolean>
      <leafBoolean name="AssumeRtiHasPmdEndpoints" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This option assumes ParticipantMessageData endpoints required by the liveliness protocol are present in RTI participants even when not properly advertised by the participant discovery protocol.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafBoolean name="ExplicitlyPublishQosSetToDefault" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element specifies whether QoS settings set to default values are explicitly published in the discovery protocol. Implementations are to use the default value for QoS settings not published, which allows a significant reduction of the amount of data that needs to be exchanged for the discovery protocol, but this requires all implementations to adhere to the default values specified by the specifications.</p>
<p>When interoperability is required with an implementation that does not follow the specifications in this regard, setting this option to true will help.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafBoolean name="ManySocketsMode" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This option specifies whether a network socket will be created for each domain participant on a host. The specification seems to assume that each participant has a unique address, and setting this option will ensure this to be the case. This is not the defeault.</p>
<p>Disabling it slightly improves performance and reduces network traffic somewhat. It also causes the set of port numbers needed by DDSI2 to become predictable, which may be useful for firewall and NAT configuration.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafBoolean name="RespondToRtiInitZeroAckWithInvalidHeartbeat" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element allows a closer mimicking of the behaviour of some other DDSI implementations, albeit at the cost of generating even more invalid messages. Setting it to true ensures a Heartbeat can be sent at any time when a remote node requests one, setting it to false delays it until a valid one can be sent.</p>
<p>The latter is fully compliant with the specification, and no adverse effects have been observed. It is the default.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafEnum name="StandardsConformance" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element sets the level of standards conformance of this instance of the DDSI2 Service. Stricter conformance typically means less interoperability with other implementations. Currently three modes are defined:</p>
<ul><li><i>pedantic</i>: very strictly conform to the specification, ultimately for compliancy testing, but currently of little value because it adheres even to what will most likely turn out to be editing errors in the DDSI standard. Arguably, as long as no errata have been published it is the current text that is in effect, and that is what pedantic currently does.</li>
<li><i>strict</i>: a slightly less strict view of the standard than does pedantic: it follows the established behaviour where the standard is obviously in error.</li>
<li><i>lax</i>: attempt to provide the smoothest possible interoperability, anticipating future revisions of elements in the standard in areas that other implementations do not adhere to, even though there is no good reason not to.</li></ul>
<p>The default setting is "lax".</p>
          ]]></comment>
        <value>lax</value>
        <value>strict</value>
        <value>pedantic</value>
        <default>lax</default>
      </leafEnum>
    </element>
    <element name="Discovery" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
<p>The Discovery element allows specifying various parameters related to the discovery of peers.</p>
        ]]></comment>
      <leafBoolean name="AdvertiseBuiltinTopicWriters" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element controls whether or not DDSI2 advertises writers for the built-in topics from its discovery for backwards compatibility with older Vortex OpenSplice versions.</p>
          ]]></comment>
        <default>true</default>
      </leafBoolean>
      <leafString name="DSGracePeriod" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This setting controls for how long endpoints discovered via a Cloud discovery service will survive after the discovery service disappeared, allowing reconnect without loss of data when the discovery service restarts (or another instance takes over).</p>
<p>Valid values are finite durations with an explicit unit or the keyword 'inf' for infinity. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>30 s</default>
      </leafString>
      <leafString name="DefaultMulticastAddress" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element specifies the default multicast address for all traffic other than participant discovery packets. It defaults to Discovery/SPDPMulticastAddress.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>auto</default>
      </leafString>
      <leafString name="DomainId" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element allows overriding of the DDS Domain Id that is used for DDSI2.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>default</default>
      </leafString>
      <leafBoolean name="GenerateBuiltinTopics" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element controls whether or not DDSI2 generates built-in topics from its discovery. When disabled, it relies on the durability service.</p>
          ]]></comment>
        <default>true</default>
      </leafBoolean>
      <leafString name="LocalDiscoveryPartition" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element controls which partition is monitored by DDSI2 for built-in topics describing entities the it mirrors in DDSI.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>__BUILT-IN PARTITION__</default>
      </leafString>
      <leafInt name="MaxAutoParticipantIndex" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element specifies the maximum DDSI participant index selected by this instance of the DDSI2 service if the Discovery/ParticipantIndex is "auto".</p>
          ]]></comment>
        <default>9</default>
      </leafInt>
      <leafString name="ParticipantIndex" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element specifies the DDSI participant index used by this instance of the DDSI2 service for discovery purposes. Only one such participant id is used, independent of the number of actual DomainParticipants on the node. It is either:</p>
<ul><li><i>auto</i>: which will attempt to automatically determine an available participant index (see also Discovery/MaxAutoParticipantIndex), or</li>
<li>a non-negative integer less than 120, or</li>
<li><i>none</i>:, which causes it to use arbitrary port numbers for unicast sockets which entirely removes the constraints on the participant index but makes unicast discovery impossible.</li></ul>
<p>The default is <i>auto</i>. The participant index is part of the port number calculation and if predictable port numbers are needed and fixing the participant index has no adverse effects, it is recommended that the second be option be used.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>auto</default>
      </leafString>
      <element name="Peers" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element statically configures addresses for discovery.</p>
<p>Valid values are finite durations with an explicit unit or the keyword 'inf' for infinity. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <element name="Group" minOccurrences="0" maxOccurrences="0" version="COMMUNITY">
          <comment><![CDATA[
<p>This element statically configures a fault tolerant group of addresses for discovery. Each member of the group is tried in sequence until one succeeds.</p>
            ]]></comment>
          <element name="Peer" minOccurrences="0" maxOccurrences="0" version="COMMUNITY">
            <comment><![CDATA[
<p>This element statically configures an addresses for discovery.</p>
              ]]></comment>
            <attributeString name="Address" required="true" version="COMMUNITY">
              <comment><![CDATA[
<p>This element specifies an IP address to which discovery packets must be sent, in addition to the default multicast address (see also General/AllowMulticast). Both a hostnames and a numerical IP address is accepted; the hostname or IP address may be suffixed with :PORT to explicitly set the port to which it must be sent. Multiple Peers may be specified.</p>
                ]]></comment>
              <maxLength>0</maxLength>
              <default></default>
            </attributeString>
          </element>
        </element>
        <element name="Peer" minOccurrences="0" maxOccurrences="0" version="COMMUNITY">
          <comment><![CDATA[
<p>This element statically configures an addresses for discovery.</p>
            ]]></comment>
          <attributeString name="Address" required="true" version="COMMUNITY">
            <comment><![CDATA[
<p>This element specifies an IP address to which discovery packets must be sent, in addition to the default multicast address (see also General/AllowMulticast). Both a hostnames and a numerical IP address is accepted; the hostname or IP address may be suffixed with :PORT to explicitly set the port to which it must be sent. Multiple Peers may be specified.</p>
              ]]></comment>
            <maxLength>0</maxLength>
            <default></default>
          </attributeString>
        </element>
      </element>
      <element name="Ports" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>The Ports element allows specifying various parameters related to the port numbers used for discovery. These all have default values specified by the DDSI 2.1 (and 2.2) specification and rarely need to be changed.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <leafInt name="Base" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
<p>This element specifies the base port number (refer to the DDSI 2.1 or 2.2 specification, section 9.6.1, constant PB).</p>
            ]]></comment>
          <minimum>1</minimum>
          <maximum>65535</maximum>
          <default>7400</default>
        </leafInt>
        <leafInt name="DomainGain" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
<p>This element specifies the domain gain, relating domain ids to sets of port numbers (refer to the DDSI 2.1 or 2.2 specification, section 9.6.1, constant DG).</p>
            ]]></comment>
          <default>250</default>
        </leafInt>
        <leafInt name="MulticastDataOffset" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
<p>This element specifies the port number for multicast meta traffic (refer to the DDSI 2.1 or 2.2 specification, section 9.6.1, constant d2).</p>
            ]]></comment>
          <default>1</default>
        </leafInt>
        <leafInt name="MulticastMetaOffset" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
<p>This element specifies the port number for multicast meta traffic (refer to the DDSI 2.1 or 2.2 specification, section 9.6.1, constant d0).</p>
            ]]></comment>
          <default>0</default>
        </leafInt>
        <leafInt name="ParticipantGain" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
<p>This element specifies the participant gain, relating p0, articipant index to sets of port numbers (refer to the DDSI 2.1 or 2.2 specification, section 9.6.1, constant PG).</p>
            ]]></comment>
          <default>2</default>
        </leafInt>
        <leafInt name="UnicastDataOffset" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
<p>This element specifies the port number for unicast meta traffic (refer to the DDSI 2.1 or 2.2 specification, section 9.6.1, constant d3).</p>
            ]]></comment>
          <default>11</default>
        </leafInt>
        <leafInt name="UnicastMetaOffset" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
<p>This element specifies the port number for unicast meta traffic (refer to the DDSI 2.1 or 2.2 specification, section 9.6.1, constant d1).</p>
            ]]></comment>
          <default>10</default>
        </leafInt>
      </element>
      <leafString name="SPDPInterval" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element specifies the interval between spontaneous transmissions of participant discovery packets.</p>
<p>The unit must be specified explicitly. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <minimum>0</minimum>
        <maximum>1hr</maximum>
        <maxLength>0</maxLength>
        <default>30 s</default>
      </leafString>
      <leafString name="SPDPMulticastAddress" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element specifies the multicast address that is used as the destination for the participant discovery packets. In IPv4 mode the default is the (standardised) 239.255.0.1, in IPv6 mode it becomes ff02::ffff:239.255.0.1, which is a non-standardised link-local multicast address.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>239.255.0.1</default>
      </leafString>
    </element>
    <element name="General" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
<p>The General element specifies overall DDSI2 service settings.</p>
        ]]></comment>
      <leafString name="AllowMulticast" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element controls whether DDSI2 uses multicasts for data traffic.</p>
<p>It is a comma-separated list of some of the following keywords: "spdp", "asm", "ssm", or either of "false" or "true".</p>
<ul>
<li><i>spdp</i>: enables the use of ASM (any-source multicast) for participant discovery</li>
<li><i>asm</i>: enables the use of ASM for all traffic (including SPDP)</li>
<li><i>ssm</i>: enables the use of SSM (source-specific multicast) for all non-SPDP traffic (if supported)</li>
</ul>
<p>When set to "false" all multicasting is disabled. The default, "true" enables full use of multicasts. Listening for multicasts can be controlled by General/MulticastRecvNetworkInterfaceAddresses.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>true</default>
      </leafString>
      <leafBoolean name="CoexistWithNativeNetworking" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element specifies whether the DDSI2 service operates in conjunction with the Vortex OpenSplice RT Networking service. When "false", the DDSI2 service will take care of all communications, including those between Vortex OpenSplice nodes; when "true", the DDSI2 service only communicates with DDS implementations other than Vortex OpenSplice. In this case the RT Networking service should be configured as well.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafBoolean name="DontRoute" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element allows setting the SO_DONTROUTE option for outgoing packets, to bypass the local routing tables. This is generally useful only when the routing tables cannot be trusted, which is highly unusual.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafBoolean name="EnableMulticastLoopback" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element specifies whether DDSI2 allows IP multicast packets to be visible to all DDSI participants in the same node, including itself. It must be "true" for intra-node multicast communications, but if a node runs only a single DDSI2 service and does not host any other DDSI-capable programs, it should be set to "false" for improved performance.</p>
          ]]></comment>
        <default>true</default>
      </leafBoolean>
      <leafString name="ExternalNetworkAddress" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element allows explicitly overruling the network address DDSI2 advertises in the discovery protocol, which by default is the address of the preferred network interface (General/NetworkInterfaceAddress), to allow DDSI2 to communicate across a Network Address Translation (NAT) device.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>auto</default>
      </leafString>
      <leafString name="ExternalNetworkMask" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element specifies the network mask of the external network address. This element is relevant only when an external network address (General/ExternalNetworkAddress) is explicitly configured. In this case locators received via the discovery protocol that are within the same external subnet (as defined by this mask) will be translated to an internal address by replacing the network portion of the external address with the corresponding portion of the preferred network interface address. This option is IPv4-only.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>0.0.0.0</default>
      </leafString>
      <leafString name="FragmentSize" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element specifies the size of DDSI sample fragments generated by DDSI2. Samples larger than FragmentSize are fragmented into fragments of FragmentSize bytes each, except the last one, which may be smaller. The DDSI spec mandates a minimum fragment size of 1025 bytes, but DDSI2 will do whatever size is requested, accepting fragments of which the size is at least the minimum of 1025 and FragmentSize.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>1280 B</default>
      </leafString>
      <leafString name="MaxMessageSize" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element specifies the maximum size of the UDP payload that DDSI2 will generate. DDSI2 will try to maintain this limit within the bounds of the DDSI specification, which means that in some cases (especially for very low values of MaxMessageSize) larger payloads may sporadically be observed (currently up to 1192 B).</p>
<p>On some networks it may be necessary to set this item to keep the packetsize below the MTU to prevent IP fragmentation. In those cases, it is generally advisable to also consider reducing Internal/FragmentSize.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>4096 B</default>
      </leafString>
      <leafString name="MulticastRecvNetworkInterfaceAddresses" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element specifies on which network interfaces DDSI2 listens to multicasts. The following options are available:</p>
<ul>
<li><i>all</i>: listen for multicasts on all multicast-capable interfaces; or</li>
<li><i>any</i>: listen for multicasts on the operating system default interface; or</li>
<li><i>preferred</i>: listen for multicasts on the preferred interface (General/NetworkInterfaceAddress); or</li>
<li><i>none</i>: does not listen for multicasts on any interface; or</li>
<li>a comma-separated list of network addresses: configures DDSI2 to listen for multicasts on all of the listed addresses.</li>
</ul>
<p>If DDSI2 is in IPv6 mode and the address of the preferred network interface is a link-local address, "all" is treated as a synonym for "preferred" and a comma-separated list is treated as "preferred" if it contains the preferred interface and as "none" if not.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>preferred</default>
      </leafString>
      <leafInt name="MulticastTimeToLive" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element specifies the time-to-live setting for outgoing multicast packets.</p>
          ]]></comment>
        <minimum>0</minimum>
        <maximum>255</maximum>
        <default>32</default>
      </leafInt>
      <leafString name="NetworkInterfaceAddress" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element specifies the preferred network interface for use by DDSI2. The preferred network interface determines the IP address that DDSI2 advertises in the discovery protocol (but see also General/ExternalNetworkAddress), and is also the only interface over which multicasts are transmitted. The interface can be identified by its IP address, network interface name or network portion of the address. If the value "auto" is entered here, DDSI2 will select what it considers the most suitable interface.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>auto</default>
      </leafString>
      <leafBoolean name="StartupModeCoversTransient" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element configures whether startup-mode should also cover transient and persistent data, for configurations where the durability service does not take care of it. Configurations without defined merge policies best leave this enabled.</p>
          ]]></comment>
        <default>true</default>
      </leafBoolean>
      <leafString name="StartupModeDuration" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element specifies how long the DDSI2 remains in its "startup" mode. While in "startup" mode all volatile reliable data published on the local node is retained as-if it were transient-local data, allowing existing readers on remote nodes to obtain the data even though discovering them takes some time. Best-effort data by definition need not arrive, and transient and persistent data are covered by the durability service.</p>
<p>Once the system is stable, DDSI2 keeps track of the existence of remote readers whether or not matching writers exist locally, avoiding this discovery delay and ensuring this is merely a node startup issue.</p>
<p>Setting General/StartupModeDuration to 0s will disable it.</p>
<p>The unit must be specified explicitly. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <minimum>0</minimum>
        <maximum>60000</maximum>
        <maxLength>0</maxLength>
        <default>2 s</default>
      </leafString>
      <leafBoolean name="UseIPv6" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element can be used to DDSI2 use IPv6 instead of IPv4. This is currently an either/or switch.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
    </element>
    <element name="Internal" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
<p>The Internal elements deal with a variety of settings that evolving and that are not necessarily fully supported. For the vast majority of the Internal settings, the functionality per-se is supported, but the right to change the way the options control the functionality is reserved. This includes renaming or moving options.</p>
        ]]></comment>
      <leafInt name="AccelerateRexmitBlockSize" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>Proxy readers that are assumed to sill be retrieving historical data get this many samples retransmitted when they NACK something, even if some of these samples have sequence numbers outside the set covered by the NACK.</p>
          ]]></comment>
        <default>0</default>
      </leafInt>
      <leafBoolean name="AggressiveKeepLastWhc" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls whether to drop a reliable sample from a DDSI2 WHC before all readers have acknowledged it as soon as a later sample becomes available. It only affects DCPS data writers with a history QoS setting of KEEP_LAST with depth 1. The default setting, <i>false</i>, mimics the behaviour of the Vortex OpenSplice RT networking and is necessary to make the behaviour of wait_for_acknowledgements() consistent across the networking services.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafString name="AssumeMulticastCapable" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls which network interfaces are assumed to be capable of multicasting even when the interface flags returned by the operating system state it is not (this provides a workaround for some platforms). It is a comma-separated lists of patterns (with ? and * wildcards) against which the interface names are matched.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default></default>
      </leafString>
      <leafString name="AutoReschedNackDelay" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This setting controls the interval with which a reader will continue NACK'ing missing samples in the absence of a response from the writer, as a protection mechanism against writers incorrectly stopping the sending of HEARTBEAT messages.</p>
<p>Valid values are finite durations with an explicit unit or the keyword 'inf' for infinity. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>1 s</default>
      </leafString>
      <leafEnum name="BuiltinEndpointSet" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls which participants will have which built-in endpoints for the discovery and liveliness protocols. Valid values are:</p>
<ul><li><i>full</i>: all participants have all endpoints;</li>
<li><i>writers</i>: all participants have the writers, but just one has the readers;</li>
<li><i>minimal</i>: only one participant has built-in endpoints.</li></ul>
<p>The default is <i>writers</i>, as this is thought to be compliant and reasonably efficient. <i>Minimal</i> may or may not be compliant but is most efficient, and <i>full</i> is inefficient but certain to be compliant. See also Internal/ConservativeBuiltinReaderStartup.</p>
          ]]></comment>
        <value>full</value>
        <value>writers</value>
        <value>minimal</value>
        <default>writers</default>
      </leafEnum>
      <leafBoolean name="ConservativeBuiltinReaderStartup" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This element forces all DDSI2 built-in discovery-related readers to request all historical data, instead of just one for each "topic". There is no indication that any of the current DDSI implementations requires changing of this setting, but it is conceivable that an implementation might track which participants have been informed of the existence of endpoints and which have not been, refusing communication with those that have "can't" know.</p>
<p>Should it be necessary to hide DDSI2's shared discovery behaviour, set this to <i>true</i> and Internal/BuiltinEndpointSet to <i>full</i>.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <element name="ControlTopic" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>The ControlTopic element allows configured whether DDSI2 provides a special control interface via a predefined topic or not.<p>
          ]]></comment>
        <attributeBoolean name="enable" required="false" version="COMMUNITY">
          <comment><![CDATA[
<b>Internal</b> <p>This attribute controls whether the DDSI2 control topic is defined and acted upon by DDSI2</p>
            ]]></comment>
          <default>false</default>
        </attributeBoolean>
        <leafBoolean name="Deaf" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
<b>Internal</b> <p>This element controls whether DDSI2 defaults to deaf mode or to normal mode. This controls both the initial behaviour and what behaviour it auto-reverts to.</p>
            ]]></comment>
          <default>false</default>
        </leafBoolean>
        <leafBoolean name="Mute" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
<b>Internal</b> <p>This element controls whether DDSI2 defaults to mute mode or to normal mode. This controls both the initial behaviour and what behaviour it auto-reverts to.</p>
            ]]></comment>
          <default>false</default>
        </leafBoolean>
      </element>
      <leafInt name="DDSI2DirectMaxThreads" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This element sets the maximum number of extra threads for an experimental, undocumented and unsupported direct mode.</p>
          ]]></comment>
        <default>1</default>
      </leafInt>
      <leafInt name="DefragReliableMaxSamples" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This element sets the maximum number of samples that can be defragmented simultaneously for a reliable writer. This has to be large enough to handle retransmissions of historical data in addition to new samples.</p>
          ]]></comment>
        <default>16</default>
      </leafInt>
      <leafInt name="DefragUnreliableMaxSamples" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This element sets the maximum number of samples that can be defragmented simultaneously for a best-effort writers.</p>
          ]]></comment>
        <default>4</default>
      </leafInt>
      <leafInt name="DeliveryQueueMaxSamples" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls the Maximum size of a delivery queue, expressed in samples. Once a delivery queue is full, incoming samples destined for that queue are dropped until space becomes available again.</p>
          ]]></comment>
        <default>256</default>
      </leafInt>
      <leafBoolean name="ForwardAllMessages" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>Forward all messages from a writer, rather than trying to forward each sample only once. The default of trying to forward each sample only once filters out duplicates for writers in multiple partitions under nearly all circumstances, but may still publish the odd duplicate. Note: the current implementation also can lose in contrived test cases, that publish more than 2**32 samples using a single data writer in conjunction with carefully controlled management of the writer history via cooperating local readers.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafEnum name="ForwardRemoteData" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls whether DDSI2 forwards data received from other network services in the domain.</p>
          ]]></comment>
        <value>false</value>
        <value>true</value>
        <value>default</value>
        <default>default</default>
      </leafEnum>
      <leafBoolean name="GenerateKeyhash" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>When true, include keyhashes in outgoing data for topics with keys.</p>
          ]]></comment>
        <default>true</default>
      </leafBoolean>
      <leafString name="HeartbeatInterval" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This element sets the base interval for the asynchronous, periodic writer heartbeats when unacknowledged data is present in its writer history cache. The actual interval is dynamically adjusted, the attributes of this element allow further configuration.</p>
<p>Valid values are finite durations with an explicit unit or the keyword 'inf' for infinity. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>100 ms</default>
        <attributeString name="max" required="false" version="COMMUNITY">
          <comment><![CDATA[
<b>Internal</b> <p>This attribute sets the maximum interval for periodic heartbeats.</p>
<p>Valid values are finite durations with an explicit unit or the keyword 'inf' for infinity. Recognised units: ns, us, ms, s, min, hr, day.</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default>8 s</default>
        </attributeString>
        <attributeString name="min" required="false" version="COMMUNITY">
          <comment><![CDATA[
<b>Internal</b> <p>This attribute sets the minimum interval that must have passed since the most recent heartbeat from a writer, before another asynchronous (not directly related to writing) will be sent.</p>
<p>Valid values are finite durations with an explicit unit or the keyword 'inf' for infinity. Recognised units: ns, us, ms, s, min, hr, day.</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default>5 ms</default>
        </attributeString>
        <attributeString name="minsched" required="false" version="COMMUNITY">
          <comment><![CDATA[
<b>Internal</b> <p>This attribute sets the minimum interval for periodic heartbeats. Other events may still cause heartbeats to go out.</p>
<p>Valid values are finite durations with an explicit unit or the keyword 'inf' for infinity. Recognised units: ns, us, ms, s, min, hr, day.</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default>20 ms</default>
        </attributeString>
      </leafString>
      <leafBoolean name="LateAckMode" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>Ack a sample only when it has been delivered, instead of when committed to delivering it.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafString name="LeaseDuration" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This setting controls the default participant lease duration. <p>
<p>The unit must be specified explicitly. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <minimum>0</minimum>
        <maximum>1hr</maximum>
        <maxLength>0</maxLength>
        <default>0 s</default>
      </leafString>
      <leafBoolean name="LegacyFragmentation" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This option enables a backwards-compatible, non-compliant setting and interpretation of the control flags in fragmented data messages. To be enabled <i>only</i> when requiring interoperability between compliant and non-compliant versions of DDSI2 for large messages.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafBoolean name="LogStackTraces" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls whether or not to write stack traces to the DDSI2 trace when a thread fails to make progress (on select platforms only).</p>
          ]]></comment>
        <default>true</default>
      </leafBoolean>
      <leafInt name="MaxParticipants" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This elements configures the maximum number of DCPS domain participants this DDSI2 instance is willing to service. 0 is unlimited.</p>
          ]]></comment>
        <default>0</default>
      </leafInt>
      <leafString name="MaxQueuedRexmitBytes" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This setting limits the maximum number of bytes queued for retransmission. The default value of 0 is unlimited unless an AuxiliaryBandwidthLimit has been set, in which case it becomes NackDelay * AuxiliaryBandwidthLimit. It must be large enough to contain the largest sample that may need to be retransmitted.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>50 kB</default>
      </leafString>
      <leafInt name="MaxQueuedRexmitMessages" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This settings limits the maximum number of samples queued for retransmission.</p>
          ]]></comment>
        <default>200</default>
      </leafInt>
      <leafString name="MaxSampleSize" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This setting controls the maximum (CDR) serialised size of samples that DDSI2 will forward in either direction. Samples larger than this are discarded with a warning.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>2147483647 B</default>
      </leafString>
      <leafBoolean name="MeasureHbToAckLatency" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This element enables heartbeat-to-ack latency among DDSI2 services by prepending timestamps to Heartbeat and AckNack messages and calculating round trip times. This is non-standard behaviour. The measured latencies are quite noisy and are currently not used anywhere.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafString name="MinimumSocketReceiveBufferSize" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This setting controls the minimum size of socket receive buffers. The operating system provides some size receive buffer upon creation of the socket, this option can be used to increase the size of the buffer beyond that initially provided by the operating system. If the buffer size cannot be increased to the specified size, an error is reported.</p>
<p>The default setting is the word "default", which means DDSI2 will attempt to increase the buffer size to 1MB, but will silently accept a smaller buffer should that attempt fail.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>default</default>
      </leafString>
      <leafString name="MinimumSocketSendBufferSize" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This setting controls the minimum size of socket send buffers. This setting can only increase the size of the send buffer, if the operating system by default creates a larger buffer, it is left unchanged.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>64 KiB</default>
      </leafString>
      <leafEnum name="MirrorRemoteEntities" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls whether DDSI2 mirrors all entities in the domain in DDSI or only local ones. Default is to discover remote ones iff General/LocalDiscoveryPartition is not the built-in partition.</p>
          ]]></comment>
        <value>false</value>
        <value>true</value>
        <value>default</value>
        <default>default</default>
      </leafEnum>
      <leafInt name="MonitorPort" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This element allows configuring a service that dumps a text description of part the internal state to TCP clients. By default (-1), this is disabled; specifying 0 means a kernel-allocated port is used; a positive number is used as the TCP port number.</p>
          ]]></comment>
        <default>-1</default>
      </leafInt>
      <leafString name="NackDelay" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This setting controls the delay between receipt of a HEARTBEAT indicating missing samples and a NACK (ignored when the HEARTBEAT requires an answer). However, no NACK is sent if a NACK had been scheduled already for a response earlier than the delay requests: then that NACK will incorporate the latest information.</p>
<p>The unit must be specified explicitly. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <minimum>0</minimum>
        <maximum>1hr</maximum>
        <maxLength>0</maxLength>
        <default>10 ms</default>
      </leafString>
      <leafString name="PreEmptiveAckDelay" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This setting controls the delay between the discovering a remote writer and sending a pre-emptive AckNack to discover the range of data available.</p>
<p>The unit must be specified explicitly. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <minimum>0</minimum>
        <maximum>1hr</maximum>
        <maxLength>0</maxLength>
        <default>10 ms</default>
      </leafString>
      <leafInt name="PrimaryReorderMaxSamples" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This element sets the maximum size in samples of a primary re-order administration. Each proxy writer has one primary re-order administration to buffer the packet flow in case some packets arrive out of order. Old samples are forwarded to secondary re-order administrations associated with readers in need of historical data.</p>
          ]]></comment>
        <default>64</default>
      </leafInt>
      <leafBoolean name="PrioritizeRetransmit" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls whether retransmits are prioritized over new data, speeding up recovery.</p>
          ]]></comment>
        <default>true</default>
      </leafBoolean>
      <leafString name="RediscoveryBlacklistDuration" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls for how long a remote participant that was previously deleted will remain on a blacklist to prevent rediscovery, giving the software on a node time to perform any cleanup actions it needs to do. To some extent this delay is required internally by DDSI2, but in the default configuration with the 'enforce' attribute set to false, DDSI2 will reallow rediscovery as soon as it has cleared its internal administration. Setting it to too small a value may result in the entry being pruned from the blacklist before DDSI2 is ready, it is therefore recommended to set it to at least several seconds.</p>
<p>Valid values are finite durations with an explicit unit or the keyword 'inf' for infinity. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>10s</default>
        <attributeBoolean name="enforce" required="false" version="COMMUNITY">
          <comment><![CDATA[
<b>Internal</b> <p>This attribute controls whether the configured time during which recently deleted participants will not be rediscovered (i.e., "black listed") is enforced and following complete removal of the participant in DDSI2, or whether it can be rediscovered earlier provided all traces of that participant have been removed already.</p>
            ]]></comment>
          <default>false</default>
        </attributeBoolean>
      </leafString>
      <leafString name="ResponsivenessTimeout" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls for how long an unresponsive reader can block the transmit thread by failing to acknowledge data when a writer's DDSI2 write cache is full. If after this time the writer's cache has not shrunk to below the low-water mark, the reader is considered unresponsive and degraded to unreliable. It will be restored to reliable service once it resumes acknowledging samples.</p>
<p>Valid values are finite durations with an explicit unit or the keyword 'inf' for infinity. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>inf</default>
      </leafString>
      <leafEnum name="RetransmitMerging" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This elements controls the addressing and timing of retransmits. Possible values are:</p>
<ul><li><i>never</i>: retransmit only to the NACK-ing reader;</li>
<li><i>adaptive</i>: attempt to combine retransmits needed for reliability, but send historical (transient-local) data to the requesting reader only;</li>
<li><i>always</i>: do not distinguish between different causes, always try to merge.</li></ul>
<p>The default is <i>adaptive</i>. See also Internal/RetransmitMergingPeriod.</p>
          ]]></comment>
        <value>never</value>
        <value>adaptive</value>
        <value>always</value>
        <default>adaptive</default>
      </leafEnum>
      <leafString name="RetransmitMergingPeriod" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This setting determines the size of the time window in which a NACK of some sample is ignored because a retransmit of that sample has been multicasted too recently. This setting has no effect on unicasted retransmits.</p>
<p>See also Internal/RetransmitMerging.</p>
<p>The unit must be specified explicitly. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <minimum>0</minimum>
        <maximum>1s</maximum>
        <maxLength>0</maxLength>
        <default>5 ms</default>
      </leafString>
      <leafBoolean name="RetryOnRejectBestEffort" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>Whether or not to locally retry pushing a received best-effort sample into the reader caches when resource limits are reached.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafString name="RetryOnRejectDuration" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>How long to keep locally retrying pushing a received sample into the reader caches when resource limits are reached. Default is dependent on Internal/LateAckMode: if the latter is false, it is 80% of Internal/ResponsivenessTimeout, otherwise it is 0.</p>
<p>Valid values are finite durations with an explicit unit or the keyword 'inf' for infinity. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>default</default>
      </leafString>
      <leafString name="SPDPResponseMaxDelay" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>Maximum pseudo-random delay in milliseconds between discovering a remote participant and responding to it.</p>
<p>The unit must be specified explicitly. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <minimum>0</minimum>
        <maximum>1s</maximum>
        <maxLength>0</maxLength>
        <default>0 ms</default>
      </leafString>
      <leafString name="ScheduleTimeRounding" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This setting allows the timing of scheduled events to be rounded up so that more events can be handled in a single cycle of the event queue. The default is 0 and causes no rounding at all, i.e. are scheduled exactly, whereas a value of 10ms would mean that events are rounded up to the nearest 10 milliseconds.</p>
<p>The unit must be specified explicitly. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <minimum>0</minimum>
        <maximum>1hr</maximum>
        <maxLength>0</maxLength>
        <default>0 ms</default>
      </leafString>
      <leafInt name="SecondaryReorderMaxSamples" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This element sets the maximum size in samples of a secondary re-order administration. The secondary re-order administration is per reader in need of historical data.</p>
          ]]></comment>
        <default>16</default>
      </leafInt>
      <leafBoolean name="SquashParticipants" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls whether DDSI2 advertises all the domain participants it serves in DDSI (when set to <i>false</i>), or rather only one domain participant (the one corresponding to the DDSI2 process; when set to <i>true</i>). In the latter case DDSI2 becomes the virtual owner of all readers and writers of all domain participants, dramatically reducing discovery traffic (a similar effect can be obtained by setting Internal/BuiltinEndpointSet to "minimal" but with less loss of information).</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafBoolean name="SuppressSPDPMulticast" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>The element controls whether the mandatory multicasting of the participant discovery packets occurs. Completely disabling multicasting requires this element be set to <i>true</i>, and generally requires explicitly listing peers to ping for unicast discovery.</p>
<p>See also General/AllowMulticast.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafString name="SynchronousDeliveryLatencyBound" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls whether samples sent by a writer with QoS settings transport_priority >= SynchronousDeliveryPriorityThreshold and a latency_budget at most this element's value will be delivered synchronously from the "recv" thread, all others will be delivered asynchronously through delivery queues. This reduces latency at the expense of aggregate bandwidth.</p>
<p>Valid values are finite durations with an explicit unit or the keyword 'inf' for infinity. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>inf</default>
      </leafString>
      <leafInt name="SynchronousDeliveryPriorityThreshold" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls whether samples sent by a writer with QoS settings latency_budget <= SynchronousDeliveryLatencyBound and transport_priority greater than or equal to this element's value will be delivered synchronously from the "recv" thread, all others will be delivered asynchronously through delivery queues. This reduces latency at the expense of aggregate bandwidth.</p>
          ]]></comment>
        <default>0</default>
      </leafInt>
      <element name="Test" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>Testing options.</p>
          ]]></comment>
        <leafInt name="XmitLossiness" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
<b>Internal</b> <p>This element controls the fraction of outgoing packets to drop, specified as samples per thousand.</p>
            ]]></comment>
          <default>0</default>
        </leafInt>
      </element>
      <leafBoolean name="UnicastResponseToSPDPMessages" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This element controls whether the response to a newly discovered participant is sent as a unicasted SPDP packet, instead of rescheduling the periodic multicasted one. There is no known benefit to setting this to <i>false</i>.</p>
          ]]></comment>
        <default>true</default>
      </leafBoolean>
      <leafInt name="UseMulticastIfMreqn" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>Do not use.</p>
          ]]></comment>
        <default>0</default>
      </leafInt>
      <element name="Watermarks" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>Watermarks for flow-control.</p>
          ]]></comment>
        <leafBoolean name="WhcAdaptive" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
<b>Internal</b> <p>This element controls whether DDSI2 will adapt the high-water mark to current traffic conditions, based on retransmit requests and transmit pressure.</p>
            ]]></comment>
          <default>true</default>
        </leafBoolean>
        <leafString name="WhcHigh" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
<b>Internal</b> <p>This element sets the maximum allowed high-water mark for the DDSI2 WHCs, expressed in bytes. A writer is suspended when the WHC reaches this size.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default>100 kB</default>
        </leafString>
        <leafString name="WhcHighInit" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
<b>Internal</b> <p>This element sets the initial level of the high-water mark for the DDSI2 WHCs, expressed in bytes.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default>30 kB</default>
        </leafString>
        <leafString name="WhcLow" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
<b>Internal</b> <p>This element sets the low-water mark for the DDSI2 WHCs, expressed in bytes. A suspended writer resumes transmitting when its DDSI2 WHC shrinks to this size.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default>1 kB</default>
        </leafString>
      </element>
      <leafString name="WriterLingerDuration" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<b>Internal</b> <p>This setting controls the maximum duration for which actual deletion of a reliable writer with unacknowledged data in its history will be postponed to provide proper reliable transmission.<p>
<p>The unit must be specified explicitly. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <minimum>0</minimum>
        <maximum>1hr</maximum>
        <maxLength>0</maxLength>
        <default>1 s</default>
      </leafString>
    </element>
    <element name="SSL" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
<p>The SSL element allows specifying various parameters related to using SSL/TLS for DDSI over TCP.</p>
        ]]></comment>
      <leafBoolean name="CertificateVerification" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>If disabled this allows SSL connections to occur even if an X509 certificate fails verification.</p>
          ]]></comment>
        <default>true</default>
      </leafBoolean>
      <leafString name="Ciphers" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>The set of ciphers used by SSL/TLS</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH</default>
      </leafString>
      <leafBoolean name="Enable" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This enables SSL/TLS for TCP.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafString name="EntropyFile" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>The SSL/TLS random entropy file name.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default></default>
      </leafString>
      <leafString name="KeyPassphrase" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>The SSL/TLS key pass phrase for encrypted keys.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>secret</default>
      </leafString>
      <leafString name="KeystoreFile" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>The SSL/TLS key and certificate store file name. The keystore must be in PEM format.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>keystore</default>
      </leafString>
      <leafBoolean name="SelfSignedCertificates" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This enables the use of self signed X509 certificates.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafBoolean name="VerifyClient" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This enables an SSL server checking the X509 certificate of a connecting client.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
    </element>
    <element name="Sizing" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
<p>The Sizing element specifies a variety of configuration settings dealing with expected system sizes, buffer sizes, &c.</p>
        ]]></comment>
      <leafInt name="EndpointsInSystem" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This endpoint specifies the expected maximum number of endpoints in the network. Underestimating this number will have a significant performance impact, but will not affect correctness; signficantly overestimating it will cause more memory to be used than necessary.</p>
          ]]></comment>
        <default>20000</default>
      </leafInt>
      <leafInt name="LocalEndpoints" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element specifies the expected maximum number of endpoints local to one DDSI2 service. Underestimating this number will have a significant performance impact, but will not affect correctness; signficantly overestimating it will cause more memory to be used than necessary.</p>
          ]]></comment>
        <default>1000</default>
      </leafInt>
      <leafInt name="NetworkQueueSize" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element specifies the maximum number of samples in the network queue. Write/dispose operations add samples to this queue, the DDSI2 service drains it. Larger values allow large bursts of writes to occur without forcing synchronization between the application and the DDSI2 service, but do introduce the potential for longer latencies and increase the maximum amount of memory potentially occupied by messages in the queue.</p>
          ]]></comment>
        <default>1000</default>
      </leafInt>
      <leafString name="ReceiveBufferChunkSize" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element specifies the size of one allocation unit in the receive buffer. Must be greater than the maximum packet size by a modest amount (too large packets are dropped). Each allocation is shrunk immediately after processing a message, or freed straightaway.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>128 KiB</default>
      </leafString>
      <element name="Watermarks" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
  { LEAF ("ReceiveBufferSize"), 1, "1 MiB", ABSOFF (rbuf_size), 0, uf_memsize, 0, pf_memsize,    "<p>This element sets the size of a single receive buffer. Many receive buffers may be needed. Their size must be greater than ReceiveBufferChunkSize by a modest amount.</p>
          ]]></comment>
        <leafBoolean name="WhcAdaptive" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
<p>This element controls whether DDSI2 will adapt the high-water mark to current traffic conditions, based on retransmit requests and transmit pressure.</p>
            ]]></comment>
          <default>true</default>
        </leafBoolean>
        <leafString name="WhcHigh" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
<p>This element sets the maximum allowed high-water mark for the DDSI2 WHCs, expressed in bytes. A writer is suspended when the WHC reaches this size.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default>100 kB</default>
        </leafString>
        <leafString name="WhcHighInit" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
<p>This element sets the initial level of the high-water mark for the DDSI2 WHCs, expressed in bytes.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default>30 kB</default>
        </leafString>
        <leafString name="WhcLow" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
<p>This element sets the low-water mark for the DDSI2 WHCs, expressed in bytes. A suspended writer resumes transmitting when its DDSI2 WHC shrinks to this size.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default>1 kB</default>
        </leafString>
      </element>
    </element>
    <element name="TCP" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
<p>The TCP element allows specifying various parameters related to running DDSI over TCP.</p>
        ]]></comment>
      <leafBoolean name="Enable" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element enables the optional TCP transport.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafBoolean name="NoDelay" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element enables the TCP_NODELAY socket option, preventing multiple DDSI messages being sent in the same TCP request. Setting this option typically optimises latency over throughput.</p>
          ]]></comment>
        <default>true</default>
      </leafBoolean>
      <leafInt name="Port" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element specifies the TCP port number on which DDSI2 accepts connections. If the port is set it is used in entity locators, published with DDSI discovery. Dynamically allocated if zero. Disabled if -1 or not configured. If disabled other DDSI services will not be able to establish connections with the service, the service can only communicate by establishing connections to other services.</p>
          ]]></comment>
        <minimum>-1</minimum>
        <maximum>65535</maximum>
        <default>-1</default>
      </leafInt>
      <leafString name="ReadTimeout" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element specifies the timeout for blocking TCP read operations. If this timeout expires then the connection is closed.</p>
<p>The unit must be specified explicitly. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <minimum>0</minimum>
        <maximum>1hr</maximum>
        <maxLength>0</maxLength>
        <default>2 s</default>
      </leafString>
      <leafString name="WriteTimeout" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element specifies the timeout for blocking TCP write operations. If this timeout expires then the connection is closed.</p>
<p>The unit must be specified explicitly. Recognised units: ns, us, ms, s, min, hr, day.</p>
          ]]></comment>
        <minimum>0</minimum>
        <maximum>1hr</maximum>
        <maxLength>0</maxLength>
        <default>2 s</default>
      </leafString>
    </element>
    <element name="ThreadPool" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
<p>The ThreadPool element allows specifying various parameters related to using a thread pool to send DDSI messages to multiple unicast addresses (TCP or UDP).</p>
        ]]></comment>
      <leafBoolean name="Enable" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element enables the optional thread pool.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafInt name="ThreadMax" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This elements configures the maximum number of threads in the thread pool.</p>
          ]]></comment>
        <default>8</default>
      </leafInt>
      <leafInt name="Threads" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This elements configures the initial number of threads in the thread pool.</p>
          ]]></comment>
        <default>4</default>
      </leafInt>
    </element>
    <element name="Threads" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
<p>This element is used to set thread properties.</p>
        ]]></comment>
      <element name="Thread" minOccurrences="0" maxOccurrences="1000" version="COMMUNITY">
        <comment><![CDATA[
<p>This element is used to set thread properties.</p>
          ]]></comment>
        <attributeString name="Name" required="true" version="COMMUNITY">
          <comment><![CDATA[
<p>The Name of the thread for which properties are being set. The following threads exist:</p>
<ul><li><i>gc</i>: garbage collector thread involved in deleting entities;</li>
<li><i>recv</i>: receive thread, taking data from the network and running the protocol state machine;</li>
<li><i>dq.builtins</i>: delivery thread for DDSI-builtin data, primarily for discovery;</li>
<li><i>lease</i>: DDSI liveliness monitoring;</li>
<li><i>tev</i>: general timed-event handling, retransmits and discovery;</li>
<li><i>xmit.CHAN</i>: transmit thread for channel CHAN;</li>
<li><i>dq.CHAN</i>: delivery thread for channel CHAN;</li>
<li><i>tev.CHAN</i>: timed-even thread for channel CHAN.</li></ul>
            ]]></comment>
          <maxLength>0</maxLength>
          <default></default>
        </attributeString>
        <element name="Scheduling" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
<p>This element configures the scheduling properties of the thread.</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <leafEnum name="Class" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
            <comment><![CDATA[
<p>This element specifies the thread scheduling class (<i>realtime</i>, <i>timeshare</i> or <i>default</i>). The user may need special privileges from the underlying operating system to be able to assign some of the privileged scheduling classes.</p>
              ]]></comment>
            <value>realtime</value>
            <value>timeshare</value>
            <value>default</value>
            <default>default</default>
          </leafEnum>
          <leafString name="Priority" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
            <comment><![CDATA[
<p>This element specifies the thread priority (decimal integer or <i>default</i>). Only priorities that are supported by the underlying operating system can be assigned to this element. The user may need special privileges from the underlying operating system to be able to assign some of the privileged priorities.</p>
              ]]></comment>
            <maxLength>0</maxLength>
            <default>default</default>
          </leafString>
        </element>
        <leafString name="StackSize" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
<p>This element configures the stack size for this thread. The default value <i>default</i> leaves the stack size at the operating system default.</p>
<p>The unit must be specified explicitly. Recognised units: B (bytes), kB & KiB (2<sup>10</sup> bytes), MB & MiB (2<sup>20</sup> bytes), GB & GiB (2<sup>30</sup> bytes).</p>
            ]]></comment>
          <maxLength>0</maxLength>
          <default>default</default>
        </leafString>
      </element>
    </element>
    <element name="Tracing" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
<p>The Tracing element controls the amount and type of information that is written into the tracing log by the DDSI service. This is useful to track the DDSI service during application development.</p>
        ]]></comment>
      <leafBoolean name="AppendToFile" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This option specifies whether the output is to be appended to an existing log file. The default is to create a new log file each time, which is generally the best option if a detailed log is generated.</p>
          ]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafString name="EnableCategory" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element enables individual logging categories. These are enabled in addition to those enabled by Tracing/Verbosity. Recognised categories are:</p>
<ul><li><i>fatal</i>: all fatal errors, errors causing immediate termination</li>
<li><i>error</i>: failures probably impacting correctness but not necessarily causing immediate termination</li>
<li><i>warning</i>: abnormal situations that will likely not impact correctness</li>
<li><i>config</i>: full dump of the configuration</li>
<li><i>info</i>: general informational notices</li>
<li><i>discovery</i>: all discovery activity</li>
<li><i>data</i>: include data content of samples in traces</li>
<li><i>radmin</i>: receive buffer administration</li>
<li><i>timing</i>: periodic reporting of CPU loads per thread</li>
<li><i>traffic</i>: periodic reporting of total outgoing data</li>
<li><i>whc</i>: tracing of writer history cache changes</li>
<li><i>tcp</i>: tracing of TCP-specific activity</li>
<li><i>topic</i>: tracing of topic definitions</li>
<li>>i>plist</i>: tracing of discovery parameter list interpretation</li> </ul>
<p>In addition, there is the keyword <i>trace</i> that enables all but <i>radmin</i>, <i>topic</i>, <i>plist</i> and <i>whc</i></p>.
<p>The categorisation of tracing output is incomplete and hence most of the verbosity levels and categories are not of much use in the current release. This is an ongoing process and here we describe the target situation rather than the current situation. Currently, the most useful is <i>trace</i>.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default></default>
      </leafString>
      <leafString name="OutputFile" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This option specifies where the logging is printed to. Note that <i>stdout</i> and <i>stderr</i> are treated as special values, representing "standard out" and "standard error" respectively. No file is created unless logging categories are enabled using the Tracing/Verbosity or Tracing/EnabledCategory settings.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default>ddsi2.log</default>
      </leafString>
      <leafString name="PacketCaptureFile" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This option specifies the file to which received and sent packets will be logged in the "pcap" format suitable for analysis using common networking tools, such as WireShark. IP and UDP headers are ficitious, in particular the destination address of received packets. The TTL may be used to distinguish between sent and received packets: it is 255 for sent packets and 128 for received ones. Currently IPv4 only.</p>
          ]]></comment>
        <maxLength>0</maxLength>
        <default></default>
      </leafString>
      <leafBoolean name="Timestamps" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This option has no effect.</p>
          ]]></comment>
        <default>true</default>
        <attributeBoolean name="absolute" required="false" version="COMMUNITY">
          <comment><![CDATA[
<p>This option has no effect</p>
            ]]></comment>
          <default>true</default>
        </attributeBoolean>
      </leafBoolean>
      <leafEnum name="Verbosity" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element enables standard groups of categories, based on a desired verbosity level. This is in addition to the categories enabled by the Tracing/EnableCategory setting. Recognised verbosity levels and the categories they map to are:</p>
<ul><li><i>none</i>: no DDSI2 log</li>
<li><i>severe</i>: error and fatal</li>
<li><i>warning</i>: <i>severe</i> + warning</li>
<li><i>info</i>: <i>warning</i> + info</li>
<li><i>config</i>: <i>info</i> + config</li>
<li><i>fine</i>: <i>config</i> + discovery</li>
<li><i>finer</i>: <i>fine</i> + traffic and timing</li>
<li><i>finest</i>: <i>finer</i> + trace</li></ul>
<p>The categorisation of tracing output is incomplete and hence most of the verbosity levels and categories are not of much use in the current release. This is an ongoing process and here we describe the target situation rather than the current situation. Currently, the most useful verbosity levels are <i>config</i>, <i>fine</i> and <i>finest</i>.</p>
          ]]></comment>
        <value>finest</value>
        <value>finer</value>
        <value>fine</value>
        <value>config</value>
        <value>info</value>
        <value>warning</value>
        <value>severe</value>
        <value>none</value>
        <default>none</default>
      </leafEnum>
    </element>
    <element name="Watchdog" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
<p>This element specifies the type of OS scheduling class will be used by the thread that announces its liveliness periodically.</p>
        ]]></comment>
      <element name="Scheduling" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
<p>This element specifies the type of OS scheduling class will be used by the thread that announces its liveliness periodically.</p>
          ]]></comment>
        <leafEnum name="Class" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
<p>This element specifies the thread scheduling class that will be used by the watchdog thread. The user may need the appropriate privileges from the underlying operating system to be able to assign some of the privileged scheduling classes.</p>
            ]]></comment>
          <value>realtime</value>
          <value>timeshare</value>
          <value>default</value>
          <default>default</default>
        </leafEnum>
        <leafInt name="Priority" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
<p>This element specifies the thread priority. Only priorities that are supported by the underlying operating system can be assigned to this element. The user may need special privileges from the underlying operating system to be able to assign some of the privileged priorities.</p>
            ]]></comment>
          <default>0</default>
          <attributeEnum name="priority_kind" required="false" version="COMMUNITY">
            <comment><![CDATA[
<p>This attribute specifies whether the specified Priority is a relative or absolute priority.</p>
              ]]></comment>
            <value>relative</value>
            <value>absolute</value>
            <default>relative</default>
          </attributeEnum>
        </leafInt>
      </element>
    </element>
  </element>
<!-- END DDSI2Service CONFIGURATION AUTOMAGICALLY GENERATED (see src/services/ddsi2e/extract-configuration-xml.awk) -->
  <element name="TunerService" minOccurrences="0" maxOccurrences="0" version="COMMUNITY">
    <comment><![CDATA[
The TunerService configuration determines how the Tuner Service handles the
incoming client connections. It expects a root element named
OpenSplice/TunerService, in which several child-elements may be specified.
Each of these are listed and explained.
        ]]></comment>
    <attributeString name="name" required="true" version="COMMUNITY">
      <comment><![CDATA[
                This attribute identifies a configuration for the Tuner Service by name.
                Multiple Tuner Service configurations can be specified in one single
                resource file. The actual applicable configuration is determined by the
                value of the <i>name</i> attribute, which must match the one specified
                under the <i>OpenSplice/Domain/Service[@name]</i> in the configuration of
                the Domain Service.
            ]]></comment>
      <default>cmsoap</default>
      <maxLength>0</maxLength>
    </attributeString>
    <element name="Watchdog" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
                This element controls the characteristics of the Watchdog thread.
            ]]></comment>
      <element name="Scheduling" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    This element specifies the type of OS scheduling class will be
                    used by the thread that announces its liveliness periodically.
                ]]></comment>
        <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the thread priority that will be used by the
                        watchdog thread. Only priorities that are supported by the
                        underlying operating system can be assigned to this element.
                        The user may need special privileges from the underlying operating
                        system to be able to assign some of the privileged priorities.
                    ]]></comment>
          <default>0</default>
          <attributeEnum name="priority_kind" required="false" version="COMMUNITY">
            <comment><![CDATA[
                            This attribute specifies whether the specified
                            Priority is a relative or absolute priority.
                        ]]></comment>
            <value>Relative</value>
            <value>Absolute</value>
            <default>Relative</default>
          </attributeEnum>
        </leafInt>
        <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the thread scheduling class that will be used by
                        the watchdog thread. The user may need the appropriate privileges from
                        the underlying operating system to be able to assign some of the
                        privileged scheduling classes.
                    ]]></comment>
          <value>Timeshare</value>
          <value>Realtime</value>
          <value>Default</value>
          <default>Default</default>
        </leafEnum>
      </element>
    </element>
    <element name="Server" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
                This element determines the serverside behaviour of the Tuner service.
            ]]></comment>
      <leafString name="PortNr" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    This element determines the port number that the TunerService
                    will use to listen for incoming requests. This port number
                    must also be used by the Tuner tool to connect to this service.
                    Valid portnumbers are 1 till 65535.
                    When using the single process option set this value to Auto.
                ]]></comment>
        <maxLength>0</maxLength>
        <default>8000</default>
      </leafString>
      <leafInt name="Backlog" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    This element specifies the maximum number of client requests
                    that are allowed to be waiting when the maximum number of
                    concurrent requests is reached.
                ]]></comment>
        <minimum>0</minimum>
        <default>5</default>
      </leafInt>
      <leafEnum name="Verbosity" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    This element specifies the verbosity level of the logging of the service.
                ]]></comment>
        <value>0</value>
        <value>1</value>
        <value>2</value>
        <value>3</value>
        <value>4</value>
        <value>5</value>
        <default>0</default>
      </leafEnum>
    </element>
    <element name="Client" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
                This element determines how the Tuner service handles the
                incoming client connections.
            ]]></comment>
      <leafInt name="MaxClients" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    This element determines the maximum allowed number of clients
                    that are allowed to be concurrently connected to the Tuner
                    service. Clients are identified by IP-address.
                ]]></comment>
        <minimum>1</minimum>
        <default>10</default>
      </leafInt>
      <leafInt name="MaxThreadsPerClient" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    This element specifies the maximum number of threads that
                    the Tuner service will create for one specific client.
                    The number of threads determines the maximum number of
                    concurrent requests for a client.
                ]]></comment>
        <minimum>1</minimum>
        <default>10</default>
      </leafInt>
      <leafFloat name="LeasePeriod" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    This element determines the maximum amount of time in which a
                    connected client must update its lease. This can be done
                    implicitly by calling any function or explicitly by calling
                    the update lease function. The Tuner tool will automatically
                    update its lease when it is connected to the Tuner service.
                    This ensures that all resources are cleaned up automatically
                    if the client fails to update its lease within this period.
                ]]></comment>
        <minimum>10.0</minimum>
        <default>15.0</default>
        <dimension>seconds</dimension>
      </leafFloat>
      <element name="Scheduling" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    This element specifies the scheduling policies used to control the threads
                    that handle the client requests to the Tuner Service.
                ]]></comment>
        <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the thread priority that will be used by the threads that handle
                        client requests to the Tuner Service. Only priorities that are supported by the underlying
                        operating system can be assigned to this element. The user may need special privileges from
                        the underlying operating system to be able to assign some of the privileged priorities.
                    ]]></comment>
          <default>0</default>
          <attributeEnum name="priority_kind" required="false" version="COMMUNITY">
            <comment><![CDATA[
                            This attribute specifies whether the specified <i>Priority</i> is a relative
                            or absolute priority.
                        ]]></comment>
            <value>Relative</value>
            <value>Absolute</value>
            <default>Relative</default>
          </attributeEnum>
        </leafInt>
        <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the thread scheduling class that will be used by the threads that
                        handle client requests to the Tuner Service. The user may need the appropriate privileges
                        from the underlying operating system to be able to assign some of the privileged scheduling
                        classes.
                    ]]></comment>
          <value>Timeshare</value>
          <value>Realtime</value>
          <value>Default</value>
          <default>Default</default>
        </leafEnum>
      </element>
    </element>
    <element name="GarbageCollector" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
                This element specifies the behaviour of the garbage collection
                thread of the service.
            ]]></comment>
      <element name="Scheduling" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    This element specifies the scheduling policies used to control the garbagage
                    collection thread of the Tuner Service.
                ]]></comment>
        <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the thread priority that will be used by the garbage collection
                        thread of the Tuner Service. Only priorities that are supported by the underlying
                        operating system can be assigned to this element. The user may need special privileges from
                        the underlying operating system to be able to assign some of the privileged priorities.
                    ]]></comment>
          <default>0</default>
          <attributeEnum name="priority_kind" required="false" version="COMMUNITY">
            <comment><![CDATA[
                            This attribute specifies whether the specified <i>Priority</i> is a relative
                            or absolute priority.
                        ]]></comment>
            <value>Relative</value>
            <value>Absolute</value>
            <default>Relative</default>
          </attributeEnum>
        </leafInt>
        <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the thread scheduling class that will be used by the garbage
                        collection thread of the Tuner Service. The user may need the appropriate privileges
                        from the underlying operating system to be able to assign some of the privileged
                        scheduling classes.
                    ]]></comment>
          <value>Timeshare</value>
          <value>Realtime</value>
          <value>Default</value>
          <default>Default</default>
        </leafEnum>
      </element>
    </element>
    <element name="LeaseManagement" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
                This element specifies the behaviour of the lease management
                thread of the Tuner Service.
            ]]></comment>
      <element name="Scheduling" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    This element specifies the scheduling policies used to control the lease
                    management thread of the Tuner Service.
                ]]></comment>
        <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the thread priority that will be used by the lease management
                        thread of the Tuner Service. Only priorities that are supported by the underlying
                        operating system can be assigned to this element. The user may need special privileges from
                        the underlying operating system to be able to assign some of the privileged priorities.
                    ]]></comment>
          <default>0</default>
          <attributeEnum name="priority_kind" required="false" version="COMMUNITY">
            <comment><![CDATA[
                            This attribute specifies whether the specified <i>Priority</i> is a relative
                            or absolute priority.
                        ]]></comment>
            <value>Relative</value>
            <value>Absolute</value>
            <default>Relative</default>
          </attributeEnum>
        </leafInt>
        <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the thread scheduling class that will be used by the lease
                        management thread of the Tuner Service. The user may need the appropriate privileges
                        from the underlying operating system to be able to assign some of the privileged
                        scheduling classes.
                    ]]></comment>
          <value>Timeshare</value>
          <value>Realtime</value>
          <value>Default</value>
          <default>Default</default>
        </leafEnum>
      </element>
    </element>
  </element>
  <element name="DbmsConnectService" minOccurrences="0" maxOccurrences="0" version="COMMERCIAL">
    <comment><![CDATA[
               The DbmsConnect Service configuration is responsible for DDS to DBMS bridging
               and expects a root element named <i>OpenSplice/DbmsConnectService</i>. Within
               this root element, the DbmsConnect Service will look for several child-elements.
               Each of these is listed and explained.
           ]]></comment>
    <attributeString name="name" required="true" version="COMMERCIAL">
      <comment><![CDATA[
                This attribute identifies the configuration for the DBMS connect service by
                name. Multiple DBMS connect service configurations can be specified in one
                single resource file. The actual applicable configuration is determined by
                the value of the name attribute, which must match the one specified under the
                <i>OpenSplice/Domain/Service[@name]</i> in the configuration of
                the DomainService.
            ]]></comment>
      <maxLength>0</maxLength>
      <default>dbmsconnect</default>
    </attributeString>
    <element name="Watchdog" minOccurrences="0" maxOccurrences="1" version="COMMUNITY">
      <comment><![CDATA[
                This element controls the characteristics of the Watchdog thread
            ]]></comment>
      <element name="Scheduling" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
        <comment><![CDATA[
                    This element specifies the type of OS scheduling class will be
                    used by the thread that announces its liveliness periodically.
                ]]></comment>
        <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the thread priority that will be used by the
                        watchdog thread. Only priorities that are supported by the
                        underlying operating system can be assigned to this element.
                        The user may need special privileges from the underlying operating
                        system to be able to assign some of the privileged priorities.
                    ]]></comment>
          <default>0</default>
          <attributeEnum name="priority_kind" required="false" version="COMMUNITY">
            <comment><![CDATA[
                            This attribute specifies whether the specified
                            Priority is a relative or absolute priority.
                        ]]></comment>
            <value>Relative</value>
            <value>Absolute</value>
            <default>Relative</default>
          </attributeEnum>
        </leafInt>
        <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMUNITY">
          <comment><![CDATA[
                        This element specifies the thread scheduling class that will be used by
                        the watchdog thread. The user may need the appropriate privileges from
                        the underlying operating system to be able to assign some of the
                        privileged scheduling classes.
                    ]]></comment>
          <value>Timeshare</value>
          <value>Realtime</value>
          <value>Default</value>
          <default>Default</default>
        </leafEnum>
      </element>
    </element>
    <element name="DdsToDbms" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
                This element specifies the configuration properties concerning DDS to DBMS bridging.
            ]]></comment>
      <attributeBoolean name="replication_mode" required="false" version="COMMERCIAL">
        <comment><![CDATA[
                    <p>This attribute specifies the default replication mode for
                    all NameSpaces in the <i>DdsToDbms</i> element.</p>
                    <p>When replicating databases through DDS, the <i>NameSpace</i>
                    elements in the <i>DbmsToDds</i> and <i>DdsToDbms</i> elements
                    map a Table and Topic circularly. To prevent data-modifications
                    from continuously cascading, modifications made by the
                    DBMSConnect service itself should not trigger new updates
                    in the DBMS nor in the DDS.</p>
                    <p>In replication mode, the DBMS-connect service ignores
                    samples that were published by itself. (Currently that means
                    that everything that is published on the same node as the
                    DBMSConnect Service is considered to be of DBMSConnect
                    origin and therefore ignored). That way, replication of
                    changes that were copied from Dbms to DDS back into Dbms
                    is avoided.</p>
                    <p><b>WARNING</b>: This setting does not avoid replication
                    of changes that were copied from DDS to Dbms back into DDS.
                    For that purpose, the <i>replication_user</i> attribute of the
                    <i>DbmsToDds</i> or <i>DbmsToDds/NameSpace</i> elements should
                    be set appropriately as well!</p>
                ]]></comment>
        <default>FALSE</default>
      </attributeBoolean>
      <element name="NameSpace" minOccurrences="1" maxOccurrences="0" version="COMMERCIAL">
        <comment><![CDATA[
                    This element specifies the responsibilities of the service
                    concerning the bridging of particular data from DDS to DBMS.
                    At least one <i>NameSpace</i> element has to be present in
                    a <i>DdsToDbms</i> element.
                ]]></comment>
        <attributeString name="name" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                        The name of the namespace. If not specified, the namespace
                        will be named "(nameless)".
                    ]]></comment>
          <maxLength>0</maxLength>
          <default>(nameless)</default>
        </attributeString>
        <attributeString name="odbc" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                        <p>The service dynamically loads an ODBC library at runtime. This attribute
                        specifies the name of the ODBC library to be loaded. Platform specific
                        pre- and postfixes and extensions are automatically added.</p>
                        <p>If this attribute is not provided, the service will attempt to load the
                        generic ODBC library. The resulting behaviour is dependent on the platform
                        on which the DbmsConnect Service is running.</p>
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <attributeString name="partition" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                        <p>This attribute specifies an expression that represents one or more DDS
                        partitions. It is allowed to use wildcards in the expression: a '*'
                        represents any sequence of characters and a '?' represents one
                        single character.</p>
                        <p>This expression is used to specify the DDS partition(s) from which
                        DDS samples must be 'bridged' to the DBMS domain.</p>
                    ]]></comment>
          <maxLength>0</maxLength>
          <default>*</default>
        </attributeString>
        <attributeString name="topic" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                        <p>This attribute specifies an expression that represents one or more DDS
                        topic names. It is allowed to use wildcards in the expression: a '*'
                        represents any sequence of characters and a '?' represents one
                        single character.</p>
                        <p>This expression is used to specify the topics from which DDS
                        samples must be 'bridged' to the DBMS domain.  For every matching
                        topic encountered in one or more of the specified partitions, it
                        creates a separate table in the DBMS. The table name will match that
                        of the topic, unless specified otherwise in the <i>table</i> attribute
                        of a <i>Mapping</i> element.</p>
                    ]]></comment>
          <maxLength>0</maxLength>
          <default>*</default>
        </attributeString>
        <attributeFloat name="update_frequency" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                        This attribute specifies the frequency (in Hz) at which the service
                        will update the DBMS domain with DDS data. By default, it is 0.0Hz
                        which means it is done event based (every time new DDS data arrives).
                    ]]></comment>
          <minimum>0.0</minimum>
          <default>0.0</default>
          <dimension>Hz</dimension>
        </attributeFloat>
        <attributeString name="dsn" required="true" version="COMMERCIAL">
          <comment><![CDATA[
                        Represents the ODBC Data Source Name, that represents the DBMS where
                        the service must bridge the DDS data to.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <attributeString name="usr" required="true" version="COMMERCIAL">
          <comment><![CDATA[
                        Represents the user name that is used when connecting to the DBMS.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <attributeString name="pwd" required="true" version="COMMERCIAL">
          <comment><![CDATA[
                        Represents the password that is used when connecting to the DBMS.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <attributeString name="schema" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                        Represents the schema that is used when communicating with the DBMS.
                        The exact schema content may be dependent on the DBMS that is being
                        used, so consult your DBMS documentation for more details on this subject.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <attributeString name="catalog" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                        Represents the catalog that is used when communicating with the DBMS.
                        The exact catalog content may be dependent on the DBMS that is being
                        used, so consult your DBMS documentation for more details on this subject.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <attributeBoolean name="replication_mode" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                        <p>This attribute specifies the replication mode for the
                        current <i>NameSpace</i> element. If not specified, the value
                        will be inherited from the <i>replication_mode</i> of the parent
                        <i>DdsToDbms</i> element, which if not explicitly specified
                        defaults to false</p>
                        <p>When replicating databases through DDS, the <i>NameSpace</i>
                        elements in the <i>DbmsToDds</i> and <i>DdsToDbms</i> elements
                        map a Table and Topic circularly. To prevent data-modifications
                        from continuously cascading, modifications made by the
                        DBMSConnect service itself should not trigger new updates
                        in the DBMS.</p>
                        <p>In replication mode, the DBMS-connect service ignores
                        samples that were published by itself. (Currently that means
                        that everything that is published on the same node as the
                        DBMSConnect Service is considered to be of DBMSConnect
                        origin and therefore ignored). That way, replication of
                        changes that were copied from Dbms to DDS back into Dbms
                        is avoided.</p>
                        <p><b>WARNING</b>: This setting does not avoid replication
                        of changes that were copied from DDS to Dbms back into DDS.
                        For that purpose, the <i>replication_user</i> attribute of the
                        <i>DbmsToDds</i> or <i>DbmsToDds/NameSpace</i> elements should
                        be set appropriately as well!</p>
                    ]]></comment>
          <default>FALSE</default>
        </attributeBoolean>
        <element name="Mapping" minOccurrences="0" maxOccurrences="0" version="COMMERCIAL">
          <comment><![CDATA[
                            This element specifies a modification to the way that the service handles
                            a pre-configured set of data within the specified NameSpace. Its attributes
                            are used to configure the responsibilities of the service concerning the
                            bridging of data from DDS to DBMS.
                    ]]></comment>
          <attributeString name="topic" required="true" version="COMMERCIAL">
            <comment><![CDATA[
                     This attribute specifies the name of the topic where the Mapping applies to. If you
                     specify no particular topic, it will create tables for all topics
                      ]]></comment>
            <maxLength>0</maxLength>
            <default/>
          </attributeString>
          <attributeString name="table" required="false" version="COMMERCIAL">
            <comment><![CDATA[
                            This attribute specifies an alternative name for the table that
                            must be associated with the topic. By default the table name is
                            equal to the topic name.
                        ]]></comment>
            <maxLength>0</maxLength>
            <default/>
          </attributeString>
          <attributeString name="query" required="false" version="COMMERCIAL">
            <comment><![CDATA[
                            This attribute specifies an SQL query expression. Only DDS data
                            that matches the query will be bridged to the DBMS domain. This
                            is realized by means of a DCPS query condition. The default value
                            is an empty string, representing all available samples of the
                            selected topic.
                        ]]></comment>
            <maxLength>0</maxLength>
            <default/>
          </attributeString>
          <attributeString name="filter" required="false" version="COMMERCIAL">
            <comment><![CDATA[
                            This attribute specifies an SQL content filter. Only DDS data
                            that matches the filter will be bridged to the DBMS domain. This
                            is realized by means of a DCPS ContentFilteredTopic. The default
                            value is an empty string, representing all available samples of
                            the selected topic.
                        ]]></comment>
            <maxLength>0</maxLength>
            <default/>
          </attributeString>
        </element>
      </element>
    </element>
    <element name="DbmsToDds" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
                Holds the configuration of the service concerning DBMS to DDS bridging
            ]]></comment>
      <attributeBoolean name="publish_initial_data" required="false" version="COMMERCIAL">
        <comment><![CDATA[
                    This attribute specifies the default behaviour with respect to publishing
                    initially available data in the DBMS to the DDS for all NameSpace elements
                    in the current DbmsToDds element. If not specified, it defaults to true.
                    The value of this attribute is ignored when the corresponding
                    event_table_policy is set to NONE.
                   ]]></comment>
        <default>true</default>
      </attributeBoolean>
      <attributeEnum name="event_table_policy" required="false" version="COMMERCIAL">
        <comment><![CDATA[
                    <p>This attribute specifies the default setting of the event table policy for all <i>NameSpace</i> elements in the current <i>DbmsToDds</i> element.</p>
                    <p>An event table (sometimes referred to as 'change table' or 'shadow table') is a support-table that is slaved to an application-table, adding some status flags that are under the control of a trigger mechanism that responds to creation/modification/ deletion events in the application-table.</p>
                    <p>The following policies are currently supported:</p>
                    <ul>
                    <li><b>FULL</b>: <i>(default)</i> An 'event table' will always be created when the service connects, and will always be deleted when the service disconnects. In this mode, the service will replace the table if it already exists.</li>
                    <li><b>LAZY</b>: An 'event table' will only be created if it is not available when the service connects, and it will not be deleted when the service disconnects.</li>
                    <li><b>NONE</b>: An 'event table' will neither be created nor deleted by the service. For each specified <i>NameSpace</i>, the service will poll for the existence of a consistent table with a frequency specified in the coresponding <i>update_frequency</i> attribute. It will start using the table as soon as it is available. With this policy set, no initial data will be published regardless of the value of the applicable <i>publish_initial_data</i> attribute.</li>
                    </ul>
                ]]></comment>
        <value>FULL</value>
        <value>LAZY</value>
        <value>NONE</value>
        <default>FULL</default>
      </attributeEnum>
      <attributeEnum name="trigger_policy" required="false" version="COMMERCIAL">
        <comment><![CDATA[
                    <p>This attribute specifies the default trigger policy for all <i>NameSpace</i> elements in the current <i>DbmsToDds</i> element.</p>
                    <p>Triggers are used to to update the event table in case of creation/modification/ deletion events on the application-table. </p>
                    <p>The following policies are currently supported:</p>
                    <ul>
                    <li><b>FULL</b>: <i>(default)</i> Triggers will always be created when the service connects, and will always be deleted when the service disconnects. In this mode, the service will replace the triggers if they already exists.</li>
                    <li><b>LAZY</b>: Triggers will only be created if they are not available when the service connects, and will not be deleted when the service disconnects.</li>
                    <li><b>NONE</b>: Triggers will neither be created nor deleted by the service. This allows you to build your own custom triggering mechanism.</li>
                    </ul>
                ]]></comment>
        <value>FULL</value>
        <value>LAZY</value>
        <value>NONE</value>
        <default>FULL</default>
      </attributeEnum>
      <attributeString name="replication_user" required="false" version="COMMERCIAL">
        <comment><![CDATA[
                    <p>This attribute specifies the default replication user for
                    all <i>NameSpace</i> elements in the current <i>DdsToDbms</i>
                    element.</p>
                    <p>When replicating databases through DDS, the <i>NameSpace</i>
                    elements in the <i>DbmsToDds</i> and <i>DdsToDbms</i> elements
                    map a Table and Topic circularly. To prevent data-modifications
                    from continuously cascading, modifications made by the
                    service itself should not trigger new updates in the
                    DBMS nor in the DDS.</p>
                    <p>To distinguish between DBMS updates coming from an
                    application and DBMS updates coming from DDS, an extra
                    database user (the replication user) has to be introduced
                    that differs from the application users. That way,
                    replication of changes that were copied from DDS to Dbms
                    back into DDS is avoided. The replication_user attribute
                    specifies the user name of that replication user. An empty
                    string (default value) indicates that there is no separate
                    replication user.</p>
                    <p><b>WARNING</b>: This setting does not avoid replication
                    of changes that were copied from Dbms to DDS back into Dbms.
                    For that purpose, the <i>replication_mode</i> attribute of
                    the <i>DssToDbms</i> or <i>DssToDbms/NameSpace</i> elements
                    should be set appropriately as well!</p>
                ]]></comment>
        <maxLength>0</maxLength>
        <default/>
      </attributeString>
      <element name="NameSpace" minOccurrences="1" maxOccurrences="0" version="COMMERCIAL">
        <comment><![CDATA[
                    This element specifies the responsibilities of the service concerning
                    the bridging of data from DBMS to DDS. At least one <i>NameSpace</i>
                    element has to be present in a <i>DbmsToDds</i> element.
                ]]></comment>
        <attributeString name="name" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                        The name of the namespace. If not specified, the namespace
                        will be named "(nameless)".
                    ]]></comment>
          <maxLength>0</maxLength>
          <default>(nameless)</default>
        </attributeString>
        <attributeString name="odbc" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                        <p>The service dynamically loads an ODBC library at runtime. This attribute
                        specifies the name of the ODBC library to be loaded. Platform specific
                        pre- and postfixes and extensions are automatically added.</p>
                        <p>If this attribute is not provided, the service will attempt to load the
                        generic ODBC library. The resulting behaviour is dependent on the platform
                        on which the DbmsConnect Service is running.</p>
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <attributeString name="partition" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                        <p>This attribute specifies an expression represents one or more DDS partitions.
                        It is allowed to use wildcards in the expression: a '*' represents any
                        sequence of characters and a '?' represents one single character.</p>
                        <p>This expression is used to specify the DDS partition(s) where DBMS records
                        will be written to as DDS samples by the service.</p>
                    ]]></comment>
          <maxLength>0</maxLength>
          <default>*</default>
        </attributeString>
        <attributeString name="table" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                        <p>This attribute specifies an expression that represents one or more DBMS
                        table names.  It is allowed to use wildcards in the expression: a '*'
                        represents any sequence of characters and a '?' represents one single
                        character.</p>
                        <p>This expression is used to specify the tables from which DBMS data must
                        be 'bridged' to the DDS domain.</p>
                    ]]></comment>
          <maxLength>0</maxLength>
          <default>*</default>
        </attributeString>
        <attributeFloat name="update_frequency" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                        This attribute specifies the frequency (in Hz) at which
                        the service will update the DDS domain with DBMS data.
                        By default, it is 2.0Hz. Event-based updates are not
                        supported. If 0.0Hz is specified, the default of 2.0Hz
                        will be used.
                    ]]></comment>
          <minimum>0.0</minimum>
          <default>2.0</default>
          <dimension>Hz</dimension>
        </attributeFloat>
        <attributeString name="dsn" required="true" version="COMMERCIAL">
          <comment><![CDATA[
                        Represents the Data Source Name, that represents the DBMS where
                        the service must bridge the DDS data from.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <attributeString name="usr" required="true" version="COMMERCIAL">
          <comment><![CDATA[
                        Represents the user name that is used when connecting to the DBMS.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <attributeString name="pwd" required="true" version="COMMERCIAL">
          <comment><![CDATA[
                        Represents the password that is used when connecting to the DBMS.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <attributeBoolean name="publish_initial_data" required="false" version="COMMERCIAL">
          <default>true</default>
          <comment><![CDATA[
                        This attribute specifies the default behaviour with respect to publishing
                        initially available data in the DBMS to the DDS for all <i>Mapping</i>
                        elements in the current <i>NameSpace</i> element. If not specified, the value
                        will be inherited from the <i>publish_initial_data</i> of the parent
                        <i>DbmsToDds</i> element, which defaults to true. The value of this attribute
                        is ignored when the corresponding <i>event_table_policy</i> is set to NONE.
                       ]]></comment>
        </attributeBoolean>
        <attributeBoolean name="force_key_equality" required="false" version="COMMERCIAL">
          <default>true</default>
          <comment><![CDATA[
                        This attribute specifies the default setting for <i>Mapping</i> elements
                        in the current <i>NameSpace</i> element with regard to the enforcement of
                        key equality between table and topic definitions. If true, key definitions
                        from the table and topic must match, otherwise key definitions may differ.
                       ]]></comment>
        </attributeBoolean>
        <attributeEnum name="event_table_policy" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                        <p>This attribute specifies the default setting of the event table policy for all <i>Mapping</i> elements in the current <i>NameSpace</i> element. If not specified, the value will be inherited from the <i>event_table_policy</i> of the parent <i>DbmsToDds</i> element, which if not explicitly specified defaults to FULL.</p>
                        <p>An event table (sometimes referred to as 'change table' or 'shadow table') is a support-table that is slaved to an application-table, adding some status flags that are under the control of a trigger mechanism that responds to creation/modification/ deletion events in the application-table.</p>
                        <p>The following policies are currently supported:</p>
                        <ul>
                        <li><b>FULL</b>: An 'event table' will always be created when the service connects, and will always be deleted when the service disconnects. In this mode, the service will replace the table if it already exists.</li>
                        <li><b>LAZY</b>: An 'event table' will only be created if it is not available when the service connects, and it will not be deleted when the service disconnects.</li>
                        <li><b>NONE</b>: An 'event table' will neither be created nor deleted by the service. For each specified <i>NameSpace</i>, the service will poll for the existence of a consistent table with a frequency specified in the coresponding <i>update_frequency</i> attribute. It will start using the table as soon as it is available. With this policy set, no initial data will be published regardless of the value of the applicable <i>publish_initial_data</i> attribute.</li>
                        </ul>
                    ]]></comment>
          <value>FULL</value>
          <value>LAZY</value>
          <value>NONE</value>
          <default>FULL</default>
        </attributeEnum>
        <attributeEnum name="trigger_policy" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                        <p>This attribute specifies the default trigger policy for all <i>Mapping</i> elements in the current <i>NameSpace</i> element. If not specified, the value will be inherited from the <i>trigger_policy</i> of the parent <i>DbmsToDds</i> element, which if not explicitly specified defaults to FULL.</p>
                        <p>Triggers are used to to update the event table in case of creation/modification/ deletion events on the application-table.</p>
                        <p>The following policies are currently supported:</p>
                        <ul>
                        <li><b>FULL</b>: <i>(default)</i> Triggers will always be created when the service connects, and will always be deleted when the service disconnects. In this mode, the service will replace the triggers if they already exists.</li>
                        <li><b>LAZY</b>: Triggers will only be created if they are not available when the service connects, and will not be deleted when the service disconnects.</li>
                        <li><b>NONE</b>: Triggers will neither be created nor deleted by the service. This allows you to build your own custom triggering mechanism.</li>
                        </ul>
                   ]]></comment>
          <value>FULL</value>
          <value>LAZY</value>
          <value>NONE</value>
          <default>FULL</default>
        </attributeEnum>
        <attributeString name="schema" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                        Represents the schema that is used when communicating with the DBMS.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <attributeString name="catalog" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                        Represents the catalog that is used when communicating with the DBMS.
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <attributeString name="replication_user" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                        <p>This attribute specifies the default replication user for
                        all <i>Mapping</i> elements in the current <i>NameSpace</i>
                        element. If not specified, the value will be inherited from
                        the <i>replication_user</i> of the parent <i>DbmsToDds</i> element,
                        which by default has no separate replication user specified.</p>
                        <p>When replicating databases through DDS, the <i>NameSpace</i>
                        elements in the <i>DbmsToDds</i> and <i>DdsToDbms</i> elements
                        map a Table and Topic circularly. To prevent data-modifications
                        from continuously cascading, modifications made by the
                        service itself should not trigger new updates in the
                        DBMS nor in the DDS.</p>
                        <p>To distinguish between DBMS updates coming from an
                        application and DBMS updates coming from DDS, an extra
                        database user (the replication user) has to be introduced
                        that differs from the application users. That way,
                        replication of changes that were copied from DDS to Dbms
                        back into DDS is avoided. The replication_user attribute
                        specifies the user name of that replication user. An empty
                        string (default value) indicates that there is no separate
                        replication user.</p>
                        <p><b>WARNING</b>: This setting does not avoid replication
                        of changes that were copied from Dbms to DDS back into Dbms.
                        For that purpose, the <i>replication_mode</i> attribute of
                        the <i>DssToDbms</i> or <i>DssToDbms/NameSpace</i> elements
                        should be set appropriately as well!</p>
                    ]]></comment>
          <maxLength>0</maxLength>
          <default/>
        </attributeString>
        <element name="Mapping" minOccurrences="0" maxOccurrences="0" version="COMMERCIAL">
          <comment><![CDATA[
                           This element specifies a modification to the way that the service handles
                           a pre-configured set of data within the specified NameSpace. Its attributes
                           are used to configure the responsibilities of the service concerning the
                           bridging of data from DBMS to DDS
                    ]]></comment>
          <attributeString name="table" required="true" version="COMMERCIAL">
            <comment><![CDATA[
                            This attribute specifies the name of the table where the Mapping applies to.
                        ]]></comment>
            <maxLength>0</maxLength>
            <default/>
          </attributeString>
          <attributeString name="topic" required="false" version="COMMERCIAL">
            <comment><![CDATA[
                            This attribute specifies an alternative name for the topic that
                            must be associated with the table. By default the topic name is
                            equal to the table name.
                        ]]></comment>
            <maxLength>0</maxLength>
            <default/>
          </attributeString>
          <attributeString name="query" required="false" version="COMMERCIAL">
            <comment><![CDATA[
                            Optional DBMS query expression. Only DBMS data that matches the
                            query will be bridged to the DDS domain. This is realized by
                            means of a SQL query. The default value is an empty string,
                            representing all available data in the selected table.
                        ]]></comment>
            <maxLength>0</maxLength>
            <default/>
          </attributeString>
          <attributeBoolean name="publish_initial_data" required="false" version="COMMERCIAL">
            <default>true</default>
            <comment><![CDATA[
                        This attribute specifies the behaviour with respect to publishing the
                        initially available data specified in the current <i>Mapping</i> element
                        from DBMS to DDS. If not specified, the value will be inherited from
                        the <i>publish_initial_data</i> of the parent <i>NameSpace</i> element,
                        which if not explicitly specified inherits from the <i>publish_initial_data</i>
                        of the parent <i>DbmsToDds</i> element, which defaults to true.
                        The value of this attribute is ignored when the corresponding
                        <i>event_table_policy</i> is set to NONE.
                       ]]></comment>
          </attributeBoolean>
          <attributeBoolean name="force_key_equality" required="false" version="COMMERCIAL">
            <default>true</default>
            <comment><![CDATA[
                           This attribute specifies the enforcement of key equality between table
                           and topic definitions. If true, key definitions from the table and
                           topic must match, otherwise key definitions may differ. If not specified,
                           the value will be inherited from the <i>force_key_equality</i> of the parent
                           <i>NameSpace</i> element, which if not explicitly specified defaults to true.
                    ]]></comment>
          </attributeBoolean>
          <attributeEnum name="event_table_policy" required="false" version="COMMERCIAL">
            <comment><![CDATA[
                        <p>This attribute specifies the event table policy in the current <i>Mapping</i> element. If not specified, the value will be inherited from the <i>event_table_policy</i> of the parent <i>NameSpace</i> element, which if not explicitly specified inherits from the <i>event_table_policy</i> of the parent <i>DbmsToDds</i> element, which defaults to FULL.</p>
                        <p>An event table (sometimes referred to as 'change table' or 'shadow table') is a support-table that is slaved to an application-table, adding some status flags that are under the control of a trigger mechanism that responds to creation/modification/ deletion events in the application-table.</p>
                        <p>The following policies are currently supported:</p>
                        <ul>
                        <li><b>FULL</b>: An 'event table' will always be created when the service connects, and will always be deleted when the service disconnects. In this mode, the service will replace the table if it already exists.</li>
                        <li><b>LAZY</b>: An 'event table' will only be created if it is not available when the service connects, and it will not be deleted when the service disconnects.</li>
                        <li><b>NONE</b>: An 'event table' will neither be created nor deleted by the service. For the specified table, the service will poll with a frequency specified in the coresponding <i>update_frequency</i> attribute of the parent <i>NameSpace</i>. It will start using the table as soon as it is available. With this policy set, no initial data will be published regardless of the value of the applicable <i>publish_initial_data</i> attribute.</li>
                        </ul>
                    ]]></comment>
            <value>FULL</value>
            <value>LAZY</value>
            <value>NONE</value>
            <default>FULL</default>
          </attributeEnum>
          <attributeEnum name="trigger_policy" required="false" version="COMMERCIAL">
            <comment><![CDATA[
                        <p>This attribute specifies the trigger policy for the current <i>Mapping</i> element. If not specified, the value will be inherited from the <i>trigger_policy</i> of the parent <i>DbmsToDds</i> element, which if not explicitly specified inherits from the <i>trigger_policy</i> of the parent <i>DbmsToDds</i> element, which defaults to FULL.</p>
                        <p>Triggers are used to to update the event table in case of creation/modification/ deletion events on the application-table.</p>
                        <p>The following policies are currently supported:</p>
                        <ul>
                        <li><b>FULL</b>: <i>(default)</i> Triggers will always be created when the service connects, and will always be deleted when the service disconnects. In this mode, the service will replace the triggers if they already exists.</li>
                        <li><b>LAZY</b>: Triggers will only be created if they are not available when the service connects, and will not be deleted when the service disconnects.</li>
                        <li><b>NONE</b>: Triggers will neither be created nor deleted by the service. This allows you to build your own custom triggering mechanism.</li>
                        </ul>
                   ]]></comment>
            <value>FULL</value>
            <value>LAZY</value>
            <value>NONE</value>
            <default>FULL</default>
          </attributeEnum>
        </element>
      </element>
    </element>
    <element name="Tracing" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
                This element controls the amount and type of information that is
                written into the tracing log file by the DbmsConnect Service.
                This is useful to track the DbmsConnect Service during application
                development. In the runtime system it should be turned off.
            ]]></comment>
      <leafString name="OutputFile" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element specifies where the logging is printed to. Note that
                    "stdout" and "stderr" are considered legal values that represent
                    "standard out" and "standard error" respectively. The default
                    value is an empty string, indicating that all tracing is disabled.
                ]]></comment>
        <maxLength>0</maxLength>
        <default>dbmsconnect.log</default>
        <dimension>file name</dimension>
      </leafString>
      <leafBoolean name="Timestamps" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element specifies whether the logging must contain timestamps.
                ]]></comment>
        <attributeBoolean name="absolute" required="false" version="COMMERCIAL">
          <comment><![CDATA[
                        This attribute specifies whether the timestamps are absolute or
                        relative to the startup time of the service.
                    ]]></comment>
          <default>true</default>
        </attributeBoolean>
        <default>true</default>
      </leafBoolean>
      <leafEnum name="Verbosity" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
                    This element specifies the verbosity level of the logging.
                ]]></comment>
        <value>SEVERE</value>
        <value>WARNING</value>
        <value>INFO</value>
        <value>CONFIG</value>
        <value>FINE</value>
        <value>FINER</value>
        <value>FINEST</value>
        <default>INFO</default>
      </leafEnum>
    </element>
  </element>
  <element name="RnRService" minOccurrences="0" maxOccurrences="0" version="COMMERCIAL">
    <comment><![CDATA[
      The Record and Replay Service allows to record data from a DDS domain to a storage, and
      replay data from a storage back into the DDS domain.
    ]]></comment>
    <attributeString name="name" required="true" version="COMMERCIAL">
      <comment><![CDATA[
        This attribute identifies a configuration for the Record and Replay Service by name.
        Multiple service configurations can be specified in one single resource file. The actual
        applicable configuration is determined by the value of the <i>name</i> attribute, which
        must match the one specified under the <i>OpenSplice/Domain/Service[@name]</i> in the
        configuration of the Domain Service.
        ]]></comment>
      <default>rnr</default>
      <maxLength>0</maxLength>
    </attributeString>
    <element name="Watchdog" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[
        This element controls the characteristics of the Watchdog thread.
      ]]></comment>
      <element name="Scheduling" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[
          This element specifies the type of OS scheduling class will be
          used by the thread that announces its liveliness periodically.
        ]]></comment>
        <leafInt name="Priority" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
            This element specifies the thread priority that will be used by the
            watchdog thread. Only priorities that are supported by the
            underlying operating system can be assigned to this element.
            The user may need special privileges from the underlying operating
            system to be able to assign some of the privileged priorities.
          ]]></comment>
          <default>0</default>
          <attributeEnum name="priority_kind" required="false" version="COMMERCIAL">
            <comment><![CDATA[
              This attribute specifies whether the specified
              Priority is a relative or absolute priority.
            ]]></comment>
            <value>Relative</value>
            <value>Absolute</value>
            <default>Relative</default>
          </attributeEnum>
        </leafInt>
        <leafEnum name="Class" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[
            This element specifies the thread scheduling class that will be used by
            the watchdog thread. The user may need the appropriate privileges from
            the underlying operating system to be able to assign some of the
            privileged scheduling classes.
          ]]></comment>
          <value>Timeshare</value>
          <value>Realtime</value>
          <value>Default</value>
          <default>Default</default>
        </leafEnum>
      </element>
    </element>
    <element name="Storage" minOccurrences="0" maxOccurrences="0" version="COMMERCIAL">
      <comment><![CDATA[This element specifies a storage to use for recording and/or replaying data.
        Currently the supported storage backends are XML and CDR.
        Note that storages can also be created, or their properties modified, by Record and Replay configuration-commands.
        These commands use the same syntax to specify configuration data as the Vortex OpenSplice configuration file,
        so the description given here also applies to commands.]]></comment>
      <attributeString name="name" required="true" version="COMMERCIAL">
        <comment><![CDATA[The name used to identify the storage in Record and Replay commands.]]></comment>
        <default>default</default>
        <maxLength>0</maxLength>
      </attributeString>
      <element name="rr_storageAttrXML" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[Attributes describing an XML storage.]]></comment>
        <leafString name="filename" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[The filename template used for files that comprise a storage.
            The filename may contain a relative or absolute path. If a path is omitted,
            the storage files are created in the current working directory.]]></comment>
          <maxLength>0</maxLength>
          <default>rnr-storage.dat</default>
        </leafString>
        <leafSize name="MaxFileSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[The maximum size per storage file. When approaching the maximum size while recording,
            a new storage file is automatically created with a sequence number appended to the filename.
            The active file is also switched transparently while replaying from a storage that contains
            multiple data files.
            The human-readable option lets the user postfix the value with K(ilobyte), M(egabyte) or
            G(igabtye). For example, 10M results in 10485760 bytes.
            This element is optional, when omitted or when 0 is configured, the file size is not monitored
            by the service and limited only by filesystem and/or platform-specific limits.]]></comment>
          <minimum>0</minimum>
          <default>0</default>
          <dimension>bytes</dimension>
        </leafSize>
      </element>
      <element name="rr_storageAttrCDR" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[Attributes describing an CDR storage.]]></comment>
        <leafString name="filename" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[The filename template used for files that comprise a storage.
            The filename may contain a relative or absolute path. If a path is omitted,
            the storage files are created in the current working directory.]]></comment>
          <maxLength>0</maxLength>
          <default>rnr-storage.dat</default>
        </leafString>
        <leafSize name="MaxFileSize" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[The maximum size per storage file. When approaching the maximum size while recording,
            a new storage file is automatically created with a sequence number appended to the filename.
            The active file is also switched transparently while replaying from a storage that contains
            multiple data files.
            The human-readable option lets the user postfix the value with K(ilobyte), M(egabyte) or
            G(igabtye). For example, 10M results in 10485760 bytes.
            This element is optional, when omitted or when 0 is configured, the file size is not monitored
            by the service and limited only by filesystem and/or platform-specific limits.]]></comment>
          <minimum>0</minimum>
          <default>0</default>
          <dimension>bytes</dimension>
        </leafSize>
      </element>
      <element name="Statistics" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[Maintain and optionally publish statistics for this storage.]]></comment>
        <attributeBoolean name="enabled" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[This attribute specifies if statistics should be maintained for this storage.]]></comment>
          <default>true</default>
        </attributeBoolean>
        <attributeInt name="publish_interval" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[This attribute specifies the publication interval of the statistics belonging to this storage,
            in a Record and Replay storage-statistics topic. The publish interval is a value in seconds but may also
            be set to -1. This means the statistics are published when the storage is closed. Note that a value of 0 means
            statistics are never published.]]></comment>
          <default>30</default>
          <dimension>seconds</dimension>
        </attributeInt>
        <attributeBoolean name="reset" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
          <comment><![CDATA[This attribute allows to reset the current values of statistics belonging to the storage. Note
            that this only makes sense in a configuration-command for an existing storage, since new storages created
            from the Vortex OpenSplice configuration file always start out with empty statistics.]]></comment>
          <maxLength>0</maxLength>
          <default>false</default>
        </attributeBoolean>
      </element>
    </element>
    <element name="Tracing" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
      <comment><![CDATA[This element enables debug output of the R&R service to a logfile.]]></comment>
      <leafString name="OutputFile" minOccurrences="1" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[This option specifies where the logging is printed to.
          Note that "stdout" is considered a legal value that represents "standard out"
          and "stderr" is a legal value representing "standard error".]]></comment>
        <maxLength>0</maxLength>
        <default>rnr.log</default>
      </leafString>
      <leafBoolean name="AppendToFile" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[This option specifies whether the output is to be appended to an existing log file.
          The default is to overwrite the log file if it exists.]]></comment>
        <default>false</default>
      </leafBoolean>
      <leafEnum name="Verbosity" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[This element specifies the verbosity level of the logging information.
          The higher the level, the more (detailed) information will be logged.]]></comment>
        <value>SEVERE</value>
        <value>WARNING</value>
        <value>INFO</value>
        <value>CONFIG</value>
        <value>FINE</value>
        <value>FINER</value>
        <value>FINEST</value>
        <value>NONE</value>
        <default>INFO</default>
      </leafEnum>
      <leafString name="EnableCategory" minOccurrences="0" maxOccurrences="1" version="COMMERCIAL">
        <comment><![CDATA[This option allows to enable specific logging categories independently of the
          categories selected by specifiying a verbosity level.
          Multiple categories, seperated by a comma, can be supplied.
          The following categories are available:
          <ul>
            <li><b>FATAL</b>: Errors that are potentially fatal for the correct operation of the service.</li>
            <li><b>ERROR</b>: Non-fatal errors.</li>
            <li><b>WARNING</b>: Warnings that indicate for example incorrect or unsupported usage of the service.</li>
            <li><b>INFO</b>: Descriptive messages, logged when certain important events occur.</li>
            <li><b>CONFIG</b>: Events related to the service configuration.</li>
            <li><b>TRACE</b>: Detailed messages describing the behaviour of the service.</li>
            <li><b>RECORD</b>: Messages for each recorded sample.</li>
            <li><b>REPLAY</b>: Messages for each replayed sample.</li>
          </ul>]]></comment>
        <maxLength>0</maxLength>
        <default/>
      </leafString>
    </element>
  </element>
  <element name="Agent" version="COMMUNITY" minOccurrences="0" maxOccurrences="1">
    <comment><![CDATA[<p>The root element of a Control and Monitoring Agent configuration.</p>]]></comment>
    <attributeString name="name" version="COMMUNITY" required="true">
      <comment><![CDATA[<p>This attribute identifies the configuration for the Control and Monitoring Agent. Multiple service configurations can be specified in one single XML file. The actual applicable configuration is determined by the value of the name attribute, which must match the string specified in the element OpenSplice/Domain/Service[@name] in the Domain Service configuration.</p>]]></comment>
      <default>cmagent</default>
      <maxLength>0</maxLength>
    </attributeString>
    <element name="Tracing" version="COMMUNITY" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[<p>The Tracing element controls the amount and type of information that is written into the tracing log by the Control and Monitoring Agent service. This is useful to track the service during application development.</p>]]></comment>
      <leafString name="EnableCategory" version="COMMUNITY" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[<p>This element enables individual logging categories. These are enabled in addition to those enabled by Tracing/Verbosity. Recognised categories are:<ul><li><i>fatal</i>: all fatal errors, errors causing immediate termination</li><li><i>error</i>: failures probably impacting correctness but not necessarily causing immediate termination</li><li><i>warning</i>: abnormal situations that will likely not impact correctness</li><li><i>config</i>: full dump of the configuration</li><li><i>info</i>: general informational notices</li></ul>In addition, there is the keyword <i>trace</i> that enables all categories</p>]]></comment>
        <default></default>
        <maxLength>0</maxLength>
      </leafString>
      <leafEnum name="Verbosity" version="COMMUNITY" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[<p>This element enables standard groups of categories, based on a desired verbosity level. This is in addition to the categories enabled by the Tracing/EnableCategory setting. Recognised verbosity levels and the categories they map to are:<ul><li><i>none</i>: no Control and Monitoring Agent log</li><li><i>severe</i>: error and fatal</li><li><i>warning</i>: <i>severe</i> + warning</li><li><i>info</i>: <i>warning</i> + general information messages</li><li><i>config</i>: <i>info</i> + config</li><li><i>fine</i>: equivalent to <i>config</i></li><li><i>finest</i>: <i>fine</i> + trace</li></ul>While <i>none</i> prevents any message from being written to a Control and Monitoring Agent log file, warnings and errors are still logged in the ospl-info.log and ospl-error.log files.</p>]]></comment>
        <default>none</default>
        <value>finest</value>
        <value>finer</value>
        <value>fine</value>
        <value>config</value>
        <value>info</value>
        <value>warning</value>
        <value>severe</value>
        <value>none</value>
      </leafEnum>
      <leafString name="OutputFile" version="COMMUNITY" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[<p>This option specifies where the logging is printed to. Note that <i>stdout</i> and <i>stderr</i> are treated as special values, representing "standard out" and "standard error" respectively. No file is created unless logging categories are enabled using the Tracing/Verbosity or Tracing/EnabledCategory settings.</p>]]></comment>
        <default>cmagent.log</default>
        <dimension>file path</dimension>
        <maxLength>0</maxLength>
      </leafString>
      <leafBoolean name="AppendToFile" version="COMMUNITY" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[<p>This option specifies whether the output is to be appended to an existing log file. The default is to create a new log file each time, which is generally the best option if a detailed log is generated.</p>]]></comment>
        <default>false</default>
      </leafBoolean>
    </element>
    <element name="Watchdog" version="COMMUNITY" minOccurrences="0" maxOccurrences="1">
      <comment><![CDATA[<p>This element specifies the type of OS scheduling class will be used by the thread that announces its liveliness periodically.</p>]]></comment>
      <element name="Scheduling" version="COMMUNITY" minOccurrences="0" maxOccurrences="1">
        <comment><![CDATA[<p>This element specifies the type of OS scheduling class will be used by the thread that announces its liveliness periodically.</p>]]></comment>
        <leafEnum name="Class" version="COMMUNITY" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[<p>This element specifies the thread scheduling class that will be used by the watchdog thread. The user may need the appropriate privileges from the underlying operating system to be able to assign some of the privileged scheduling classes.</p>]]></comment>
          <default>default</default>
          <value>realtime</value>
          <value>timeshare</value>
          <value>default</value>
        </leafEnum>
        <leafInt name="Priority" version="COMMUNITY" minOccurrences="0" maxOccurrences="1">
          <comment><![CDATA[<p>This element specifies the thread priority. Only priorities that are supported by the underlying operating system can be assigned to this element. The user may need special privileges from the underlying operating system to be able to assign some of the privileged priorities.</p>]]></comment>
          <attributeEnum name="priority_kind" version="COMMUNITY" required="true">
            <comment><![CDATA[<p>This attribute specifies whether the specified Priority is a relative or absolute priority.</p>]]></comment>
            <default>relative</default>
            <value>relative</value>
            <value>absolute</value>
          </attributeEnum>
          <default>0</default>
        </leafInt>
      </element>
    </element>
  </element>
</splice_meta_config>
