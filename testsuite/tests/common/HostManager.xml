<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE stax SYSTEM "../../stax/stax.dtd">

<stax>
    <script>STAXMessageLog = 1</script>
    <function name="Initialize" scope="global">
        <function-prolog>
        <![CDATA[
            <p>The HostManager::Initialize function is the main entry point for starting a batch
            of testcases. It only needs to be executed once but if it gets called multiple times
            (for example when linking batches of testcases in a seperate, parent, STAX script),
            the 'init_required' variable will make sure the body of the function isn't executed more than once.
            The function takes care of the following:
            <ul>
                <li>Include library functions from other STAX scripts (STAXUtil, ResourceManager, FileUtils, OpenSplice), which makes
                them accessible to the testcases that are executed after initialisation</li>
                <li>Import the TestHost python module, used for administration of machines involved in testcases</li>
                <li>The hostname of the resource pool machines is resolved by checking environment variable 'RESPOOLSERVER'.
                If this is unavailable, the local STAF machine is used to manage the resource pools.</li>
                <li>The file with TestHost definitions is resolved by checking environment variable 'HOSTDEFS'.
                If unavailable, the script will attempt to load the file 'hosts.pkl' in the current script directory.</li>
                <li>The testmachine and networking ports resource pools are created and populated.</li>
                <li>The local machine is queried for available OpenSplice installers (in $OSPL_HOME/install/VC),
                which can be deployed on testhosts during a testcase</li>
            </ul>
            The following global variables are accessible after the function completes:
            <ul>
                <li>staf_root: The STAF installation path on the local machine (resolved using {STAF/Config/STAFRoot}).</li>
                <li>file_sep: The file seperator on the local machine (resolved using {STAF/Config/Sep/File}).</li>
                <li>local_ospl_home: The path used to locate OpenSplice installers and testcase files on the local machine.</li>
                <li>ospl_installer_path: The path where OpenSplice installers are available on the local machine.</li>
                <li>ospl_installers: Python list of available OpenSplice installers.</li>
            </ul>
            This function may throw the following exceptions:
            <ul>
                <li>NoHostsAvailable: No host could be initialized.</li>
            </ul>
            </p>
        ]]>
        </function-prolog>
        <function-epilog></function-epilog>
        <sequence>
            <script>
                import os, sys, re, random, time, copy
                try:
                    if(init_required):
                        init_required = 0
                except NameError:
                    init_required = 1
            </script>
            <if expr="init_required == 1">
                <sequence>
                    <log message="STAXMessageLog" level="'info'">'Initializing HostManager'</log>
                    <!--  Resolve some local STAF variables -->
                    <stafcmd name="'Initialize::ResolveString'">
                        <location>STAXCurrentXMLMachine</location>
                        <service>'VAR'</service>
                        <request>
                            'RESOLVE STRING %s STRING %s STRING %s' % ( '{STAF/Config/STAFRoot}', '{STAF/Config/Sep/File}', '{STAF/Env/OSPL_HOME}')
                        </request>
                    </stafcmd>
                    <script>
                        staf_root = STAXGlobal([None])
                        file_sep = STAXGlobal([None])
                        local_ospl_home = STAXGlobal([None])

                        if STAFResult[0]['rc'] == '0':
                            staf_root = STAFResult[0]['result']

                        if STAFResult[1]['rc'] == '0':
                            file_sep = STAFResult[1]['result']

                        if STAFResult[2]['rc'] == '0':
                            local_ospl_home = STAFResult[2]['result']
                    </script>

                    <!-- Append utility classes to python path -->
                    <script>
                        sys.path.append(os.path.dirname(STAXCurrentXMLFile) + file_sep + 'python')
                        from TestHost             	  import *
                        from process                  import *
                        from base_test_scenario       import *
                    </script>

                    <!--  Import other lib functions -->
                    <import file="'ResourceManager.xml'"/>
                    <import file="'FileUtils.xml'"/>
                    <import file="'OpenSplice.xml'"/>

                    <!--  Import STAXUtil functions -->
                    <import file="'%(root)s%(sep)cservices%(sep)cstax%(sep)clibraries%(sep)cSTAXUtil.xml' % { 'root': staf_root, 'sep': file_sep }"/>

                    <!--  Use envvar 'RESPOOLSERVER' as ResourcePool STAF machine
                          (defaults to local) -->
                    <script>
                        respoolsrv = os.getenv('RESPOOLSERVER')

                        if respoolsrv == None:
                            respoolsrv = STAXCurrentXMLMachine
                    </script>
                    <call function="'CreateResourcePools'">0, respoolsrv</call>

                    <script>
                        hostsfile = os.getenv('HOSTDEFS')
                        if hostsfile == None:
                            hostsfile = os.path.dirname(STAXCurrentXMLFile) + file_sep + 'hosts.pkl'
                    </script>

                    <call function="'LoadHostsDefinitions'">hostsfile</call>
                    <log message="STAXMessageLog" level="'info'">'HostManager: %d available hosts' % STAXResult</log>
                    <if expr="STAXResult == 0">
                        <throw exception="'Resource.NoHostAvailable'">'Could not find any usable STAF hosts'</throw>
                    </if>

                    <!-- Reserve a port-range for OpenSplice tests
                         Note: for any port, if a reliable channel is bound to that port, port+1 is also used by the reliable networking protocol
                         Therefore only even ports are added to the resource pool.
                    -->
                    <loop from="33000" to="33100" by="2" var="port">
                        <sequence>
                            <call function="'AddPortResource'">port</call>
                            <log message="STAXMessageLog" if="(STAXResult[0] != STAFRC.Ok) and (STAXResult[0] != STAFRC.AlreadyExists)" level="'warning'">'HostManager: Failed to reserve port %d (RC: %d, Msg: %s)' % (port, STAXResult[0], STAXResult[1])</log>
                        </sequence>
                    </loop>

                    <!--  Initialize OpenSplice installers -->
                    <script>
                        ospl_installer_path = STAXGlobal([])
                        ospl_installers = STAXGlobal([])
                        if local_ospl_home == None:
                            # Try to guess OSPL_HOME based on current directory
                            local_ospl_home = '%(cwd)s%(sep)c..%(sep)c..%(sep)c..%(sep)c..%(sep)c../ospli' % { 'cwd': os.path.dirname(STAXCurrentXMLFile), 'sep': file_sep }

                        ospl_installer_path = os.path.abspath('%s%c%s%c%s' % (local_ospl_home, file_sep, 'install', file_sep, 'VC'))
                    </script>
                    <stafcmd name="'Initialize::ListInstallers'">
                        <location>'local'</location>
                        <service>'FS'</service>
                        <request>'LIST DIRECTORY %s NAME %s TYPE F SORTBYNAME' % (ospl_installer_path, 'OpenSpliceDDS*installer*')</request>
                    </stafcmd>
                    <if expr="RC == STAFRC.Ok">
                        <script>
                            ospl_installers = STAFResult
                            ospl_installers.reverse()
                        </script>
                        <else>
                            <!-- Note: testcases can still run if hosts have access to preinstalled OpenSplice instance -->
                            <log message="STAXMessageLog" level="'warning'">'No installers available at %s' % ospl_installer_path</log>
                        </else>
                    </if>
                </sequence>
                <else>
                    <log message="STAXMessageLog" level="'info'">'Skipping HostManager initialization'</log>
                </else>
            </if>
        </sequence>
    </function>

    <function name="LoadHostsDefinitions">
        <function-prolog>
        <![CDATA[
            Load serialized host definitions (TestHost objects) from a python 'pickle file'.
            This file is created by the GenerateHosts.py script and contains basic hosts properties.
            Additional host information is added to the TestHost objects by various functions before and during a testcase.
            For each host, a host resource entry is added by calling 'AddHostResource' and the host is initialized by calling 'InitializeHost'
            A global python list ('hostsList') is created. A host is added to this list if:<br/>
            - It could be deserialized from the pickle data file<br/>
            - A host resource entry could be added or an existing entry reused<br/>
            - The host was successfully initialized (by calling InitializeHost)<br/>
        ]]>
        </function-prolog>
        <function-epilog>
        <![CDATA[
            The function returns the number of hosts that could be successfully initialized.
        ]]>
        </function-epilog>
        <function-single-arg>
            <function-required-arg name="hostsfile">
                Absolute path to a file containing (serialized) TestHost objects.
            </function-required-arg>
        </function-single-arg>
        <sequence>
            <script>
                import cPickle as pickle
                if os.path.isfile(hostsfile):
                    tmpList = pickle.load(open(hostsfile))
                else:
                    tmpList = []
                hostsList = STAXGlobal([])
            </script>
            <if expr="len(tmpList) > 0">
                    <paralleliterate in="tmpList" var="host_obj">
                        <sequence>
                            <!--  Add to resource pool -->
                            <call function="'AddHostResource'">host_obj</call>

                            <if expr="(STAXResult[0] == STAFRC.Ok) or (STAXResult[0] == STAFRC.AlreadyExists)">
                                <sequence>
                                    <log if="STAXResult[0] == STAFRC.AlreadyExists" message="STAXMessageLog" level="'warning'">
                                        'HostManager: %s resource already exists' % host_obj.get_hostname()
                                    </log>

                                    <!--  Initialize -->
                                    <call function="'InitializeHost'">host_obj</call>
                                    <script>RC = STAXResult</script>
                                    <if expr="RC == STAFRC.Ok">
                                        <sequence>
                                            <script>hostsList.append(host_obj)</script>
                                            <log message="STAXMessageLog" level="'info'">
                                                'HostManager: Host %s initialized' % host_obj.get_hostname()
                                            </log>
                                        </sequence>
                                        <else>
                                            <log message="STAXMessageLog" level="'error'">
                                                'HostManager: %s failed initialization' % host_obj.get_hostname()
                                            </log>
                                        </else>
                                    </if>
                                </sequence>
                                <elseif expr="STAXResult[0] == STAFRC.NoPathToMachine">
                                    <log message="STAXMessageLog" level="'warning'">'HostManager: %s is unreachable (%s)' % (host_obj.get_hostname(), STAXResult[1])</log>
                                </elseif>
                                <else>
                                    <log message="STAXMessageLog" level="'warning'">'HostManager: %s failed (%s)' % (host_obj.get_hostname(), STAXResult[1])</log>
                                </else>
                            </if>
                        </sequence>
                    </paralleliterate>
                    <else>
                        <log message="STAXMessageLog" level="'fatal'">'Failed to load any hosts from file: %s' % hostsfile</log>
                    </else>
            </if>
            <return>len(hostsList)</return>
        </sequence>
    </function>

    <function name="InitializeHost" scope="local">
        <function-prolog>
        <![CDATA[
            <p>Initialize a host by detecting various platform dependent properties and storing them
            in the TestHost object that describes the host.</p>
        ]]>
        </function-prolog>
        <function-epilog>
        <![CDATA[
            <p>The function returns  if the host is successfully initialized. If any errors or warnings occur
            during initialization, these are logged and 1 is returned.</p>
        ]]>
        </function-epilog>
        <function-single-arg>
            <function-required-arg name="host">The TestHost to initialize</function-required-arg>
        </function-single-arg>
        <sequence>
            <call function="'STAXUtilImportSTAFConfigVars'">host.get_staf_url()</call>
            <script>
                [RC, staf_map, error_list] = STAXResult
            </script>
            <if expr="(RC == 0) and (error_list == None)">
                <sequence>
                    <script>
                        ospl_home = None
                        basedir = None
                    </script>
                    <call function="'STAXUtilImportSTAFVars'">
                    [ { 'STAF/Env/OSPL_HOME':   'ospl_home',
                        'STAF/DataDir':         'basedir'   },
                        host.get_staf_url()
                    ]
                    </call>
                    <if expr="basedir == None">
                        <script>
                            RC = 1
                            if error_list == None:
                                error_list = []
                            error_list.append('Fatal: cannot resolve {STAF/DataDir}')
                        </script>
                        <else>
                            <sequence>
                                <script>
                                    [RC, error_list] = host.initCapabilities(staf_map, ospl_home, basedir)
                                </script>
                            </sequence>
                        </else>
                    </if>
                </sequence>
                <!--
                <else>
                    <script>
                        error_list = []
                        error_list.append('Fatal: failed to resolve STAF config variables')
                    </script>
                </else>
                 -->
            </if>
            <if expr="len(error_list) > 0">
                <sequence>
                    <script>
                        msg = ''
                        for err in error_list:
                            msg += '- %s' % err
                            if err != error_list[-1]:
                                msg += '%s' % '\n'
                    </script>
                    <log message="STAXMessageLog" level="'info'">
                        'HostManager: Initializing host %s:\n%s' % (host.get_hostname(), msg)
                    </log>
                </sequence>
            </if>
            <return>RC</return>
        </sequence>
    </function>

    <function name="RequestHost" scope="local">
        <function-prolog>
        <![CDATA[
            <p>Request a host with specific properties. The internal list of test hosts is used
            to find a host that meets the requested properties. Then the TestMachines resource pool
            is queried to check if the host is available for a test run.</p>
        ]]>
        </function-prolog>
        <function-epilog>
        <![CDATA[
            <p>If a suitable TestHost can be found it is returned.
            The function throws a 'NoHostAvailable' exception and returns None if no suitable host can be found.</p>
        ]]>
        </function-epilog>
        <function-map-args>
            <function-optional-arg name="hostname">
                Regular expression to match against hostname
            </function-optional-arg>
            <function-optional-arg name="target">
                Regular expression describing OpenSplice target that the host needs to support ('win32', 'x86_64', 'x86.*-dev')
            </function-optional-arg>
            <function-optional-arg name="mode">
                OpenSplice deployment mode that the host needs to support ('RTS', 'HDE', 'SRC')
            </function-optional-arg>
            <function-optional-arg name="reused_host" default="0">
                If the host could be used second time it is 1.
            </function-optional-arg>
        </function-map-args>
        <sequence>
            <script>
                import re
                resultHost = None
                if hostname == None:
                    # Search all hosts
                    searchList = hostsList[:]
                else:
                    # Search only hosts which hostname matches 'hostname'
                    searchList = []
                    for h in hostsList:
                        if re.search(hostname, h.get_hostname(), re.I):
                            searchList.append(h)
                # Randomize list
                random.shuffle(searchList)
            </script>
            <if expr="len(searchList) > 0">
            <iterate var="candidate" in="searchList">
                <sequence>
                    <script>msg = 'RequestHost: try %s... target is %s and mode is %s' % (candidate.get_hostname(), target, mode)</script>
                    <if expr="candidate.supportsTarget(target) and candidate.supportsMode(mode)">
                        <sequence>
                            <call function="'RequestHostResource'">candidate.get_hostname(), 5</call>
                            <if expr="STAXResult == 0 or reused_host">
                                <sequence>
                                    <script>
                                        msg += 'Success'
                                        if reused_host:
                                            resultHost = copy.deepcopy(candidate)
                                        else:
                                            resultHost = candidate
                                    </script>
                                    <log message="STAXMessageLog" level="'info'">msg</log>
                                    <break/>
                                </sequence>
                                <else>
                                    <script>msg += 'Failed (locked)'</script>
                                </else>
                            </if>
                        </sequence>
                        <else>
                            <script>msg += 'Failed (not supported)'</script>
                        </else>
                    </if>
                    <log message="STAXMessageLog" level="'info'">msg</log>
                </sequence>
            </iterate>
            </if>
            <if expr="resultHost == None">
                <throw exception="'Resource.NoHostAvailable'">'No available host'</throw>
            </if>
            <return>resultHost</return>
        </sequence>
    </function>

    <function name="ReleaseHost">
        <function-prolog>
        <![CDATA[
            <p>This function can be called if a host is finished running testcases and the TestHost object is not
            needed anymore. The resource entry in the TestMachines pool is then released.</p>
        ]]>
        </function-prolog>
        <function-epilog>
        <![CDATA[
            <p>If the host resource can be released the result of the ReleaseHostResource call is returned. If the host is invalid 1 is returned.</p>
        ]]>
        </function-epilog>
        <function-list-args>
            <function-required-arg name="host">The TestHost to release</function-required-arg>
        </function-list-args>
        <sequence>
            <if expr="host == None">
                <return>1</return>
            </if>
            <if expr="host.is_deployed()">
                <log message="STAXMessageLog" level="'warning'">'ReleaseHost: Warning %s still has deployed OpenSplice instance!' % host.get_hostname()</log>
            </if>
            <call function="'ReleaseHostResource'">host.get_hostname()</call>
            <return>RC</return>
        </sequence>
    </function>

    <function name="DeployHost">
        <function-prolog>
        <![CDATA[
            <p>This function prepares a host to run OpenSplice. Deploying a host will update the
            TestHost object to support a particular preinstalled OpenSplice version and if no
            suitable preinstalled version is available it will try to install OpenSplice if a suitable
            installer is available on the local host.
            A number of properties can influence the way in which a host is deployed.<br/>
            - If the 'purge' argument is 0, try to re-use preinstalled OpenSplice instances<br/>
            - If OSPL_HOME is set, check there, else use {STAF/DataDir} to locate preinstalled versions<br/>
            - If the 'mode' argument is 'SRC' and OSPL_HOME is not set, throw 'HostDeployException' (live git checkouts are not supported yet)<br/>
            - If the 'version' argument is used, only accept a matching preinstalled version.<br/>
            - The most recent preinstalled version that can be validated, is used.<br/>
            - If none of the preinstalled versions can be validated or if 'purge' argument is set, stop caring about preinstalled versions and try installers<br/>
            - Call 'DeployOpenSplice' to find and install a suitable OpenSplice version.<br/>
            - Update the TestHost object according to the newly installed or re-used OpenSplice instance. Set is_deployed flag on host.<br/>
            </p>
        ]]>
        </function-prolog>
        <function-epilog>
        <![CDATA[
            <p>The function throws a 'HostDeployFailed' exception if the host cannot be deployed due to an error on the host. If incompatible parameters are used the function throws HostDeployUnsupported exception.</p>
        ]]>
        </function-epilog>
        <function-map-args>
            <function-required-arg name="host">
                TestHost to deploy
            </function-required-arg>
            <function-optional-arg name="version" default="None">
                The version of OpenSplice to deploy, in X.Y.Z format. If omitted, the most recent, validated version is used
            </function-optional-arg>
            <function-optional-arg name="purge" default="0">
                Install, or reuse a preinstalled OpenSplice. Default: re-use
            </function-optional-arg>
            <function-optional-arg name="keep" default="1">
                If a new OpenSplice instance is deployed, uninstall it at host cleanup. Default: keep
            </function-optional-arg>
        </function-map-args>
        <sequence>
            <!--  Retrieve ospl environment path+filename -->
            <script>
                envfile_path = None
                validated = STAFRC.UserDefined
            </script>
            <if expr="purge == 0">
                <if expr="host.get_ospl_home() == None">
                    <if expr="host.get_mode() == 'SRC'">
                        <sequence>
                            <!--  todo GitManager script: deploy git tags/branches -->
                            <log message="STAXMessageLog" level="'fatal'">'DeployHost: Deploying OpenSplice source tree on %s not supported if OSPL_HOME unset' % host.get_hostname()</log>
                            <throw exception="'Resource.HostDeployUnsupported'">'SRC mode only supported if OSPL_HOME is set'</throw>
                        </sequence>
                        <else>
                            <!-- Find RTS/HDE deployment target path -->
                            <sequence>
                                <script>
                                    base_path = '%(root)s%(sep)cOpenSpliceDDS%(sep)c' % { 'root': host.get_basedir(), 'sep': host.get_filesep() }
                                </script>
                                <log if="version == None" message="STAXMessageLog" level="'info'">'DeployHost: Locating preinstalled OpenSplice instances on %s (version: all, path: %s)' % (host.get_hostname(), base_path)</log>
                                <log if="version != None" message="STAXMessageLog" level="'info'">'DeployHost: Locating preinstalled OpenSplice instances on %s (version: %s, path: %s)' % (host.get_hostname(), version, base_path)</log>

                                <if expr="version == None">
                                    <sequence>
                                        <stafcmd name="'DeployHost::ListInstalledOpenSpliceVersions'">
                                            <location>host.get_staf_url()</location>
                                            <service>'FS'</service>
                                            <request>'LIST DIRECTORY %s TYPE D SORTBYNAME' % base_path</request>
                                        </stafcmd>
                                        <if expr="RC == 0 and (len(STAFResult) > 0)">
                                            <!-- Check if preinstalled OpenSplice is valid
                                                 Break if valid version is found
                                            -->
                                            <iterate var="element" in="STAFResult">                                               
                                                <sequence>
                                                    <log message="STAXMessageLog" level="'info'">'DeployHost: version is \'%s\' on %s' % (element, host.get_hostname())</log>
                                                    <script>
                                                        <!--m = re.match('^V([0-9]+\.[0-9]+\.[0-9]+)', element, re.I)
                                                        if m:
                                                            host.set_version(m.group(1))
                                                            corrupt = 0
                                                        else:-->
                                                            host.set_version(element)
                                                            corrupt = 0
                                                    </script>
                                                    <if expr="corrupt">
                                                        <log message="STAXMessageLog" level="'warning'">'DeployHost: Unsupported OpenSplice instance \'%s\' on %s' % (element, host.get_hostname())</log>
                                                        <else>
                                                            <sequence>
                                                                <call function="'ValidateInstallation'">host</call>
                                                                <script>[validated, envfile_path] = STAXResult</script>
                                                                <if expr="validated == STAFRC.Ok">
                                                                    <sequence>
                                                                        <log message="STAXMessageLog" level="'info'">'DeployHost: Using preinstalled OpenSplice instance \'%s\' on %s' % (element, host.get_hostname())</log>
                                                                        <if expr="not keep">
                                                                            <script>
                                                                                uninst_path = base_path + host.get_filesep() + element + host.get_filesep() + 'uninstall-' + host.get_target().replace('-release', '') + '-' + host.get_mode() + host.get_exec_ext()
                                                                                host.set_uninstaller(uninst_path)
                                                                            </script>
                                                                        </if>
                                                                        <break/>
                                                                    </sequence>
                                                                </if>
                                                            </sequence>
                                                        </else>
                                                    </if>
                                                </sequence>
                                            </iterate>
                                        </if>
                                    </sequence>
                                    <else>
                                        <sequence>
                                            <script>host.set_version(version)</script>
                                            <call function="'ValidateInstallation'">host</call>
                                            <script>[validated, envfile_path] = STAXResult</script>
                                        </sequence>
                                    </else>
                                </if>
                                <log if="validated != STAFRC.Ok" level="'info'">'DeployHost: Failed to locate suitable preinstalled OpenSplice instance on %s' % host.get_hostname()</log>
                            </sequence>
                        </else>
                    </if>
                    <else>
                        <!-- OSPL_HOME is set -->
                        <sequence>
                            <!-- don't care about version if OSPL_HOME is set -->
                            <log if="version == None" message="STAXMessageLog" level="'info'">'DeployHost: using OSPL_HOME to locate OpenSplice on %s' % host.get_hostname()</log>
                            <log if="version != None" message="STAXMessageLog" level="'warning'">'DeployHost: using OSPL_HOME to locate OpenSplice on %s (ignoring request for version %s)' % (host.get_hostname(), version)</log>
                            <script>host.set_version('unknown')</script>
                            <call function="'ValidateInstallation'">host</call>
                            <script>[validated, envfile_path] = STAXResult</script>
                        </sequence>
                    </else>
                </if>
            </if>

            <if expr="validated != STAFRC.Ok">
                <!-- No preinstalled version found (or purge=1) -->
                <sequence>
                    <call function="'DeployOpenSplice'">host, keep</call>
                    <script>
                        validated = STAXResult
                        envfile_path = host.get_envfile()
                    </script>
                 </sequence>
            </if>

            <if expr="envfile_path != None and validated == STAFRC.Ok">
                <sequence>
                    <log message="STAXMessageLog" level="'info'">'Validated envfile for %s: %s' % (host.get_hostname(), envfile_path)</log>
                    <!-- If mode == SRC we cannot extend the host environment at runtime.
                     Sourcing the env_file will overwrite any extended variables since original variable contents
                     are not included in the env_file (This is a shortcoming in our configure and makefile scripting).
                     To workaround this we will parse the entire env_file, set all vars as environment extensions on the TestHost,
                     and not source the env_file when we run something on the host.
                    -->
                    <if expr="host.get_mode() == 'SRC'">
                        <sequence>
                            <stafcmd>
                                <location>host.get_staf_url()</location>
                                <service>'FS'</service>
                                <request>'GET FILE %s TEXT FORMAT NATIVE' % envfile_path</request>
                            </stafcmd>
                            <if expr="RC == STAFRC.Ok">
                                <script>host.parse_env(STAFResult)</script>
                                <else>
                                    <throw exception="'Resource.HostDeployFailed'">STAFResult</throw>
                                </else>
                            </if>
                        </sequence>
                    </if>
                    <call function="'CreateDirectory'">host, host.get_logdir()</call>
                    <script>
                        # Set default OpenSplice executables
                        ext = host.get_exec_ext()
                        host.set_env('OSPL_EXEC', 'spliced' + ext)
                        host.set_env('OSPL_NWEXEC', 'networking' + ext)
                        host.set_env('OSPL_DEXEC', 'durability' + ext)
                        host.set_deployed(1)
                    </script>
                </sequence>
                <else>
                    <throw exception="'Resource.HostDeployFailed'">'Failed to deploy OpenSplice'</throw>
                </else>
            </if>
        </sequence>
    </function>

    <function name="ValidateInstallation" scope="local">
        <function-prolog>
        <![CDATA[
            <p>A host is validated by checking if the detected OpenSplice environment file can be accessed on the host.
            If the file can be accessed it is set as active environment file on the TestHost.</p>
        ]]>
        </function-prolog>
        <function-epilog>
        <![CDATA[
            <p>The function result is the return code of the file check and the path to the detected environment file.</p>
        ]]>
        </function-epilog>
        <function-single-arg>
            <function-required-arg name="host">TestHost</function-required-arg>
        </function-single-arg>
        <sequence>
            <script>
                env_file = host.detect_envfile()
                msg = 'ValidateInstallation: %s on %s' % (env_file, host.get_hostname())
            </script>
            <stafcmd>
                <location>host.get_staf_url()</location>
                <service>'FS'</service>
                <request>'QUERY ENTRY %s' % env_file</request>
            </stafcmd>
            <script>
                if RC == STAFRC.Ok:
                    msg += ' is valid'
                    host.set_envfile(env_file)
                else:
                    msg += ' not valid'
            </script>
            <log message="STAXMessageLog" level="'debug'">msg</log>
            <return>RC, env_file</return>
        </sequence>
    </function>

    <function name="DeployOpenSplice">
        <function-prolog>
        <![CDATA[
            <p>Find a suitable installer and install OpenSplice on a remote host. For an installation,
            the installer is first copied to the remote host</p>
        ]]>
        </function-prolog>
        <function-epilog>
        <![CDATA[
            <p>If the installation fails the function throws a 'HostDeployFailed' and a non-0 value is returned.</p>
        ]]>
        </function-epilog>
        <function-list-args>
            <function-required-arg name="host">TestHost</function-required-arg>
            <function-optional-arg name="keep" default="0">Don't run uninstaller at host cleanup (default: run uninstaller)</function-optional-arg>
        </function-list-args>
        <sequence>
            <script>
                installer = host.matchInstaller(ospl_installers)
                target_path = '{STAF/DataDir}' + host.get_filesep() + 'tmp'
            </script>
            <if expr="installer == None">
                <sequence>
                    <log message="STAXMessageLog" level="'error'">'DeployOpenSplice: No suitable installer available for %s (Installers: %s)' % (host.get_hostname(), ospl_installers)</log>
                    <return>STAFRC.UserDefined</return>
                </sequence>
                <else>
                    <sequence>
                        <log message="STAXMessageLog" level="'debug'">'DeployOpenSplice: Using %s on %s' % (installer, host.get_hostname())</log>
                        <call-with-map function="'FileCopy'">
                            <call-map-arg name="'src_path'">ospl_installer_path + file_sep + installer</call-map-arg>
                            <call-map-arg name="'dest_host'">host</call-map-arg>
                            <call-map-arg name="'dest_path'">target_path</call-map-arg>
                        </call-with-map>
                        <if expr="STAXResult == STAFRC.Ok">
                            <sequence>
                                <script>
                                    prefix_path = host.get_basedir() + host.get_filesep() + 'OpenSpliceDDS' + host.get_filesep() + 'V' + host.get_version()
                                    exec_parms = '--debugtrace install.log --mode unattended --prefix %s' % prefix_path
                                    exec_cmd = target_path + host.get_filesep() + installer
                                </script>
                                <process name="'DeployOpenSplice::RunInstaller'">
                                    <location>host.get_staf_url()</location>
                                    <command>exec_cmd</command>
                                    <parms>exec_parms</parms>
                                    <workdir>'{STAF/DataDir}'</workdir>
                                    <stderr mode="'stdout'"/>
                                    <returnstdout/>
                                </process>
                                <script>result = RC</script>
                                <if expr="(RC == STAFRC.Ok)">
                                    <if expr="not (keep)">
                                        <script>
                                            uninst_target = host.get_target().replace('-release', '')
                                            uninst_path = prefix_path + host.get_filesep() + 'uninstall-' + host.get_target().replace('-release', '') + '-' + host.get_mode() + host.get_exec_ext()
                                            host.set_uninstaller(uninst_path)
                                        </script>
                                    </if>
                                    <else>
                                        <log message="STAXMessageLog">'OpenSplice installer failed on %s: %s Installer: %s %s' % (host.get_hostname(), STAXResult[0][1], exec_cmd, exec_parms)</log>
                                    </else>
                                </if>
                            </sequence>
                            <else>
                                <throw exception="'Resource.HostDeployFailed'">'Failed to copy %s to %s' % (installer, host.get_hostname())</throw>
                            </else>
                        </if>
                    </sequence>
                </else>
            </if>

            <call function="'ValidateInstallation'">host</call>
            <script>[validated, envfile_path] = STAXResult</script>
            <if expr="validated != STAFRC.Ok">
                <throw exception="'Resource.HostDeployFailed'">'Failed to deploy OpenSplice'</throw>
            </if>
            <return>result</return>
        </sequence>
    </function>

    <function name="RemoveOpenSplice">
        <function-prolog>
        <![CDATA[
            <p>Call OpenSplice uninstaller</p>
        ]]>
        </function-prolog>
        <function-epilog>
        <![CDATA[
            <p>The return code of the uninstaller is returned</p>
        ]]>
        </function-epilog>
        <function-single-arg>
            <function-required-arg name="host">TestHost</function-required-arg>
        </function-single-arg>
        <sequence>
            <call function="'FileExists'">(host, host.get_uninstaller())</call>
            <if expr="STAXResult == STAFRC.Ok">
                <process name="'RemoveOpenSplice::RunUninstaller'">
                    <location>host.get_staf_url()</location>
                    <command>host.get_uninstaller()</command>
                    <parms>'--mode unattended'</parms>
                </process>
            </if>
            <return>RC</return>
        </sequence>
    </function>

    <function name="CleanupHost">
        <function-prolog>
        <![CDATA[
            <p>Carry out all tasks to clean a host after running testcases.</p>
        ]]>
        </function-prolog>
        <function-single-arg>
            <function-required-arg name="host">TestHost</function-required-arg>
        </function-single-arg>
        <sequence>
            <if expr="host != None">
                <sequence>
                    <if expr="host.is_deployed()">
                        <!-- In case the testcase didn't do it already -->
                        <sequence>
                            <!-- Stop OpenSplice and purge logdir -->
                            <call function="'StopOpenSplice'">host, 1</call>
                            <log if="STAXResult != STAFRC.DoesNotExist" message="STAXMessageLog" level="'info'">
                                'CleanupHost: OpenSplice was not properly stopped on %s\nPlease call StopOpenSplice from inside the \'%s\' testcase.\nResult: %s' % (host.get_hostname(), host.get_scenario(), STAXResult)
                            </log>
                        </sequence>
                    </if>
                    <!-- Call uninstaller (if set) -->
                    <if expr="host.uninstaller != None">
                        <sequence>
                            <call function="'RemoveOpenSplice'">host</call>
                            <log message="STAXMessageLog" if="STAXResult == STAFRC.Ok" level="'info'">'CleanupHost: OpenSplice uninstalled on %s' % host.get_hostname()</log>
                            <log message="STAXMessageLog" if="STAXResult != STAFRC.Ok" level="'error'">'CleanupHost: OpenSplice uninstallation failed on %s' % host.get_hostname()</log>
                        </sequence>
                    </if>
                    <!-- Purge persistent store (if set) -->
                    <if expr="host.get_env('OSPL_PSTORE')">
                        <sequence>
                            <stafcmd name="'CleanupHost::PurgePersistentStore'">
                                <location>host.get_staf_url()</location>
                                <service>'FS'</service>
                                <request>'DELETE ENTRY %s CONFIRM RECURSE' % host.get_env('OSPL_PSTORE')</request>
                            </stafcmd>
                        </sequence>
                    </if>
                    <script>
                        host.set_deployed(0)
                    </script>
                    <call function="'ReleaseHost'">host</call>
                </sequence>
                <else>
                    <log message="STAXMessageLog" level="'debug'">'CleanupHost: Warning function called with invalid host'</log>
                </else>
            </if>
        </sequence>
    </function>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
    <function name="SpawnProcess" scope="local">
        <function-prolog>
            <![CDATA[
            Asynchronously spawns a process without waiting for it to complete
            and returns the handle to the user & stores it on the passed process.
            ]]>
        </function-prolog>

        <function-epilog>
            <![CDATA[
            Will throw an exception if the process fails to start.
            ]]>
        </function-epilog>

        <function-list-args>
            <function-required-arg name="host">
                The host to run the process on.
            </function-required-arg>
            <function-required-arg name="process">
                The process instance that should be run.
            </function-required-arg>
        </function-list-args>

        <sequence>
            <script>
                request = "START SHELL COMMAND %s"% (host.get_process_prearg() + process.get_command())
                if process.get_args() != "":
                    request += " PARMS %s"% process.get_args()
                request += " FOCUS Minimized"
                request += " " + host.get_cmd_envs()
                if process.get_working_dir() != "":
                    request += " WORKDIR %s"% process.get_working_dir()
                if process.get_log_file() != "":
                    request += " STDOUT %s STDERRTOSTDOUT"% process.get_log_file()
            </script>
            <log level="'info'" message="1">
                "SpawnProcess: Starting [%s] on [%s]"% (process.get_command(), host.get_hostname())
            </log>
            <stafcmd name="'Start [%s] on [%s]'% (process.get_command(), host.get_staf_url())">
                <location>
                    host.get_staf_url()
                </location>
                <service>
                    "PROCESS"
                </service>
                <request>
                    request
                </request>
            </stafcmd>
          <if expr="RC != 0">
            <sequence>
                <script>
                    err_msg = "SpawnProcess: Starting [%s] on [%s] failed with result [%s] [%s]"%\
                              (process.get_command(),
                               host.get_hostname(),
                               RC,
                               STAFResult)
                </script>
                <call function="'ShowErrorMsgAndThrowException'">[err_msg, STAXResult, "RunningProcessError"]</call>
            </sequence>
                <else>
                    <sequence>
                        <script>
                            process.set_handle(STAFResult)
                        </script>
                        <log level="'info'" message="1">
                            "SpawnProcess: Started [%s] on [%s] with handle [%d]"% (process.get_command(), host.get_hostname(), process.get_handle())
                        </log>
                        <return>RC</return>
                    </sequence>
                </else>
            </if>
            <return>-1</return>
        </sequence>
    </function>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
    <function name="RunProcess" scope="local">
        <function-prolog>
            <![CDATA[
            Runs a process on a host 'synchronously'.
            Process should be expected to complete within a reasonable time.
            Will timeout otherwise. Optional timeout can be specified.
            ]]>
        </function-prolog>
        <function-epilog>
            <![CDATA[
            Return dictionary {'timed_out':  1 if timed out, 0 if not,
                                'RC':  process return code
                               }
            Will throw an exception if process could not be started.
            ]]>
        </function-epilog>

        <function-list-args>
            <function-required-arg name="host">
                The host to run the process on.
            </function-required-arg>
            <function-required-arg name="process">
                The process instance that should be run.
            </function-required-arg>
            <function-optional-arg name="timeout" default="'60s'">
                A timeout to wait for the process to complete.
            </function-optional-arg>
            <function-optional-arg name="throw_if_err" default="1">
                A timeout to wait for the process to complete.
            </function-optional-arg>
        </function-list-args>

        <sequence>
            <log level="'info'" message="1">
                "RunProcess: Running [%s %s] on [%s]."%\
                (process.get_command(),
                 process.get_args(),
                 host.get_hostname())
            </log>
            <!-- Start with the specified duration -->
            <timer duration="timeout">
                <sequence>
                    <process name="'%s %s on %s'% (process.get_command(), process.get_args(), host.get_staf_url())">
                        <location>
                            host.get_staf_url()
                        </location>
                        <command mode="'shell'">
                            host.get_process_prearg() + process.get_command()
                        </command>
                        <parms>
                            process.get_args()
                        </parms>
                        <workdir>
                            process.get_working_dir()
                        </workdir>
                        <envs>
                            host.get_process_envs()
                        </envs>
                        <stdout>
                            process.get_log_file()
                        </stdout>
                        <stderr mode="'stdout'"/>
                        <returnstdout/>
                        <focus mode="'minimized'"/>
                    </process>

                    <!-- Check -->
                    <script>
                        starting_error = 0
                        if type(RC).__name__ != 'org.python.core.PyLong':
                            starting_error = 1
                    </script>
                    <if expr="starting_error">
                        <sequence>
                            <script>
                                err_msg = "RunProcess: [%s %s] failed on [%s] with result [%s] [%s] [%s]"%\
                                          (process.get_command(),
                                           process.get_args(),
                                           host.get_hostname(),
                                           RC,
                                           STAFResult,
                                           STAXResult)
                            </script>
                            <call function="'ShowErrorMsgAndThrowException'">[err_msg, STAFResult, "RunningProcessError"]</call>
                        </sequence>
                        <else>
                            <return>
                                {'timed_out': 0, 'RC': RC}
                            </return>
                        </else>
                    </if>
                </sequence>
            </timer>
            <!-- Check if process is timed out -->
            <script>
                warn_msg = "RunProcess: [%s %s] timed out on [%s] after [%s]."%\
                           (process.get_command(),
                            process.get_args(),
                            host.get_hostname(),
                            timeout)
            </script>
            <log level="'warning'" message="1">warn_msg</log>
            <return>{'timed_out': 1, 'RC': 1}</return>
        </sequence>
    </function>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
    <function name="TerminateProcess" scope="local">
        <function-prolog>
            <![CDATA[
            Check an asynchronously started process has completed successfully
            with return code 0. Terminate it if it hasn't.
            ]]>
        </function-prolog>
        <function-epilog>
            <![CDATA[
            REturn dictionary {'terminated':  1 if terminated, 0 if not,
                                'RC':  process return code
                               }
            Will free handle resources in at all possible.
            Will only throw exception if the STAF service cannot be contacted.
            ]]>
        </function-epilog>

        <function-list-args>
            <function-required-arg name="host">
                The host to run the process on.
            </function-required-arg>
              <function-required-arg name="process">
                The process instance you want to check and stop.
            </function-required-arg>
        </function-list-args>

        <sequence>
            <log level="'info'" message="1">
                "TerminateProcess: Stopping [%s] with handle [%d] on [%s] "% (process.get_command(), process.get_handle(), host.get_hostname())
            </log>

            <if expr="process.get_handle() == 0">
                <return>0</return>
            </if>

            <script>
                request = "QUERY HANDLE %d"% process.get_handle()
            </script>

            <!-- Check for process exit information and std / out error -->
            <stafcmd name="'Peek at event queue for [%s] on [%s] process exit'% (process.get_command(), host.get_staf_url())">
                <location>
                    host.get_staf_url()
                </location>
                <service>
                    "QUEUE"
                </service>
                <request>
                    "PEEK ALL"
                </request>
            </stafcmd>

            <stafcmd name="'Check [%s] completed.'% process.get_command()">
                <location>
                    host.get_staf_url()
                </location>
                <service>
                    "PROCESS"
                </service>
                <request>
                    request
                </request>
            </stafcmd>

            <if expr="RC != STAFRC.Ok">
                <sequence>
                    <script>
                        err_msg = "TerminateProcess: Checking [%s] on [%s] failed with result [%s] [%s]"%\
                                  (process.get_command(),
                                   host.get_hostname(),
                                   RC,
                                   STAFResult)
                    </script>
                    <call function="'ShowErrorMsgAndThrowException'">[err_msg]</call>
                </sequence>
                <else>
                    <sequence>
                        <if expr="STAFResult['rc'] == None">
                            <sequence>
                                <log level="'info'" message="1">
                                    "Terminating: %s"% process.get_command()
                                </log>

                                <stafcmd name="'Terminate [%s]'% process.get_command()">
                                    <location>
                                        host.get_staf_url()
                                    </location>
                                    <service>
                                        "PROCESS"
                                    </service>
                                    <request>
                                        "STOP HANDLE %d"% process.get_handle()
                                    </request>
                                </stafcmd>
                                <if expr="RC != STAFRC.Ok">
                                    <sequence>
                                        <script>
                                            err_msg = "Terminating process error: terminating [%s] on [%s] failed with result [%s] [%s]"%\
                                                      (process.get_command(),
                                                       host.get_hostname(),
                                                       RC,
                                                       STAFResult)
                                        </script>
                                        <call function="'ShowErrorMsgAndThrowException'">[err_msg]</call>
                                    </sequence>
                                    <else>
                                        <script>result = {'terminated': 1, 'RC': 1}</script>
                                    </else>
                                </if>
                            </sequence>
                            <else>
                                <script>result = {'terminated': 0, 'RC': STAFResult['rc']}</script>
                            </else>
                        </if>
                    </sequence>
                </else>
            </if>

            <!-- Check for process exit information and std / out error -->
            <stafcmd name="'Peek at event queue for [%s] on [%s] process exit'% (process.get_command(), host.get_staf_url())">
                <location>
                    host.get_staf_url()
                </location>
                <service>
                    "QUEUE"
                </service>
                <request>
                    "PEEK ALL"
                </request>
            </stafcmd>

            <if expr="RC == 0">
                <if expr="STAFResult != None">
                    <iterate var="event_record" in="STAFResult">
                         <log level="'info'">event_record</log>
                    </iterate>
                </if>
            </if>

            <stafcmd name="'Free resources from [%s]'% process.get_command()">
                <location>
                    host.get_staf_url()
                </location>
                <service>
                    "PROCESS"
                </service>
                <request>
                    "FREE HANDLE %d"% process.get_handle()
                </request>
            </stafcmd>

          <return>result</return>
        </sequence>
    </function>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
    <function name="CreateLocalhost" scope="local">
        <function-prolog>
            <![CDATA[
            Gets the local tcp port and creates localhost object.
            ]]>
        </function-prolog>
        <function-epilog>
            <![CDATA[
            Functiom returns created TestHost object.
            ]]>
        </function-epilog>
        <sequence>
            <stafcmd name="'Get staf local tcp port'">
                <location>
                    "local"
                </location>
                <service>
                    "MISC"
                </service>
                <request>
                    "list interfaces"
                </request>
            </stafcmd>
            <script>
                error = 0
                try:
                    port = STAFResult[2].get('optionMap').get('Port')
                except:
                    error = 1
            </script>
            <if expr="RC != 0 or error">
                <throw exception="'Host.LocalhostNotCreated'">'Error while getting local tcp port'</throw>
            </if>
            <script>
                localhost = TestHost(hostname = TestHost.LOCAL_HOST_NAME, port = port, targets = [])
            </script>
            <return>localhost</return>
        </sequence>
    </function>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
    <function name="GetEnv" scope="local">
        <function-prolog>
            <![CDATA[
            Gets an environment value from a host
            ]]>
        </function-prolog>
        <function-epilog>
            <![CDATA[
            Returns the variable value or empty string if it can't be resoved on the box.
            ]]>
        </function-epilog>

        <function-list-args>
            <function-required-arg name="host">
                Which host to request the variable from.
            </function-required-arg>
            <function-required-arg name="variable_name">
                The environment variable name required.
            </function-required-arg>
        </function-list-args>

        <sequence>
            <stafcmd>
                <location>
                    host.get_staf_url()
                </location>
                <service>
                    "VAR"
                </service>
                <request>
                    "RESOLVE STRING {STAF/Env/%s}"% variable_name
                </request>
            </stafcmd>

            <!-- If the STAF command request successfully passed then return the value -->
            <if expr="RC == 0">
                <sequence>
                    <return>STAFResult</return>
                </sequence>
            </if>
          <return>""</return>
        </sequence>
    </function>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
    <function name="ShowErrorMsgAndThrowException" scope="local">
        <function-prolog>
            <![CDATA[
            Print the error message using 'error' level.
            And throw the 'ProcessNoWorkyError' exception.
            ]]>
        </function-prolog>
        <function-epilog>
            <![CDATA[
            ]]>
        </function-epilog>

        <function-list-args>
            <function-required-arg name="err_msg">
                The message to be printed.
            </function-required-arg>
            <function-optional-arg name="stax_result" default="None">
                STAXResult to be printed.
            </function-optional-arg>
            <function-optional-arg name="the_exception" default="'ProcessNoWorkyError'">
                The exception to be printed.
            </function-optional-arg>
        </function-list-args>

        <sequence>
            <!-- Print the error message -->
            <call function="'ShowErrorMsg'">[err_msg, stax_result]</call>
            <!-- Throw the execption -->
            <throw exception="the_exception">err_msg</throw>
        </sequence>
    </function>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
    <function name="ShowErrorMsg" scope="local">
        <function-prolog>
            <![CDATA[
            Print the error message using 'error' level.
            ]]>
        </function-prolog>
        <function-epilog>
            <![CDATA[
            ]]>
        </function-epilog>

        <function-list-args>
            <function-required-arg name="err_msg">
                The message to be printed.
            </function-required-arg>
            <function-optional-arg name="stax_result" default="None">
                STAXResult to be printed.
            </function-optional-arg>
        </function-list-args>

        <sequence>
            <!-- Print error message -->
            <log level="'error'" message="1">err_msg</log>
            <!-- Print STAX result -->
            <if expr="stax_result != None">
                <!--<iterate var="file_info" in="stax_result" indexvar="i">
                        <sequence>-->
                            <log level="'error'">stax_result</log>
                        <!--</sequence>
                </iterate>-->
            </if>
        </sequence>
    </function>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

</stax>
