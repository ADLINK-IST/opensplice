<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE stax SYSTEM "../../stax/stax.dtd">
<!--
## \defgroup dds1615 DDS1615 - Configuration of preferred aligner
#
# \b Test \b ID: dds1615
# 
# \b Test \b Objectives: \n
# Verify the preferred aligner selection can be manipulated by placing nodes in a particular role. This is achieved by 
# publishing two sets of samples on two hosts in different roles. While these are the only hosts in their respective roles,
# they will select themselves as preferred aligner. Then a third host is started, in a role that matches one of the other hosts.
# Instead of selecting itself, it will select the host with matching role as its preferred aligner.
# Initial alignment takes place, resulting in a complete set of samples on the third host. The third host is then restarted,
# this time in the role that matches the other host. Behaviour is identical as it will again receive a complete set of samples
# through initial alignment, but this time from the other host. To confirm preferred aligner selections during the test behaved
# as expected the durability tracing logs are analyzed.
#
# \b Prerequisites, \b assumptions, \b constraints
#
# \par \e Environment:
# Three nodes are used in this test with an undisturbed method of communication,
# using the default OpenSplice (reliable broadcast channel) networking features.
#
# \par \e Invariant:
# Nodes A and B are running OpenSplice daemon with networking and durability services enabled on the default domain.
# The topic 'TestTopic' (T1) is used for this test, created with default QoS settings with the following exceptions: durability is set to transient, reliability is set to reliable.      
#
# \par \e Node \e 1:
# Configured to use RoleA. Publisher of a set of instances 0..9 (S1) of topic T1 on the default partition.
# \par \e Node \e 2:
# Configured to use RoleB. Publisher of a set of instances 10..19 (S2) of topic T1 on the default partition.
# \par \e Node \e 3:
# Initially inactive, started later on in the test.
# Configured to use RoleA but during the test the configuration is switched and OpenSplice restarted,
# placing the node in RoleB. Subscriber of topic T1 on the default partition.
#
# \b Test \b Procedure
#
# \b Step \b 1
# \par \e Action
# Start OpenSplice on node 1 (RoleA) and node 2 (RoleB)
# \par \e Result
# OpenSplice daemon and services is started on both nodes, nothing is written to error log.
#
# \b Step \b 2
# \par \e Action
# Create a DataWriter on node 1, write samples S1
# \par \e Result
# The datawriter completes the write operation without errors.
#
# \b Step \b 3
# \par \e Action
# Create a DataWriter on node 2, write samples S2
# \par \e Result
# The datawriter completes the write operation without errors.
#
# \b Step \b 4
# \par \e Action
# Start OpenSplice on node 3
# \par \e Result
# OpenSplice daemon and services are started on node 3. The node is placed in RoleA.
# Initial alignment is triggered when node 1 and node 2 are discovered.
#
# \b Step \b 5
# \par \e Action
# Create a DataReader on NodeC, subscribing to T1 on the default partition.
# Wait 3 seconds for historical data and then take as many samples as possible.
# \par \e Result
# Both sample sets S1 and S2 are read.
#
# \b Step \b 6
# \par \e Action
# Verify the preferred aligner selected by all three nodes
# \par \e Result
# Node 1 has selected itself as preferred aligner since node 3 is initially inactive and node 2 is in a different role,
# but aligns with node 2 since it is the only source of samples S2. Node 2 has selected itself as preferred aligner,
# since node 1 and node 3 are in a different role, but aligns with node 1 since it is the only source of samples S1.
# When started, node 3 selects node 1 as preferred aligner since they are in the same role, and receives S1+S2 by aligning with node 1.
#
# \b Step \b 7
# \par \e Action
# On node 3, restart OpenSplice with a different configuration that places the node in RoleB.
# \par \e Result
# The transient samples are lost on node 3 when OpenSplice is stopped. 
# The node is placed in RoleB when the OpenSplice daemon and services are started with the alternative configuration. 
# Initial alignment is triggered when node 1 and node 2 are discovered.
#
# \b Step \b 8
# \par \e Action
# Repeat step 5 + step 6
# \par \e Result
# The durability service has again aligned with the other nodes, making both sample sets S1 and S2 available on node 3.
# The preferred aligners have changed, this time node 3 selects and aligns from node 2 since they're both in RoleB.
#
# \b Step \b 9
# \par \e Action
# Stop OpenSplice and retrieve logfiles on all three nodes.
# \par \e Result
# OpenSplice and services are properly stopped on all nodes.
 -->
<stax>
    <defaultcall function="Run"/>
    <function name="Run">
        <function-list-args>
            <function-optional-arg name="host1" default="None">
                STAF machine nickname (hostname) of host 1
            </function-optional-arg>
            <function-optional-arg name="host2" default="None">
                STAF machine nickname (hostname) of host 2
            </function-optional-arg>
            <function-optional-arg name="host3" default="None">
                STAF machine nickname (hostname) of host 3
            </function-optional-arg>
        </function-list-args>
        
        <sequence>
            <import file="'../../common/HostManager.xml'"/>
            <import file="'../common/Publisher.xml'"/>
            <import file="'../common/Subscriber.xml'"/>
            <import file="'../../common/DurabilityService.xml'"/>
            <call function="'Initialize'"/>
            
            <script> 
                hostList = [None, None, None]
                portList = [None, None, None]
                samples = [None, None, None]
                expected_samples = [None, None, None]
                
                if ((STAXJobName == None) or (len(STAXJobName) == 0)):
                    STAXJobName = 'Job%d_dds1615_scenario1' % STAXJobID

                uri = os.path.dirname(STAXCurrentXMLFile) + file_sep + 'etc' + file_sep + 'config_dds1615-001.xml'
                
                STAXMessageLog = 1
            </script>
            
            <try> <!-- Catching Resource.* and Testcase.* exceptions -->
                <sequence>
                    <!-- Request/lock three linux machines by hostname or by requesting three random hosts -->
                    <block name="'RequestHosts'">
                        <if expr="(host1 != None) and (host2 != None) and (host3 != None)">
                            <sequence>
                                <call-with-map function="'RequestHost'">
                                    <call-map-arg name="'hostname'">host1</call-map-arg>
                                </call-with-map>
                                <script>hostList[0] = STAXResult</script>
                                <call-with-map function="'RequestHost'">
                                    <call-map-arg name="'hostname'">host2</call-map-arg>
                                </call-with-map>
                                <script>hostList[1] = STAXResult</script>
                                <call-with-map function="'RequestHost'">
                                    <call-map-arg name="'hostname'">host3</call-map-arg>
                                </call-with-map>
                                <script>hostList[2] = STAXResult</script>
                            </sequence>
                            <else>
                                <loop from="0" to="len(hostList) - 1" var="i">
                                    <sequence>
                                        <call-with-map function="'RequestHost'">
                                            <call-map-arg name="'target'">'.*linux.*'</call-map-arg>
                                        </call-with-map>
                                        <script>hostList[i] = STAXResult</script>
                                    </sequence>
                                </loop>
                            </else>
                        </if>
                    </block>
                    
                    <!-- Request/lock three UDP ports during the testcase -->
                    <block name="'RequestPorts'">
                        <loop from="0" to="len(portList) - 1" var="i">
                            <sequence>
                                <call function="'RequestPortResource'"/>
                                <script>
                                    [RC, port] = STAXResult
                                    portList[i] = port
                                </script>
                            </sequence>
                        </loop>
                    </block>
                        
                    <!-- Deploy OpenSplice on the machines and set some common properties -->
                    <block name="'DeployHosts'">
                        <sequence>
                            <paralleliterate in="hostList" var="host">
                                <sequence>
                                    <call-with-map function="'DeployHost'">
                                        <call-map-arg name="'host'">host</call-map-arg>
                                    </call-with-map>
                                    <script>
                                        # Set some common parameters
                                        host.set_scenario('tc_dds1615_preferred_aligner_001')
                                        host.set_env('OSPL_BESTEFFORT_PORT', portList[0])
                                        host.set_env('OSPL_RELIABLE_PORT', portList[1])
                                        host.set_env('OSPL_DISCOVERY_PORT', portList[2])
                                        host.set_env('OSPL_DOMAIN', host.get_scenario())
                                        host.set_env('OSPL_ERRORFILE', host.get_scenario() + '-ospl-error.log')
                                        host.set_env('OSPL_INFOFILE', host.get_scenario() + '-ospl-info.log')
                                        host.set_env('OSPL_DURABILITY_TRACE', host.get_scenario() + '-durability.log')
                                    </script>
                                </sequence>
                            </paralleliterate>
                            <!-- Set initial roles -->
                            <script>
                                # These hosts will keep their role during the testcase
                                hostList[0].set_env('OSPL_ROLE', 'RoleA') 
                                hostList[1].set_env('OSPL_ROLE', 'RoleB')
                                # This host will switch roles in tc_001f
                                hostList[2].set_env('OSPL_ROLE', 'RoleA')
                                hostList[2].set_env('OSPL_DURABILITY_TRACE', hostList[2].get_scenario() + 'RoleA-durability.log')
                            </script>
                        </sequence>
                    </block>
                
                    <block name="'DeployFiles'">
                        <paralleliterate in="hostList" var="host">
                            <sequence>
                                <call function="'DeployPublisher'">host</call>
                                <call function="'DeploySubscriber'">host</call>
                            </sequence>
                        </paralleliterate>
                    </block>
                
                    <block name="'RunScenario'">
                        <sequence>
                            <!-- Global variables to keep track of durability log index between testcases -->
                            <script>
                                logIndex = STAXGlobal([])
                                nodeIds = STAXGlobal([])
                                for host in hostList:
                                    logIndex.append(0)
                                    nodeIds.append(0)
                            </script>
                            
                            <!-- Start two OpenSplice nodes (A1, B1) in two different roles -->
                            <call function="'tc_dds1615_preferred_aligner_001a'"/>
                            
                            <!-- Publish ten distinct instances on each node -->
                            <call function="'tc_dds1615_preferred_aligner_001b'"/>
                            
                            <!-- Start an additional node in RoleA (A2), triggering initial alignment with RoleA -->
                            <call function="'tc_dds1615_preferred_aligner_001c'"/>
                            
                            <!-- Verify node A2 received all samples (A1 + B1) -->
                            <call function="'tc_dds1615_preferred_aligner_001d'"/>
                            
                            <!-- Verify preferred aligner of node A2, it should align with A1 and not with B1) -->
                            <call function="'tc_dds1615_preferred_aligner_001e'"/>
                            
                            <!-- Restart OpenSplice on node A2, switch it to RoleB (B2), triggering initial alignment with RoleB -->
                            <call function="'tc_dds1615_preferred_aligner_001f'"/>
                            
                            <!--Verify node B2 received all samples  -->
                            <call function="'tc_dds1615_preferred_aligner_001g'"/>
                            
                            <!-- Verify node B2 aligned from node B1 and not from node A1 -->
                            <call function="'tc_dds1615_preferred_aligner_001h'"/>
                            
                            <!-- Stop OpenSplice and retrieve logfiles on all three nodes -->
                            <call function="'tc_dds1615_preferred_aligner_001i'"/>
                        </sequence>
                    </block>
                </sequence>
                                
                <catch exception="'Resource'" var="msg">
                    <log message="1">'An exception occurred related to a resource needed to run this test. The test cannot start.\nException: %s' % msg</log>
                </catch>
                <catch exception="'TestCase'" var="msg">
                    <sequence>
                        <log message="1">'An exception occured during a testcase. Succeeding tests are cancelled.\nException: %s' % msg</log>
                        <if expr="STAXCurrentTestcase != None">
                            <tcstatus result="'fail'">'Exception occurred'</tcstatus>
                        </if>
                    </sequence>
                </catch>
                <catch exception="'...'" var="msg">
                    <rethrow/>
                </catch>
                
                <finally>
                    <!-- Release, cleanup resources -->
                    <sequence>
                        <paralleliterate in="hostList" var="host">
                            <if expr="host != None">
                                <call function="'CleanupHost'">host</call>
                            </if>
                        </paralleliterate>
                        <paralleliterate in="portList" var="port">
                            <if expr="port != None">
                                <call function="'ReleasePortResource'">port</call>
                            </if>
                        </paralleliterate>
                    </sequence>
                </finally>
            </try> 
        </sequence>
    </function>
    
    <!-- Start two OpenSplice nodes (A1, B1) in two different roles -->
    <function name="tc_dds1615_preferred_aligner_001a">
        <function-no-args/>
        <testcase name="'tc_dds1615_preferred_aligner_001a'">
            <sequence>
                <script>proceed = STAXGlobal(1)</script>
                <!-- Start OpenSplice -->
                <paralleliterate in="[ hostList[0], hostList[1] ]" var="host">
                    <sequence>
                        <if expr="host.isWindows()">
                            <throw exception="'TestCase.IncompatibleHost'">'This testcase requires Linux hosts, %s is not usable' % host.get_hostname()</throw>
                        </if>
                        <call function="'SetURI'">host, uri</call>
                        <call function="'StartOpenSplice'">host</call>
                        <tcstatus result="'info'">'Started OpenSplice on %s' % host.get_hostname()</tcstatus>
                    </sequence>
                </paralleliterate>
                
                <!-- Wait (max. 30 secs) for persistent source discovery -->
                <paralleliterate in="[ hostList[0], hostList[1] ]" var="host" indexvar="i">
                    <sequence>
                        <script>
                            success = 0
                            # Get the timestamp of service startup, node id, match the start of persistent source discovery state and get timestamp at end of state
                            conditions = []
                            conditions.append(re.compile(R"([0-9]+\.[0-9]+) INIT \(mainThread\) -> Configuration:"))
                            conditions.append(re.compile(R"[0-9]+\.[0-9]+ DISCOVER_FELLOWS_GROUPS \(mainThread\) -> My address is: '([0-9]+)'"))
                            conditions.append(re.compile(R"[0-9]+\.[0-9]+ DISCOVER_PERSISTENT_SOURCE \(mainThread\) -> ----ENTERING STATE----"))
                            conditions.append(re.compile(R"([0-9]+\.[0-9]+) DISCOVER_PERSISTENT_SOURCE \(mainThread\) -> ----LEAVING STATE----")) 
                        </script>
                        <timer duration="'30s'">
                            <loop while="success == 0">
                                <sequence>
                                    <stafcmd name="'PersistentSourceDiscoveryDelay'">
                                        <location>host.get_staf_url()</location>
                                        <service>'DELAY'</service>
                                        <request>'DELAY 5s'</request>
                                    </stafcmd>
                                    <call function="'GetDurabilityLog'">host, 1</call>
                                    <script>log = STAXResult</script>
                                    <if expr="log != None">
                                        <sequence>
                                            <call function="'VerifyLog'">log, conditions</call>
                                            <script>matchIndex, matches = STAXResult</script>
                                            <if expr="len(matches) == len(conditions)">
                                                <sequence>
                                                    <script>
                                                        tsServiceStart = float(matches[0].group(1))
                                                        nodeId = matches[1].group(1)
                                                        nodeIds[i] = nodeId # store durability ID for use later in testcase
                                                        logIndex[i] = matchIndex # store index in durability trace log for later use
                                                        tsEnd = float(matches[3].group(1))
                                                        success = 1
                                                    </script>
                                                    <log message="STAXMessageLog" level="'info'">'Host %s acquired persistent source %.2fs after service start' % (host.get_hostname(), tsEnd-tsServiceStart)</log>
                                                </sequence>
                                                <else>
                                                    <log level="'debug'" message="0">'Host %s failed persistent source discovery\nFailed condition: %s' % (host.get_hostname(), conditions[len(matches)].pattern)</log>
                                                </else>
                                            </if>
                                        </sequence>
                                    </if>
                                </sequence>
                            </loop>
                        </timer>
                        <!-- Timer timeout -->
                        <if expr="RC != 0">
                            <sequence>
                                <script>
                                    proceed.set(0)
                                    msg = 'Failed to verify persistent source discovery on host %s (timeout): ' % host.get_hostname()
                                    if log == None:
                                        msg += 'Could not get durability tracing log'
                                    else:
                                        msg += 'Failed condition (%s)\n' % conditions[len(matches)].pattern
                                        msg += 'Tracing log:\n'
                                        msg += '\n'.join(log)
                                </script>
                                <log message="STAXMessageLog" level="'debug'">msg</log>
                                <tcstatus result="'fail'">'Failed to verify persistent source discovery on host %s (timeout)' % host.get_hostname()</tcstatus>
                            </sequence>
                        </if>
                    </sequence>
                </paralleliterate>
                <if expr="proceed">
                    <tcstatus result="'pass'">'OpenSplice started on host %s and %s' % (hostList[0].get_hostname(), hostList[1].get_hostname())</tcstatus>
                </if>
            </sequence>
        </testcase>
    </function>
    
    <!-- Publish ten distinct instances on each node -->
    <function name="tc_dds1615_preferred_aligner_001b">
        <function-no-args/>
        <testcase name="'tc_dds1615_preferred_aligner_001b'">
            <sequence>
                <!-- Publish samples on host A1 -->
                <if expr="proceed">
                    <sequence>
                        <script>sample_file_a1 = os.path.dirname(STAXCurrentXMLFile) + file_sep + 'etc' + file_sep + 'samples_dds1615-001_A1.txt'</script>
                        <call-with-map function="'Publisher'">
                            <call-map-arg name="'host'">hostList[0]</call-map-arg>
                            <call-map-arg name="'samples'">sample_file_a1</call-map-arg>
                        </call-with-map>
                        <if expr="STAXResult != STAFRC.Ok">
                            <sequence>
                                <script>proceed.set(0)</script>
                                <log message="STAXMessageLog" level="'info'">'Publisher failed on host A1 (%s, RC=%s)' % (hostList[0].get_hostname(), STAXResult)</log>
                                <tcstatus result="'fail'">'Publisher failed on host A1 (%s)' % hostList[0].get_hostname()</tcstatus>
                            </sequence>
                            <else>
                                <log message="STAXMessageLog" level="'info'">'Published 10 samples on host A1 (%s, RC: %s)' % (hostList[0].get_hostname(), STAXResult)</log>
                            </else>
                        </if>
                    </sequence>
                </if>
                <!-- Publish samples on host B1 -->
                <if expr="proceed">
                    <sequence>
                        <script>sample_file_b1 = os.path.dirname(STAXCurrentXMLFile) + file_sep + 'etc' + file_sep + 'samples_dds1615-001_B1.txt'</script>
                        <call-with-map function="'Publisher'">
                            <call-map-arg name="'host'">hostList[1]</call-map-arg>
                            <call-map-arg name="'samples'">sample_file_b1</call-map-arg>
                        </call-with-map>
                        <if expr="STAXResult != STAFRC.Ok">
                            <sequence>
                                <script>proceed.set(0)</script>
                                <log message="STAXMessageLog" level="'info'">'Publisher failed on host B1 (%s, RC=%s)' % (hostList[1].get_hostname(), STAXResult)</log>
                                <tcstatus result="'fail'">'Publisher failed on host B1 (%s)' % hostList[1].get_hostname()</tcstatus>
                            </sequence>
                            <else>
                                <sequence>
                                    <log message="STAXMessageLog" level="'info'">'Published 10 samples on host B1 (%s, RC: %s)' % (hostList[1].get_hostname(), STAXResult)</log>
                                    <tcstatus result="'pass'">'Published 10 distinct samples on host A1 and B1'</tcstatus>       
                                </sequence>     
                            </else>
                        </if>
                    </sequence>
                </if>
            </sequence>
        </testcase>
    </function>
    
    <!-- Start an additional node in RoleA (A2), triggering initial alignment with RoleA -->
    <function name="tc_dds1615_preferred_aligner_001c">
        <function-no-args/>
        <testcase name="'tc_dds1615_preferred_aligner_001c'">
            <if expr="proceed">
                <sequence>
                    <script>host = hostList[2]</script>
    
                    <!-- Start OpenSplice on node 3 -->
                    <if expr="host.isWindows()">
                        <throw exception="'TestCase.IncompatibleHost'">'This testcase requires Linux hosts, %s is not usable' % host.get_hostname()</throw>
                    </if>
                    <call function="'SetURI'">host, uri</call>
                    <call function="'StartOpenSplice'">host</call>
                    <tcstatus result="'info'">'Started OpenSplice on %s' % host.get_hostname()</tcstatus>
                
                    <!-- Wait (max. 30 secs) for persistent source discovery -->
                    <script>
                        success = 0
                        # Get the timestamp of service startup, node id, match the start of persistent source discovery state and get timestamp at end of state
                        conditions = []
                        conditions.append(re.compile(R"([0-9]+\.[0-9]+) INIT \(mainThread\) -> Configuration:"))
                        conditions.append(re.compile(R"[0-9]+\.[0-9]+ DISCOVER_FELLOWS_GROUPS \(mainThread\) -> My address is: '([0-9]+)'"))
                        conditions.append(re.compile(R"[0-9]+\.[0-9]+ DISCOVER_PERSISTENT_SOURCE \(mainThread\) -> ----ENTERING STATE----"))
                        conditions.append(re.compile(R"([0-9]+\.[0-9]+) DISCOVER_PERSISTENT_SOURCE \(mainThread\) -> ----LEAVING STATE----")) 
                    </script>
                    <timer duration="'30s'">
                        <loop while="success == 0">
                            <sequence>
                                <stafcmd name="'PersistentSourceDiscoveryDelay'">
                                    <location>host.get_staf_url()</location>
                                    <service>'DELAY'</service>
                                    <request>'DELAY 5s'</request>
                                </stafcmd>
                                <call function="'GetDurabilityLog'">host, 1</call>
                                <script>log = STAXResult</script>
                                <if expr="log != None">
                                    <sequence>
                                        <call function="'VerifyLog'">log, conditions</call>
                                        <script>matchIndex, matches = STAXResult</script>
                                        <if expr="len(matches) == len(conditions)">
                                            <sequence>
                                                <script>
                                                    tsServiceStart = float(matches[0].group(1))
                                                    nodeId = matches[1].group(1)
                                                    nodeIds[2] = nodeId # store durability ID for use later in testcase
                                                    logIndex[2] = matchIndex # store index in durability trace log for later use
                                                    tsEnd = float(matches[3].group(1))
                                                    success = 1
                                                </script>
                                                <log message="STAXMessageLog" level="'info'">'Host %s acquired persistent source %.2fs after service start' % (host.get_hostname(), tsEnd-tsServiceStart)</log>
                                            </sequence>
                                            <else>
                                                <log level="'debug'" message="0">'Host %s failed persistent source discovery\nFailed condition: %s' % (host.get_hostname(), conditions[len(matches)].pattern)</log>
                                            </else>
                                        </if>
                                    </sequence>
                                </if>
                            </sequence>
                        </loop>
                    </timer>
                    <!-- Timer timeout -->
                    <if expr="RC != 0">
                        <sequence>
                            <script>
                                proceed.set(0)
                                msg = 'Failed to verify persistent source discovery on host %s (timeout): ' % host.get_hostname()
                                if log == None:
                                    msg += 'Could not get durability tracing log'
                                else:
                                    msg += 'Failed condition (%s)\n' % conditions[len(matches)].pattern
                                    msg += 'Tracing log:\n'
                                    msg += '\n'.join(log)
                            </script>
                            <log message="STAXMessageLog" level="'debug'">msg</log>
                            <tcstatus result="'fail'">'Failed to verify persistent source discovery on host %s (timeout)' % host.get_hostname()</tcstatus>
                        </sequence>
                        <else>
                            <tcstatus result="'pass'">'OpenSplice started on host %s' % host.get_hostname()</tcstatus>
                        </else>
                    </if>
                </sequence>
            </if>
        </testcase>
    </function>
    
    <!-- Verify node A2 received all samples (A1 + B1) -->
    <function name="tc_dds1615_preferred_aligner_001d">
        <function-no-args/>
        <testcase name="'tc_dds1615_preferred_aligner_001d'">
            <if expr="proceed">
                <sequence>
                    <script>samples_expected = os.path.dirname(STAXCurrentXMLFile) + file_sep + 'etc' + file_sep + 'samples_dds1615-001_AB.txt'</script>
                    <call-with-map function="'Subscriber'">
                        <call-map-arg name="'host'">hostList[2]</call-map-arg>
                        <call-map-arg name="'samples'">samples_expected</call-map-arg>
                        <call-map-arg name="'take'">1</call-map-arg>
                        <call-map-arg name="'wait'">3000</call-map-arg>
                    </call-with-map>
                    <if expr="STAXResult != STAFRC.Ok">
                        <sequence>
                            <script>proceed.set(0)</script>
                            <log message="STAXMessageLog" level="'info'">'Subscriber failed on host A2 (%s, RC=%s)' % (hostList[2].get_hostname(), STAXResult)</log>
                            <tcstatus result="'fail'">'Subscriber failed on host A2 (%s)' % hostList[2].get_hostname()</tcstatus>
                        </sequence>
                        <else>
                            <sequence>
                                <log message="STAXMessageLog" level="'info'">'Read all expected samples on host A2 (%s, RC: %s)' % (hostList[2].get_hostname(), STAXResult)</log>
                                <tcstatus result="'pass'">'Read all expected samples on host A2'</tcstatus>       
                            </sequence>  
                        </else>
                    </if>
                </sequence>
            </if>
        </testcase>
    </function>

    <!-- Verify preferred aligner of node A2, it should align with A1 and not with B1) -->
    <function name="tc_dds1615_preferred_aligner_001e">
        <function-no-args/>
        <testcase name="'tc_dds1615_preferred_aligner_001e'">
            <!-- Verify preferred aligner based on the roles used by the nodes -->
            <if expr="proceed">
                <sequence>
                    <script>
                        # Sort nodes by role
                        roles = {}
                        for host in hostList:
                            role = host.get_env('OSPL_ROLE')
                            if not role:
                                role = 'defaultRole'
                            if role in roles.keys():
                                roles[role].append(host)
                            else:
                                roles[role] = [host]
                    </script>
                    <paralleliterate in="roles.keys()" var="role">
                        <sequence>
                            <call function="'GetMasterNode'">roles[role], 'defaultNameSpace'</call>
                            <script>rc, msg = STAXResult</script>
                            <if expr="rc">
                                <log message="STAXMessageLog" level="'info'">
                                    'Preferred aligner selection verified for role %s:\n%s' % (role, msg) 
                                </log>
                                <else>
                                    <sequence>
                                        <log message="STAXMessageLog" level="'info'">
                                            'Preferred aligner selection failed for role %s:\n%s' % (role, msg)
                                        </log>
                                        <tcstatus result="'fail'">'Failed to verify preferred aligner for role %s' % role</tcstatus>
                                        <script>proceed.set(0)</script>
                                    </sequence>
                                </else>
                            </if>
                        </sequence>
                    </paralleliterate>
                    <if expr="proceed">
                        <tcstatus result="'pass'">'Verified preferred aligners'</tcstatus>
                    </if>
                </sequence>
            </if>
        </testcase>
    </function>
    
     <!-- Restart OpenSplice on node A2, switch it to RoleB (B2), triggering initial alignment with RoleB -->
    <function name="tc_dds1615_preferred_aligner_001f">
        <function-no-args/>
        <testcase name="'tc_dds1615_preferred_aligner_001f'">
            <if expr="proceed">
                <sequence>                
                    <!-- Stop OpenSplice on host A2 -->
                    <script>host = hostList[2]</script>
                    <call function="'StopOpenSplice'">host</call>
                    <if expr="STAXResult != STAFRC.Ok">
                        <sequence>
                            <tcstatus result="'fail'">'Failure stopping OpenSplice on %s' % host.get_hostname()</tcstatus>
                            <script>proceed.set(0)</script>
                        </sequence>
                        <else>
                            <sequence>
                                <tcstatus result="'info'">'Stopped OpenSplice on %s' % host.get_hostname()</tcstatus>
                                <!-- Switch host to RoleB and start OpenSplice -->
                                <script>
                                    host.set_env('OSPL_ROLE', 'RoleB')
                                    host.set_env('OSPL_DURABILITY_TRACE', host.get_scenario() + 'RoleB-durability.log')
                                </script>
                                <call function="'StartOpenSplice'">host</call>
                                <tcstatus result="'info'">'Started OpenSplice on %s' % host.get_hostname()</tcstatus>
                                
                                <!-- Wait (max. 30 secs) for persistent source discovery -->
                                <script>
                                    success = 0
                                    # Get the timestamp of service startup, node id, match the start of persistent source discovery state and get timestamp at end of state
                                    conditions = []
                                    conditions.append(re.compile(R"([0-9]+\.[0-9]+) INIT \(mainThread\) -> Configuration:"))
                                    conditions.append(re.compile(R"[0-9]+\.[0-9]+ DISCOVER_FELLOWS_GROUPS \(mainThread\) -> My address is: '([0-9]+)'"))
                                    conditions.append(re.compile(R"[0-9]+\.[0-9]+ DISCOVER_PERSISTENT_SOURCE \(mainThread\) -> ----ENTERING STATE----"))
                                    conditions.append(re.compile(R"([0-9]+\.[0-9]+) DISCOVER_PERSISTENT_SOURCE \(mainThread\) -> ----LEAVING STATE----")) 
                                </script>
                                <timer duration="'30s'">
                                    <loop while="success == 0">
                                        <sequence>
                                            <stafcmd name="'PersistentSourceDiscoveryDelay'">
                                                <location>host.get_staf_url()</location>
                                                <service>'DELAY'</service>
                                                <request>'DELAY 5s'</request>
                                            </stafcmd>
                                            <call function="'GetDurabilityLog'">host, 1</call>
                                            <script>log = STAXResult</script>
                                            <if expr="log != None">
                                                <sequence>
                                                    <call function="'VerifyLog'">log, conditions</call>
                                                    <script>matchIndex, matches = STAXResult</script>
                                                    <if expr="len(matches) == len(conditions)">
                                                        <sequence>
                                                            <script>
                                                                tsServiceStart = float(matches[0].group(1))
                                                                nodeId = matches[1].group(1)
                                                                nodeIds[2] = nodeId # store durability ID for use later in testcase
                                                                logIndex[2] = matchIndex # store index in durability trace log for later use
                                                                tsEnd = float(matches[3].group(1))
                                                                success = 1
                                                            </script>
                                                            <log message="STAXMessageLog" level="'info'">'Host %s acquired persistent source %.2fs after service start' % (host.get_hostname(), tsEnd-tsServiceStart)</log>
                                                        </sequence>
                                                        <else>
                                                            <log level="'debug'" message="0">'Host %s failed persistent source discovery\nFailed condition: %s' % (host.get_hostname(), conditions[len(matches)].pattern)</log>
                                                        </else>
                                                    </if>
                                                </sequence>
                                            </if>
                                        </sequence>
                                    </loop>
                                </timer>
                                <!-- Timer timeout -->
                                <if expr="RC != 0">
                                    <sequence>
                                        <script>
                                            proceed.set(0)
                                            msg = 'Failed to verify persistent source discovery on host %s (timeout): ' % host.get_hostname()
                                            if log == None:
                                                msg += 'Could not get durability tracing log'
                                            else:
                                                msg += 'Failed condition (%s)\n' % conditions[len(matches)].pattern
                                                msg += 'Tracing log:\n'
                                                msg += '\n'.join(log)
                                        </script>
                                        <log message="STAXMessageLog" level="'debug'">msg</log>
                                        <tcstatus result="'fail'">'Failed to verify persistent source discovery on host %s (timeout)' % host.get_hostname()</tcstatus>
                                    </sequence>
                                    <else>
                                        <tcstatus result="'pass'">'OpenSplice started on host %s' % host.get_hostname()</tcstatus>
                                    </else>
                                </if>
                            </sequence>
                        </else>
                    </if>
                </sequence>
            </if>
        </testcase>
    </function>
    
    <!--Verify node B2 received all samples  -->
    <function name="tc_dds1615_preferred_aligner_001g">
        <function-no-args/>
        <testcase name="'tc_dds1615_preferred_aligner_001g'">
            <if expr="proceed">
                <sequence>
                    <script>samples_expected = os.path.dirname(STAXCurrentXMLFile) + file_sep + 'etc' + file_sep + 'samples_dds1615-001_AB.txt'</script>
                    <call-with-map function="'Subscriber'">
                        <call-map-arg name="'host'">hostList[2]</call-map-arg>
                        <call-map-arg name="'samples'">samples_expected</call-map-arg>
                        <call-map-arg name="'take'">1</call-map-arg>
                        <call-map-arg name="'wait'">3000</call-map-arg>
                    </call-with-map>
                    <if expr="STAXResult != STAFRC.Ok">
                        <sequence>
                            <script>proceed.set(0)</script>
                            <log message="STAXMessageLog" level="'info'">'Subscriber failed on host B2 (%s, RC=%s)' % (hostList[2].get_hostname(), STAXResult)</log>
                            <tcstatus result="'fail'">'Subscriber failed on host B2 (%s)' % hostList[2].get_hostname()</tcstatus>
                        </sequence>
                        <else>
                            <sequence>
                                <log message="STAXMessageLog" level="'info'">'Read all expected samples on host B2 (%s, RC: %s)' % (hostList[2].get_hostname(), STAXResult)</log>
                                <tcstatus result="'pass'">'Read all expected samples on host B2'</tcstatus>       
                            </sequence>  
                        </else>
                    </if>
                </sequence>
            </if>
        </testcase>
    </function>
    
    <!-- Verify node B2 aligned from node B1 and not from node A1 -->
    <!-- (Identical to tc_dds1615_preferred_aligner_001e) -->    
    <function name="tc_dds1615_preferred_aligner_001h">
        <function-no-args/>
        <testcase name="'tc_dds1615_preferred_aligner_001h'">
            <!-- Verify preferred aligner based on the roles used by the nodes -->
            <if expr="proceed">
                <sequence>
                    <script>
                        # Sort nodes by role
                        roles = {}
                        for host in hostList:
                            role = host.get_env('OSPL_ROLE')
                            if not role:
                                role = 'defaultRole'
                            if role in roles.keys():
                                roles[role].append(host)
                            else:
                                roles[role] = [host]
                    </script>
                    <paralleliterate in="roles.keys()" var="role">
                        <sequence>
                            <call function="'GetMasterNode'">roles[role], 'defaultNameSpace'</call>
                            <script>rc, msg = STAXResult</script>
                            <if expr="rc">
                                <log message="STAXMessageLog" level="'info'">
                                    'Preferred aligner selection verified for role %s:\n%s' % (role, msg) 
                                </log>
                                <else>
                                    <sequence>
                                        <log message="STAXMessageLog" level="'info'">
                                            'Preferred aligner selection failed for role %s:\n%s' % (role, msg)
                                        </log>
                                        <tcstatus result="'fail'">'Failed to verify preferred aligner for role %s' % role</tcstatus>
                                        <script>proceed.set(0)</script>
                                    </sequence>
                                </else>
                            </if>
                        </sequence>
                    </paralleliterate>
                    <if expr="proceed">
                        <tcstatus result="'pass'">'Verified preferred aligners'</tcstatus>
                    </if>
                </sequence>
            </if>
        </testcase>
    </function>
    
    <!-- Stop OpenSplice and retrieve logfiles on all three nodes -->
    <function name="tc_dds1615_preferred_aligner_001i">
        <function-no-args/>
        <testcase name="'tc_dds1615_preferred_aligner_001i'">
            <sequence>
                <script>success = STAXGlobal(1)</script>
                <paralleliterate in="hostList" var="host">
                    <sequence>
                        <call function="'StopOpenSplice'">host</call>
                        <if expr="STAXResult != STAFRC.Ok">
                            <sequence>
                                <tcstatus result="'fail'">'Failure stopping OpenSplice on %s' % host.get_hostname()</tcstatus>
                                <script>success.set(0)</script>
                            </sequence>
                            <else>
                                <tcstatus result="'info'">'Stopped OpenSplice on %s' % host.get_hostname()</tcstatus>
                            </else>
                        </if>
                    </sequence>
                </paralleliterate>
                <if expr="success">
                    <tcstatus result="'pass'">'Stopped OpenSplice on all hosts'</tcstatus>                
                </if>
            </sequence>
        </testcase>
    </function>
</stax>
